/*! jQuery v3.1.1 | (c) jQuery Foundation | jquery.org/license */
!function(a,b){"use strict";"object"==typeof module&&"object"==typeof module.exports?module.exports=a.document?b(a,!0):function(a){if(!a.document)throw new Error("jQuery requires a window with a document");return b(a)}:b(a)}("undefined"!=typeof window?window:this,function(a,b){"use strict";var c=[],d=a.document,e=Object.getPrototypeOf,f=c.slice,g=c.concat,h=c.push,i=c.indexOf,j={},k=j.toString,l=j.hasOwnProperty,m=l.toString,n=m.call(Object),o={};function p(a,b){b=b||d;var c=b.createElement("script");c.text=a,b.head.appendChild(c).parentNode.removeChild(c)}var q="3.1.1",r=function(a,b){return new r.fn.init(a,b)},s=/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g,t=/^-ms-/,u=/-([a-z])/g,v=function(a,b){return b.toUpperCase()};r.fn=r.prototype={jquery:q,constructor:r,length:0,toArray:function(){return f.call(this)},get:function(a){return null==a?f.call(this):a<0?this[a+this.length]:this[a]},pushStack:function(a){var b=r.merge(this.constructor(),a);return b.prevObject=this,b},each:function(a){return r.each(this,a)},map:function(a){return this.pushStack(r.map(this,function(b,c){return a.call(b,c,b)}))},slice:function(){return this.pushStack(f.apply(this,arguments))},first:function(){return this.eq(0)},last:function(){return this.eq(-1)},eq:function(a){var b=this.length,c=+a+(a<0?b:0);return this.pushStack(c>=0&&c<b?[this[c]]:[])},end:function(){return this.prevObject||this.constructor()},push:h,sort:c.sort,splice:c.splice},r.extend=r.fn.extend=function(){var a,b,c,d,e,f,g=arguments[0]||{},h=1,i=arguments.length,j=!1;for("boolean"==typeof g&&(j=g,g=arguments[h]||{},h++),"object"==typeof g||r.isFunction(g)||(g={}),h===i&&(g=this,h--);h<i;h++)if(null!=(a=arguments[h]))for(b in a)c=g[b],d=a[b],g!==d&&(j&&d&&(r.isPlainObject(d)||(e=r.isArray(d)))?(e?(e=!1,f=c&&r.isArray(c)?c:[]):f=c&&r.isPlainObject(c)?c:{},g[b]=r.extend(j,f,d)):void 0!==d&&(g[b]=d));return g},r.extend({expando:"jQuery"+(q+Math.random()).replace(/\D/g,""),isReady:!0,error:function(a){throw new Error(a)},noop:function(){},isFunction:function(a){return"function"===r.type(a)},isArray:Array.isArray,isWindow:function(a){return null!=a&&a===a.window},isNumeric:function(a){var b=r.type(a);return("number"===b||"string"===b)&&!isNaN(a-parseFloat(a))},isPlainObject:function(a){var b,c;return!(!a||"[object Object]"!==k.call(a))&&(!(b=e(a))||(c=l.call(b,"constructor")&&b.constructor,"function"==typeof c&&m.call(c)===n))},isEmptyObject:function(a){var b;for(b in a)return!1;return!0},type:function(a){return null==a?a+"":"object"==typeof a||"function"==typeof a?j[k.call(a)]||"object":typeof a},globalEval:function(a){p(a)},camelCase:function(a){return a.replace(t,"ms-").replace(u,v)},nodeName:function(a,b){return a.nodeName&&a.nodeName.toLowerCase()===b.toLowerCase()},each:function(a,b){var c,d=0;if(w(a)){for(c=a.length;d<c;d++)if(b.call(a[d],d,a[d])===!1)break}else for(d in a)if(b.call(a[d],d,a[d])===!1)break;return a},trim:function(a){return null==a?"":(a+"").replace(s,"")},makeArray:function(a,b){var c=b||[];return null!=a&&(w(Object(a))?r.merge(c,"string"==typeof a?[a]:a):h.call(c,a)),c},inArray:function(a,b,c){return null==b?-1:i.call(b,a,c)},merge:function(a,b){for(var c=+b.length,d=0,e=a.length;d<c;d++)a[e++]=b[d];return a.length=e,a},grep:function(a,b,c){for(var d,e=[],f=0,g=a.length,h=!c;f<g;f++)d=!b(a[f],f),d!==h&&e.push(a[f]);return e},map:function(a,b,c){var d,e,f=0,h=[];if(w(a))for(d=a.length;f<d;f++)e=b(a[f],f,c),null!=e&&h.push(e);else for(f in a)e=b(a[f],f,c),null!=e&&h.push(e);return g.apply([],h)},guid:1,proxy:function(a,b){var c,d,e;if("string"==typeof b&&(c=a[b],b=a,a=c),r.isFunction(a))return d=f.call(arguments,2),e=function(){return a.apply(b||this,d.concat(f.call(arguments)))},e.guid=a.guid=a.guid||r.guid++,e},now:Date.now,support:o}),"function"==typeof Symbol&&(r.fn[Symbol.iterator]=c[Symbol.iterator]),r.each("Boolean Number String Function Array Date RegExp Object Error Symbol".split(" "),function(a,b){j["[object "+b+"]"]=b.toLowerCase()});function w(a){var b=!!a&&"length"in a&&a.length,c=r.type(a);return"function"!==c&&!r.isWindow(a)&&("array"===c||0===b||"number"==typeof b&&b>0&&b-1 in a)}var x=function(a){var b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u="sizzle"+1*new Date,v=a.document,w=0,x=0,y=ha(),z=ha(),A=ha(),B=function(a,b){return a===b&&(l=!0),0},C={}.hasOwnProperty,D=[],E=D.pop,F=D.push,G=D.push,H=D.slice,I=function(a,b){for(var c=0,d=a.length;c<d;c++)if(a[c]===b)return c;return-1},J="checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",K="[\\x20\\t\\r\\n\\f]",L="(?:\\\\.|[\\w-]|[^\0-\\xa0])+",M="\\["+K+"*("+L+")(?:"+K+"*([*^$|!~]?=)"+K+"*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|("+L+"))|)"+K+"*\\]",N=":("+L+")(?:\\((('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|((?:\\\\.|[^\\\\()[\\]]|"+M+")*)|.*)\\)|)",O=new RegExp(K+"+","g"),P=new RegExp("^"+K+"+|((?:^|[^\\\\])(?:\\\\.)*)"+K+"+$","g"),Q=new RegExp("^"+K+"*,"+K+"*"),R=new RegExp("^"+K+"*([>+~]|"+K+")"+K+"*"),S=new RegExp("="+K+"*([^\\]'\"]*?)"+K+"*\\]","g"),T=new RegExp(N),U=new RegExp("^"+L+"$"),V={ID:new RegExp("^#("+L+")"),CLASS:new RegExp("^\\.("+L+")"),TAG:new RegExp("^("+L+"|[*])"),ATTR:new RegExp("^"+M),PSEUDO:new RegExp("^"+N),CHILD:new RegExp("^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\("+K+"*(even|odd|(([+-]|)(\\d*)n|)"+K+"*(?:([+-]|)"+K+"*(\\d+)|))"+K+"*\\)|)","i"),bool:new RegExp("^(?:"+J+")$","i"),needsContext:new RegExp("^"+K+"*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\("+K+"*((?:-\\d)?\\d*)"+K+"*\\)|)(?=[^-]|$)","i")},W=/^(?:input|select|textarea|button)$/i,X=/^h\d$/i,Y=/^[^{]+\{\s*\[native \w/,Z=/^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,$=/[+~]/,_=new RegExp("\\\\([\\da-f]{1,6}"+K+"?|("+K+")|.)","ig"),aa=function(a,b,c){var d="0x"+b-65536;return d!==d||c?b:d<0?String.fromCharCode(d+65536):String.fromCharCode(d>>10|55296,1023&d|56320)},ba=/([\0-\x1f\x7f]|^-?\d)|^-$|[^\0-\x1f\x7f-\uFFFF\w-]/g,ca=function(a,b){return b?"\0"===a?"\ufffd":a.slice(0,-1)+"\\"+a.charCodeAt(a.length-1).toString(16)+" ":"\\"+a},da=function(){m()},ea=ta(function(a){return a.disabled===!0&&("form"in a||"label"in a)},{dir:"parentNode",next:"legend"});try{G.apply(D=H.call(v.childNodes),v.childNodes),D[v.childNodes.length].nodeType}catch(fa){G={apply:D.length?function(a,b){F.apply(a,H.call(b))}:function(a,b){var c=a.length,d=0;while(a[c++]=b[d++]);a.length=c-1}}}function ga(a,b,d,e){var f,h,j,k,l,o,r,s=b&&b.ownerDocument,w=b?b.nodeType:9;if(d=d||[],"string"!=typeof a||!a||1!==w&&9!==w&&11!==w)return d;if(!e&&((b?b.ownerDocument||b:v)!==n&&m(b),b=b||n,p)){if(11!==w&&(l=Z.exec(a)))if(f=l[1]){if(9===w){if(!(j=b.getElementById(f)))return d;if(j.id===f)return d.push(j),d}else if(s&&(j=s.getElementById(f))&&t(b,j)&&j.id===f)return d.push(j),d}else{if(l[2])return G.apply(d,b.getElementsByTagName(a)),d;if((f=l[3])&&c.getElementsByClassName&&b.getElementsByClassName)return G.apply(d,b.getElementsByClassName(f)),d}if(c.qsa&&!A[a+" "]&&(!q||!q.test(a))){if(1!==w)s=b,r=a;else if("object"!==b.nodeName.toLowerCase()){(k=b.getAttribute("id"))?k=k.replace(ba,ca):b.setAttribute("id",k=u),o=g(a),h=o.length;while(h--)o[h]="#"+k+" "+sa(o[h]);r=o.join(","),s=$.test(a)&&qa(b.parentNode)||b}if(r)try{return G.apply(d,s.querySelectorAll(r)),d}catch(x){}finally{k===u&&b.removeAttribute("id")}}}return i(a.replace(P,"$1"),b,d,e)}function ha(){var a=[];function b(c,e){return a.push(c+" ")>d.cacheLength&&delete b[a.shift()],b[c+" "]=e}return b}function ia(a){return a[u]=!0,a}function ja(a){var b=n.createElement("fieldset");try{return!!a(b)}catch(c){return!1}finally{b.parentNode&&b.parentNode.removeChild(b),b=null}}function ka(a,b){var c=a.split("|"),e=c.length;while(e--)d.attrHandle[c[e]]=b}function la(a,b){var c=b&&a,d=c&&1===a.nodeType&&1===b.nodeType&&a.sourceIndex-b.sourceIndex;if(d)return d;if(c)while(c=c.nextSibling)if(c===b)return-1;return a?1:-1}function ma(a){return function(b){var c=b.nodeName.toLowerCase();return"input"===c&&b.type===a}}function na(a){return function(b){var c=b.nodeName.toLowerCase();return("input"===c||"button"===c)&&b.type===a}}function oa(a){return function(b){return"form"in b?b.parentNode&&b.disabled===!1?"label"in b?"label"in b.parentNode?b.parentNode.disabled===a:b.disabled===a:b.isDisabled===a||b.isDisabled!==!a&&ea(b)===a:b.disabled===a:"label"in b&&b.disabled===a}}function pa(a){return ia(function(b){return b=+b,ia(function(c,d){var e,f=a([],c.length,b),g=f.length;while(g--)c[e=f[g]]&&(c[e]=!(d[e]=c[e]))})})}function qa(a){return a&&"undefined"!=typeof a.getElementsByTagName&&a}c=ga.support={},f=ga.isXML=function(a){var b=a&&(a.ownerDocument||a).documentElement;return!!b&&"HTML"!==b.nodeName},m=ga.setDocument=function(a){var b,e,g=a?a.ownerDocument||a:v;return g!==n&&9===g.nodeType&&g.documentElement?(n=g,o=n.documentElement,p=!f(n),v!==n&&(e=n.defaultView)&&e.top!==e&&(e.addEventListener?e.addEventListener("unload",da,!1):e.attachEvent&&e.attachEvent("onunload",da)),c.attributes=ja(function(a){return a.className="i",!a.getAttribute("className")}),c.getElementsByTagName=ja(function(a){return a.appendChild(n.createComment("")),!a.getElementsByTagName("*").length}),c.getElementsByClassName=Y.test(n.getElementsByClassName),c.getById=ja(function(a){return o.appendChild(a).id=u,!n.getElementsByName||!n.getElementsByName(u).length}),c.getById?(d.filter.ID=function(a){var b=a.replace(_,aa);return function(a){return a.getAttribute("id")===b}},d.find.ID=function(a,b){if("undefined"!=typeof b.getElementById&&p){var c=b.getElementById(a);return c?[c]:[]}}):(d.filter.ID=function(a){var b=a.replace(_,aa);return function(a){var c="undefined"!=typeof a.getAttributeNode&&a.getAttributeNode("id");return c&&c.value===b}},d.find.ID=function(a,b){if("undefined"!=typeof b.getElementById&&p){var c,d,e,f=b.getElementById(a);if(f){if(c=f.getAttributeNode("id"),c&&c.value===a)return[f];e=b.getElementsByName(a),d=0;while(f=e[d++])if(c=f.getAttributeNode("id"),c&&c.value===a)return[f]}return[]}}),d.find.TAG=c.getElementsByTagName?function(a,b){return"undefined"!=typeof b.getElementsByTagName?b.getElementsByTagName(a):c.qsa?b.querySelectorAll(a):void 0}:function(a,b){var c,d=[],e=0,f=b.getElementsByTagName(a);if("*"===a){while(c=f[e++])1===c.nodeType&&d.push(c);return d}return f},d.find.CLASS=c.getElementsByClassName&&function(a,b){if("undefined"!=typeof b.getElementsByClassName&&p)return b.getElementsByClassName(a)},r=[],q=[],(c.qsa=Y.test(n.querySelectorAll))&&(ja(function(a){o.appendChild(a).innerHTML="<a id='"+u+"'></a><select id='"+u+"-\r\\' msallowcapture=''><option selected=''></option></select>",a.querySelectorAll("[msallowcapture^='']").length&&q.push("[*^$]="+K+"*(?:''|\"\")"),a.querySelectorAll("[selected]").length||q.push("\\["+K+"*(?:value|"+J+")"),a.querySelectorAll("[id~="+u+"-]").length||q.push("~="),a.querySelectorAll(":checked").length||q.push(":checked"),a.querySelectorAll("a#"+u+"+*").length||q.push(".#.+[+~]")}),ja(function(a){a.innerHTML="<a href='' disabled='disabled'></a><select disabled='disabled'><option/></select>";var b=n.createElement("input");b.setAttribute("type","hidden"),a.appendChild(b).setAttribute("name","D"),a.querySelectorAll("[name=d]").length&&q.push("name"+K+"*[*^$|!~]?="),2!==a.querySelectorAll(":enabled").length&&q.push(":enabled",":disabled"),o.appendChild(a).disabled=!0,2!==a.querySelectorAll(":disabled").length&&q.push(":enabled",":disabled"),a.querySelectorAll("*,:x"),q.push(",.*:")})),(c.matchesSelector=Y.test(s=o.matches||o.webkitMatchesSelector||o.mozMatchesSelector||o.oMatchesSelector||o.msMatchesSelector))&&ja(function(a){c.disconnectedMatch=s.call(a,"*"),s.call(a,"[s!='']:x"),r.push("!=",N)}),q=q.length&&new RegExp(q.join("|")),r=r.length&&new RegExp(r.join("|")),b=Y.test(o.compareDocumentPosition),t=b||Y.test(o.contains)?function(a,b){var c=9===a.nodeType?a.documentElement:a,d=b&&b.parentNode;return a===d||!(!d||1!==d.nodeType||!(c.contains?c.contains(d):a.compareDocumentPosition&&16&a.compareDocumentPosition(d)))}:function(a,b){if(b)while(b=b.parentNode)if(b===a)return!0;return!1},B=b?function(a,b){if(a===b)return l=!0,0;var d=!a.compareDocumentPosition-!b.compareDocumentPosition;return d?d:(d=(a.ownerDocument||a)===(b.ownerDocument||b)?a.compareDocumentPosition(b):1,1&d||!c.sortDetached&&b.compareDocumentPosition(a)===d?a===n||a.ownerDocument===v&&t(v,a)?-1:b===n||b.ownerDocument===v&&t(v,b)?1:k?I(k,a)-I(k,b):0:4&d?-1:1)}:function(a,b){if(a===b)return l=!0,0;var c,d=0,e=a.parentNode,f=b.parentNode,g=[a],h=[b];if(!e||!f)return a===n?-1:b===n?1:e?-1:f?1:k?I(k,a)-I(k,b):0;if(e===f)return la(a,b);c=a;while(c=c.parentNode)g.unshift(c);c=b;while(c=c.parentNode)h.unshift(c);while(g[d]===h[d])d++;return d?la(g[d],h[d]):g[d]===v?-1:h[d]===v?1:0},n):n},ga.matches=function(a,b){return ga(a,null,null,b)},ga.matchesSelector=function(a,b){if((a.ownerDocument||a)!==n&&m(a),b=b.replace(S,"='$1']"),c.matchesSelector&&p&&!A[b+" "]&&(!r||!r.test(b))&&(!q||!q.test(b)))try{var d=s.call(a,b);if(d||c.disconnectedMatch||a.document&&11!==a.document.nodeType)return d}catch(e){}return ga(b,n,null,[a]).length>0},ga.contains=function(a,b){return(a.ownerDocument||a)!==n&&m(a),t(a,b)},ga.attr=function(a,b){(a.ownerDocument||a)!==n&&m(a);var e=d.attrHandle[b.toLowerCase()],f=e&&C.call(d.attrHandle,b.toLowerCase())?e(a,b,!p):void 0;return void 0!==f?f:c.attributes||!p?a.getAttribute(b):(f=a.getAttributeNode(b))&&f.specified?f.value:null},ga.escape=function(a){return(a+"").replace(ba,ca)},ga.error=function(a){throw new Error("Syntax error, unrecognized expression: "+a)},ga.uniqueSort=function(a){var b,d=[],e=0,f=0;if(l=!c.detectDuplicates,k=!c.sortStable&&a.slice(0),a.sort(B),l){while(b=a[f++])b===a[f]&&(e=d.push(f));while(e--)a.splice(d[e],1)}return k=null,a},e=ga.getText=function(a){var b,c="",d=0,f=a.nodeType;if(f){if(1===f||9===f||11===f){if("string"==typeof a.textContent)return a.textContent;for(a=a.firstChild;a;a=a.nextSibling)c+=e(a)}else if(3===f||4===f)return a.nodeValue}else while(b=a[d++])c+=e(b);return c},d=ga.selectors={cacheLength:50,createPseudo:ia,match:V,attrHandle:{},find:{},relative:{">":{dir:"parentNode",first:!0}," ":{dir:"parentNode"},"+":{dir:"previousSibling",first:!0},"~":{dir:"previousSibling"}},preFilter:{ATTR:function(a){return a[1]=a[1].replace(_,aa),a[3]=(a[3]||a[4]||a[5]||"").replace(_,aa),"~="===a[2]&&(a[3]=" "+a[3]+" "),a.slice(0,4)},CHILD:function(a){return a[1]=a[1].toLowerCase(),"nth"===a[1].slice(0,3)?(a[3]||ga.error(a[0]),a[4]=+(a[4]?a[5]+(a[6]||1):2*("even"===a[3]||"odd"===a[3])),a[5]=+(a[7]+a[8]||"odd"===a[3])):a[3]&&ga.error(a[0]),a},PSEUDO:function(a){var b,c=!a[6]&&a[2];return V.CHILD.test(a[0])?null:(a[3]?a[2]=a[4]||a[5]||"":c&&T.test(c)&&(b=g(c,!0))&&(b=c.indexOf(")",c.length-b)-c.length)&&(a[0]=a[0].slice(0,b),a[2]=c.slice(0,b)),a.slice(0,3))}},filter:{TAG:function(a){var b=a.replace(_,aa).toLowerCase();return"*"===a?function(){return!0}:function(a){return a.nodeName&&a.nodeName.toLowerCase()===b}},CLASS:function(a){var b=y[a+" "];return b||(b=new RegExp("(^|"+K+")"+a+"("+K+"|$)"))&&y(a,function(a){return b.test("string"==typeof a.className&&a.className||"undefined"!=typeof a.getAttribute&&a.getAttribute("class")||"")})},ATTR:function(a,b,c){return function(d){var e=ga.attr(d,a);return null==e?"!="===b:!b||(e+="","="===b?e===c:"!="===b?e!==c:"^="===b?c&&0===e.indexOf(c):"*="===b?c&&e.indexOf(c)>-1:"$="===b?c&&e.slice(-c.length)===c:"~="===b?(" "+e.replace(O," ")+" ").indexOf(c)>-1:"|="===b&&(e===c||e.slice(0,c.length+1)===c+"-"))}},CHILD:function(a,b,c,d,e){var f="nth"!==a.slice(0,3),g="last"!==a.slice(-4),h="of-type"===b;return 1===d&&0===e?function(a){return!!a.parentNode}:function(b,c,i){var j,k,l,m,n,o,p=f!==g?"nextSibling":"previousSibling",q=b.parentNode,r=h&&b.nodeName.toLowerCase(),s=!i&&!h,t=!1;if(q){if(f){while(p){m=b;while(m=m[p])if(h?m.nodeName.toLowerCase()===r:1===m.nodeType)return!1;o=p="only"===a&&!o&&"nextSibling"}return!0}if(o=[g?q.firstChild:q.lastChild],g&&s){m=q,l=m[u]||(m[u]={}),k=l[m.uniqueID]||(l[m.uniqueID]={}),j=k[a]||[],n=j[0]===w&&j[1],t=n&&j[2],m=n&&q.childNodes[n];while(m=++n&&m&&m[p]||(t=n=0)||o.pop())if(1===m.nodeType&&++t&&m===b){k[a]=[w,n,t];break}}else if(s&&(m=b,l=m[u]||(m[u]={}),k=l[m.uniqueID]||(l[m.uniqueID]={}),j=k[a]||[],n=j[0]===w&&j[1],t=n),t===!1)while(m=++n&&m&&m[p]||(t=n=0)||o.pop())if((h?m.nodeName.toLowerCase()===r:1===m.nodeType)&&++t&&(s&&(l=m[u]||(m[u]={}),k=l[m.uniqueID]||(l[m.uniqueID]={}),k[a]=[w,t]),m===b))break;return t-=e,t===d||t%d===0&&t/d>=0}}},PSEUDO:function(a,b){var c,e=d.pseudos[a]||d.setFilters[a.toLowerCase()]||ga.error("unsupported pseudo: "+a);return e[u]?e(b):e.length>1?(c=[a,a,"",b],d.setFilters.hasOwnProperty(a.toLowerCase())?ia(function(a,c){var d,f=e(a,b),g=f.length;while(g--)d=I(a,f[g]),a[d]=!(c[d]=f[g])}):function(a){return e(a,0,c)}):e}},pseudos:{not:ia(function(a){var b=[],c=[],d=h(a.replace(P,"$1"));return d[u]?ia(function(a,b,c,e){var f,g=d(a,null,e,[]),h=a.length;while(h--)(f=g[h])&&(a[h]=!(b[h]=f))}):function(a,e,f){return b[0]=a,d(b,null,f,c),b[0]=null,!c.pop()}}),has:ia(function(a){return function(b){return ga(a,b).length>0}}),contains:ia(function(a){return a=a.replace(_,aa),function(b){return(b.textContent||b.innerText||e(b)).indexOf(a)>-1}}),lang:ia(function(a){return U.test(a||"")||ga.error("unsupported lang: "+a),a=a.replace(_,aa).toLowerCase(),function(b){var c;do if(c=p?b.lang:b.getAttribute("xml:lang")||b.getAttribute("lang"))return c=c.toLowerCase(),c===a||0===c.indexOf(a+"-");while((b=b.parentNode)&&1===b.nodeType);return!1}}),target:function(b){var c=a.location&&a.location.hash;return c&&c.slice(1)===b.id},root:function(a){return a===o},focus:function(a){return a===n.activeElement&&(!n.hasFocus||n.hasFocus())&&!!(a.type||a.href||~a.tabIndex)},enabled:oa(!1),disabled:oa(!0),checked:function(a){var b=a.nodeName.toLowerCase();return"input"===b&&!!a.checked||"option"===b&&!!a.selected},selected:function(a){return a.parentNode&&a.parentNode.selectedIndex,a.selected===!0},empty:function(a){for(a=a.firstChild;a;a=a.nextSibling)if(a.nodeType<6)return!1;return!0},parent:function(a){return!d.pseudos.empty(a)},header:function(a){return X.test(a.nodeName)},input:function(a){return W.test(a.nodeName)},button:function(a){var b=a.nodeName.toLowerCase();return"input"===b&&"button"===a.type||"button"===b},text:function(a){var b;return"input"===a.nodeName.toLowerCase()&&"text"===a.type&&(null==(b=a.getAttribute("type"))||"text"===b.toLowerCase())},first:pa(function(){return[0]}),last:pa(function(a,b){return[b-1]}),eq:pa(function(a,b,c){return[c<0?c+b:c]}),even:pa(function(a,b){for(var c=0;c<b;c+=2)a.push(c);return a}),odd:pa(function(a,b){for(var c=1;c<b;c+=2)a.push(c);return a}),lt:pa(function(a,b,c){for(var d=c<0?c+b:c;--d>=0;)a.push(d);return a}),gt:pa(function(a,b,c){for(var d=c<0?c+b:c;++d<b;)a.push(d);return a})}},d.pseudos.nth=d.pseudos.eq;for(b in{radio:!0,checkbox:!0,file:!0,password:!0,image:!0})d.pseudos[b]=ma(b);for(b in{submit:!0,reset:!0})d.pseudos[b]=na(b);function ra(){}ra.prototype=d.filters=d.pseudos,d.setFilters=new ra,g=ga.tokenize=function(a,b){var c,e,f,g,h,i,j,k=z[a+" "];if(k)return b?0:k.slice(0);h=a,i=[],j=d.preFilter;while(h){c&&!(e=Q.exec(h))||(e&&(h=h.slice(e[0].length)||h),i.push(f=[])),c=!1,(e=R.exec(h))&&(c=e.shift(),f.push({value:c,type:e[0].replace(P," ")}),h=h.slice(c.length));for(g in d.filter)!(e=V[g].exec(h))||j[g]&&!(e=j[g](e))||(c=e.shift(),f.push({value:c,type:g,matches:e}),h=h.slice(c.length));if(!c)break}return b?h.length:h?ga.error(a):z(a,i).slice(0)};function sa(a){for(var b=0,c=a.length,d="";b<c;b++)d+=a[b].value;return d}function ta(a,b,c){var d=b.dir,e=b.next,f=e||d,g=c&&"parentNode"===f,h=x++;return b.first?function(b,c,e){while(b=b[d])if(1===b.nodeType||g)return a(b,c,e);return!1}:function(b,c,i){var j,k,l,m=[w,h];if(i){while(b=b[d])if((1===b.nodeType||g)&&a(b,c,i))return!0}else while(b=b[d])if(1===b.nodeType||g)if(l=b[u]||(b[u]={}),k=l[b.uniqueID]||(l[b.uniqueID]={}),e&&e===b.nodeName.toLowerCase())b=b[d]||b;else{if((j=k[f])&&j[0]===w&&j[1]===h)return m[2]=j[2];if(k[f]=m,m[2]=a(b,c,i))return!0}return!1}}function ua(a){return a.length>1?function(b,c,d){var e=a.length;while(e--)if(!a[e](b,c,d))return!1;return!0}:a[0]}function va(a,b,c){for(var d=0,e=b.length;d<e;d++)ga(a,b[d],c);return c}function wa(a,b,c,d,e){for(var f,g=[],h=0,i=a.length,j=null!=b;h<i;h++)(f=a[h])&&(c&&!c(f,d,e)||(g.push(f),j&&b.push(h)));return g}function xa(a,b,c,d,e,f){return d&&!d[u]&&(d=xa(d)),e&&!e[u]&&(e=xa(e,f)),ia(function(f,g,h,i){var j,k,l,m=[],n=[],o=g.length,p=f||va(b||"*",h.nodeType?[h]:h,[]),q=!a||!f&&b?p:wa(p,m,a,h,i),r=c?e||(f?a:o||d)?[]:g:q;if(c&&c(q,r,h,i),d){j=wa(r,n),d(j,[],h,i),k=j.length;while(k--)(l=j[k])&&(r[n[k]]=!(q[n[k]]=l))}if(f){if(e||a){if(e){j=[],k=r.length;while(k--)(l=r[k])&&j.push(q[k]=l);e(null,r=[],j,i)}k=r.length;while(k--)(l=r[k])&&(j=e?I(f,l):m[k])>-1&&(f[j]=!(g[j]=l))}}else r=wa(r===g?r.splice(o,r.length):r),e?e(null,g,r,i):G.apply(g,r)})}function ya(a){for(var b,c,e,f=a.length,g=d.relative[a[0].type],h=g||d.relative[" "],i=g?1:0,k=ta(function(a){return a===b},h,!0),l=ta(function(a){return I(b,a)>-1},h,!0),m=[function(a,c,d){var e=!g&&(d||c!==j)||((b=c).nodeType?k(a,c,d):l(a,c,d));return b=null,e}];i<f;i++)if(c=d.relative[a[i].type])m=[ta(ua(m),c)];else{if(c=d.filter[a[i].type].apply(null,a[i].matches),c[u]){for(e=++i;e<f;e++)if(d.relative[a[e].type])break;return xa(i>1&&ua(m),i>1&&sa(a.slice(0,i-1).concat({value:" "===a[i-2].type?"*":""})).replace(P,"$1"),c,i<e&&ya(a.slice(i,e)),e<f&&ya(a=a.slice(e)),e<f&&sa(a))}m.push(c)}return ua(m)}function za(a,b){var c=b.length>0,e=a.length>0,f=function(f,g,h,i,k){var l,o,q,r=0,s="0",t=f&&[],u=[],v=j,x=f||e&&d.find.TAG("*",k),y=w+=null==v?1:Math.random()||.1,z=x.length;for(k&&(j=g===n||g||k);s!==z&&null!=(l=x[s]);s++){if(e&&l){o=0,g||l.ownerDocument===n||(m(l),h=!p);while(q=a[o++])if(q(l,g||n,h)){i.push(l);break}k&&(w=y)}c&&((l=!q&&l)&&r--,f&&t.push(l))}if(r+=s,c&&s!==r){o=0;while(q=b[o++])q(t,u,g,h);if(f){if(r>0)while(s--)t[s]||u[s]||(u[s]=E.call(i));u=wa(u)}G.apply(i,u),k&&!f&&u.length>0&&r+b.length>1&&ga.uniqueSort(i)}return k&&(w=y,j=v),t};return c?ia(f):f}return h=ga.compile=function(a,b){var c,d=[],e=[],f=A[a+" "];if(!f){b||(b=g(a)),c=b.length;while(c--)f=ya(b[c]),f[u]?d.push(f):e.push(f);f=A(a,za(e,d)),f.selector=a}return f},i=ga.select=function(a,b,c,e){var f,i,j,k,l,m="function"==typeof a&&a,n=!e&&g(a=m.selector||a);if(c=c||[],1===n.length){if(i=n[0]=n[0].slice(0),i.length>2&&"ID"===(j=i[0]).type&&9===b.nodeType&&p&&d.relative[i[1].type]){if(b=(d.find.ID(j.matches[0].replace(_,aa),b)||[])[0],!b)return c;m&&(b=b.parentNode),a=a.slice(i.shift().value.length)}f=V.needsContext.test(a)?0:i.length;while(f--){if(j=i[f],d.relative[k=j.type])break;if((l=d.find[k])&&(e=l(j.matches[0].replace(_,aa),$.test(i[0].type)&&qa(b.parentNode)||b))){if(i.splice(f,1),a=e.length&&sa(i),!a)return G.apply(c,e),c;break}}}return(m||h(a,n))(e,b,!p,c,!b||$.test(a)&&qa(b.parentNode)||b),c},c.sortStable=u.split("").sort(B).join("")===u,c.detectDuplicates=!!l,m(),c.sortDetached=ja(function(a){return 1&a.compareDocumentPosition(n.createElement("fieldset"))}),ja(function(a){return a.innerHTML="<a href='#'></a>","#"===a.firstChild.getAttribute("href")})||ka("type|href|height|width",function(a,b,c){if(!c)return a.getAttribute(b,"type"===b.toLowerCase()?1:2)}),c.attributes&&ja(function(a){return a.innerHTML="<input/>",a.firstChild.setAttribute("value",""),""===a.firstChild.getAttribute("value")})||ka("value",function(a,b,c){if(!c&&"input"===a.nodeName.toLowerCase())return a.defaultValue}),ja(function(a){return null==a.getAttribute("disabled")})||ka(J,function(a,b,c){var d;if(!c)return a[b]===!0?b.toLowerCase():(d=a.getAttributeNode(b))&&d.specified?d.value:null}),ga}(a);r.find=x,r.expr=x.selectors,r.expr[":"]=r.expr.pseudos,r.uniqueSort=r.unique=x.uniqueSort,r.text=x.getText,r.isXMLDoc=x.isXML,r.contains=x.contains,r.escapeSelector=x.escape;var y=function(a,b,c){var d=[],e=void 0!==c;while((a=a[b])&&9!==a.nodeType)if(1===a.nodeType){if(e&&r(a).is(c))break;d.push(a)}return d},z=function(a,b){for(var c=[];a;a=a.nextSibling)1===a.nodeType&&a!==b&&c.push(a);return c},A=r.expr.match.needsContext,B=/^<([a-z][^\/\0>:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?>(?:<\/\1>|)$/i,C=/^.[^:#\[\.,]*$/;function D(a,b,c){return r.isFunction(b)?r.grep(a,function(a,d){return!!b.call(a,d,a)!==c}):b.nodeType?r.grep(a,function(a){return a===b!==c}):"string"!=typeof b?r.grep(a,function(a){return i.call(b,a)>-1!==c}):C.test(b)?r.filter(b,a,c):(b=r.filter(b,a),r.grep(a,function(a){return i.call(b,a)>-1!==c&&1===a.nodeType}))}r.filter=function(a,b,c){var d=b[0];return c&&(a=":not("+a+")"),1===b.length&&1===d.nodeType?r.find.matchesSelector(d,a)?[d]:[]:r.find.matches(a,r.grep(b,function(a){return 1===a.nodeType}))},r.fn.extend({find:function(a){var b,c,d=this.length,e=this;if("string"!=typeof a)return this.pushStack(r(a).filter(function(){for(b=0;b<d;b++)if(r.contains(e[b],this))return!0}));for(c=this.pushStack([]),b=0;b<d;b++)r.find(a,e[b],c);return d>1?r.uniqueSort(c):c},filter:function(a){return this.pushStack(D(this,a||[],!1))},not:function(a){return this.pushStack(D(this,a||[],!0))},is:function(a){return!!D(this,"string"==typeof a&&A.test(a)?r(a):a||[],!1).length}});var E,F=/^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]+))$/,G=r.fn.init=function(a,b,c){var e,f;if(!a)return this;if(c=c||E,"string"==typeof a){if(e="<"===a[0]&&">"===a[a.length-1]&&a.length>=3?[null,a,null]:F.exec(a),!e||!e[1]&&b)return!b||b.jquery?(b||c).find(a):this.constructor(b).find(a);if(e[1]){if(b=b instanceof r?b[0]:b,r.merge(this,r.parseHTML(e[1],b&&b.nodeType?b.ownerDocument||b:d,!0)),B.test(e[1])&&r.isPlainObject(b))for(e in b)r.isFunction(this[e])?this[e](b[e]):this.attr(e,b[e]);return this}return f=d.getElementById(e[2]),f&&(this[0]=f,this.length=1),this}return a.nodeType?(this[0]=a,this.length=1,this):r.isFunction(a)?void 0!==c.ready?c.ready(a):a(r):r.makeArray(a,this)};G.prototype=r.fn,E=r(d);var H=/^(?:parents|prev(?:Until|All))/,I={children:!0,contents:!0,next:!0,prev:!0};r.fn.extend({has:function(a){var b=r(a,this),c=b.length;return this.filter(function(){for(var a=0;a<c;a++)if(r.contains(this,b[a]))return!0})},closest:function(a,b){var c,d=0,e=this.length,f=[],g="string"!=typeof a&&r(a);if(!A.test(a))for(;d<e;d++)for(c=this[d];c&&c!==b;c=c.parentNode)if(c.nodeType<11&&(g?g.index(c)>-1:1===c.nodeType&&r.find.matchesSelector(c,a))){f.push(c);break}return this.pushStack(f.length>1?r.uniqueSort(f):f)},index:function(a){return a?"string"==typeof a?i.call(r(a),this[0]):i.call(this,a.jquery?a[0]:a):this[0]&&this[0].parentNode?this.first().prevAll().length:-1},add:function(a,b){return this.pushStack(r.uniqueSort(r.merge(this.get(),r(a,b))))},addBack:function(a){return this.add(null==a?this.prevObject:this.prevObject.filter(a))}});function J(a,b){while((a=a[b])&&1!==a.nodeType);return a}r.each({parent:function(a){var b=a.parentNode;return b&&11!==b.nodeType?b:null},parents:function(a){return y(a,"parentNode")},parentsUntil:function(a,b,c){return y(a,"parentNode",c)},next:function(a){return J(a,"nextSibling")},prev:function(a){return J(a,"previousSibling")},nextAll:function(a){return y(a,"nextSibling")},prevAll:function(a){return y(a,"previousSibling")},nextUntil:function(a,b,c){return y(a,"nextSibling",c)},prevUntil:function(a,b,c){return y(a,"previousSibling",c)},siblings:function(a){return z((a.parentNode||{}).firstChild,a)},children:function(a){return z(a.firstChild)},contents:function(a){return a.contentDocument||r.merge([],a.childNodes)}},function(a,b){r.fn[a]=function(c,d){var e=r.map(this,b,c);return"Until"!==a.slice(-5)&&(d=c),d&&"string"==typeof d&&(e=r.filter(d,e)),this.length>1&&(I[a]||r.uniqueSort(e),H.test(a)&&e.reverse()),this.pushStack(e)}});var K=/[^\x20\t\r\n\f]+/g;function L(a){var b={};return r.each(a.match(K)||[],function(a,c){b[c]=!0}),b}r.Callbacks=function(a){a="string"==typeof a?L(a):r.extend({},a);var b,c,d,e,f=[],g=[],h=-1,i=function(){for(e=a.once,d=b=!0;g.length;h=-1){c=g.shift();while(++h<f.length)f[h].apply(c[0],c[1])===!1&&a.stopOnFalse&&(h=f.length,c=!1)}a.memory||(c=!1),b=!1,e&&(f=c?[]:"")},j={add:function(){return f&&(c&&!b&&(h=f.length-1,g.push(c)),function d(b){r.each(b,function(b,c){r.isFunction(c)?a.unique&&j.has(c)||f.push(c):c&&c.length&&"string"!==r.type(c)&&d(c)})}(arguments),c&&!b&&i()),this},remove:function(){return r.each(arguments,function(a,b){var c;while((c=r.inArray(b,f,c))>-1)f.splice(c,1),c<=h&&h--}),this},has:function(a){return a?r.inArray(a,f)>-1:f.length>0},empty:function(){return f&&(f=[]),this},disable:function(){return e=g=[],f=c="",this},disabled:function(){return!f},lock:function(){return e=g=[],c||b||(f=c=""),this},locked:function(){return!!e},fireWith:function(a,c){return e||(c=c||[],c=[a,c.slice?c.slice():c],g.push(c),b||i()),this},fire:function(){return j.fireWith(this,arguments),this},fired:function(){return!!d}};return j};function M(a){return a}function N(a){throw a}function O(a,b,c){var d;try{a&&r.isFunction(d=a.promise)?d.call(a).done(b).fail(c):a&&r.isFunction(d=a.then)?d.call(a,b,c):b.call(void 0,a)}catch(a){c.call(void 0,a)}}r.extend({Deferred:function(b){var c=[["notify","progress",r.Callbacks("memory"),r.Callbacks("memory"),2],["resolve","done",r.Callbacks("once memory"),r.Callbacks("once memory"),0,"resolved"],["reject","fail",r.Callbacks("once memory"),r.Callbacks("once memory"),1,"rejected"]],d="pending",e={state:function(){return d},always:function(){return f.done(arguments).fail(arguments),this},"catch":function(a){return e.then(null,a)},pipe:function(){var a=arguments;return r.Deferred(function(b){r.each(c,function(c,d){var e=r.isFunction(a[d[4]])&&a[d[4]];f[d[1]](function(){var a=e&&e.apply(this,arguments);a&&r.isFunction(a.promise)?a.promise().progress(b.notify).done(b.resolve).fail(b.reject):b[d[0]+"With"](this,e?[a]:arguments)})}),a=null}).promise()},then:function(b,d,e){var f=0;function g(b,c,d,e){return function(){var h=this,i=arguments,j=function(){var a,j;if(!(b<f)){if(a=d.apply(h,i),a===c.promise())throw new TypeError("Thenable self-resolution");j=a&&("object"==typeof a||"function"==typeof a)&&a.then,r.isFunction(j)?e?j.call(a,g(f,c,M,e),g(f,c,N,e)):(f++,j.call(a,g(f,c,M,e),g(f,c,N,e),g(f,c,M,c.notifyWith))):(d!==M&&(h=void 0,i=[a]),(e||c.resolveWith)(h,i))}},k=e?j:function(){try{j()}catch(a){r.Deferred.exceptionHook&&r.Deferred.exceptionHook(a,k.stackTrace),b+1>=f&&(d!==N&&(h=void 0,i=[a]),c.rejectWith(h,i))}};b?k():(r.Deferred.getStackHook&&(k.stackTrace=r.Deferred.getStackHook()),a.setTimeout(k))}}return r.Deferred(function(a){c[0][3].add(g(0,a,r.isFunction(e)?e:M,a.notifyWith)),c[1][3].add(g(0,a,r.isFunction(b)?b:M)),c[2][3].add(g(0,a,r.isFunction(d)?d:N))}).promise()},promise:function(a){return null!=a?r.extend(a,e):e}},f={};return r.each(c,function(a,b){var g=b[2],h=b[5];e[b[1]]=g.add,h&&g.add(function(){d=h},c[3-a][2].disable,c[0][2].lock),g.add(b[3].fire),f[b[0]]=function(){return f[b[0]+"With"](this===f?void 0:this,arguments),this},f[b[0]+"With"]=g.fireWith}),e.promise(f),b&&b.call(f,f),f},when:function(a){var b=arguments.length,c=b,d=Array(c),e=f.call(arguments),g=r.Deferred(),h=function(a){return function(c){d[a]=this,e[a]=arguments.length>1?f.call(arguments):c,--b||g.resolveWith(d,e)}};if(b<=1&&(O(a,g.done(h(c)).resolve,g.reject),"pending"===g.state()||r.isFunction(e[c]&&e[c].then)))return g.then();while(c--)O(e[c],h(c),g.reject);return g.promise()}});var P=/^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;r.Deferred.exceptionHook=function(b,c){a.console&&a.console.warn&&b&&P.test(b.name)&&a.console.warn("jQuery.Deferred exception: "+b.message,b.stack,c)},r.readyException=function(b){a.setTimeout(function(){throw b})};var Q=r.Deferred();r.fn.ready=function(a){return Q.then(a)["catch"](function(a){r.readyException(a)}),this},r.extend({isReady:!1,readyWait:1,holdReady:function(a){a?r.readyWait++:r.ready(!0)},ready:function(a){(a===!0?--r.readyWait:r.isReady)||(r.isReady=!0,a!==!0&&--r.readyWait>0||Q.resolveWith(d,[r]))}}),r.ready.then=Q.then;function R(){d.removeEventListener("DOMContentLoaded",R),
a.removeEventListener("load",R),r.ready()}"complete"===d.readyState||"loading"!==d.readyState&&!d.documentElement.doScroll?a.setTimeout(r.ready):(d.addEventListener("DOMContentLoaded",R),a.addEventListener("load",R));var S=function(a,b,c,d,e,f,g){var h=0,i=a.length,j=null==c;if("object"===r.type(c)){e=!0;for(h in c)S(a,b,h,c[h],!0,f,g)}else if(void 0!==d&&(e=!0,r.isFunction(d)||(g=!0),j&&(g?(b.call(a,d),b=null):(j=b,b=function(a,b,c){return j.call(r(a),c)})),b))for(;h<i;h++)b(a[h],c,g?d:d.call(a[h],h,b(a[h],c)));return e?a:j?b.call(a):i?b(a[0],c):f},T=function(a){return 1===a.nodeType||9===a.nodeType||!+a.nodeType};function U(){this.expando=r.expando+U.uid++}U.uid=1,U.prototype={cache:function(a){var b=a[this.expando];return b||(b={},T(a)&&(a.nodeType?a[this.expando]=b:Object.defineProperty(a,this.expando,{value:b,configurable:!0}))),b},set:function(a,b,c){var d,e=this.cache(a);if("string"==typeof b)e[r.camelCase(b)]=c;else for(d in b)e[r.camelCase(d)]=b[d];return e},get:function(a,b){return void 0===b?this.cache(a):a[this.expando]&&a[this.expando][r.camelCase(b)]},access:function(a,b,c){return void 0===b||b&&"string"==typeof b&&void 0===c?this.get(a,b):(this.set(a,b,c),void 0!==c?c:b)},remove:function(a,b){var c,d=a[this.expando];if(void 0!==d){if(void 0!==b){r.isArray(b)?b=b.map(r.camelCase):(b=r.camelCase(b),b=b in d?[b]:b.match(K)||[]),c=b.length;while(c--)delete d[b[c]]}(void 0===b||r.isEmptyObject(d))&&(a.nodeType?a[this.expando]=void 0:delete a[this.expando])}},hasData:function(a){var b=a[this.expando];return void 0!==b&&!r.isEmptyObject(b)}};var V=new U,W=new U,X=/^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,Y=/[A-Z]/g;function Z(a){return"true"===a||"false"!==a&&("null"===a?null:a===+a+""?+a:X.test(a)?JSON.parse(a):a)}function $(a,b,c){var d;if(void 0===c&&1===a.nodeType)if(d="data-"+b.replace(Y,"-$&").toLowerCase(),c=a.getAttribute(d),"string"==typeof c){try{c=Z(c)}catch(e){}W.set(a,b,c)}else c=void 0;return c}r.extend({hasData:function(a){return W.hasData(a)||V.hasData(a)},data:function(a,b,c){return W.access(a,b,c)},removeData:function(a,b){W.remove(a,b)},_data:function(a,b,c){return V.access(a,b,c)},_removeData:function(a,b){V.remove(a,b)}}),r.fn.extend({data:function(a,b){var c,d,e,f=this[0],g=f&&f.attributes;if(void 0===a){if(this.length&&(e=W.get(f),1===f.nodeType&&!V.get(f,"hasDataAttrs"))){c=g.length;while(c--)g[c]&&(d=g[c].name,0===d.indexOf("data-")&&(d=r.camelCase(d.slice(5)),$(f,d,e[d])));V.set(f,"hasDataAttrs",!0)}return e}return"object"==typeof a?this.each(function(){W.set(this,a)}):S(this,function(b){var c;if(f&&void 0===b){if(c=W.get(f,a),void 0!==c)return c;if(c=$(f,a),void 0!==c)return c}else this.each(function(){W.set(this,a,b)})},null,b,arguments.length>1,null,!0)},removeData:function(a){return this.each(function(){W.remove(this,a)})}}),r.extend({queue:function(a,b,c){var d;if(a)return b=(b||"fx")+"queue",d=V.get(a,b),c&&(!d||r.isArray(c)?d=V.access(a,b,r.makeArray(c)):d.push(c)),d||[]},dequeue:function(a,b){b=b||"fx";var c=r.queue(a,b),d=c.length,e=c.shift(),f=r._queueHooks(a,b),g=function(){r.dequeue(a,b)};"inprogress"===e&&(e=c.shift(),d--),e&&("fx"===b&&c.unshift("inprogress"),delete f.stop,e.call(a,g,f)),!d&&f&&f.empty.fire()},_queueHooks:function(a,b){var c=b+"queueHooks";return V.get(a,c)||V.access(a,c,{empty:r.Callbacks("once memory").add(function(){V.remove(a,[b+"queue",c])})})}}),r.fn.extend({queue:function(a,b){var c=2;return"string"!=typeof a&&(b=a,a="fx",c--),arguments.length<c?r.queue(this[0],a):void 0===b?this:this.each(function(){var c=r.queue(this,a,b);r._queueHooks(this,a),"fx"===a&&"inprogress"!==c[0]&&r.dequeue(this,a)})},dequeue:function(a){return this.each(function(){r.dequeue(this,a)})},clearQueue:function(a){return this.queue(a||"fx",[])},promise:function(a,b){var c,d=1,e=r.Deferred(),f=this,g=this.length,h=function(){--d||e.resolveWith(f,[f])};"string"!=typeof a&&(b=a,a=void 0),a=a||"fx";while(g--)c=V.get(f[g],a+"queueHooks"),c&&c.empty&&(d++,c.empty.add(h));return h(),e.promise(b)}});var _=/[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source,aa=new RegExp("^(?:([+-])=|)("+_+")([a-z%]*)$","i"),ba=["Top","Right","Bottom","Left"],ca=function(a,b){return a=b||a,"none"===a.style.display||""===a.style.display&&r.contains(a.ownerDocument,a)&&"none"===r.css(a,"display")},da=function(a,b,c,d){var e,f,g={};for(f in b)g[f]=a.style[f],a.style[f]=b[f];e=c.apply(a,d||[]);for(f in b)a.style[f]=g[f];return e};function ea(a,b,c,d){var e,f=1,g=20,h=d?function(){return d.cur()}:function(){return r.css(a,b,"")},i=h(),j=c&&c[3]||(r.cssNumber[b]?"":"px"),k=(r.cssNumber[b]||"px"!==j&&+i)&&aa.exec(r.css(a,b));if(k&&k[3]!==j){j=j||k[3],c=c||[],k=+i||1;do f=f||".5",k/=f,r.style(a,b,k+j);while(f!==(f=h()/i)&&1!==f&&--g)}return c&&(k=+k||+i||0,e=c[1]?k+(c[1]+1)*c[2]:+c[2],d&&(d.unit=j,d.start=k,d.end=e)),e}var fa={};function ga(a){var b,c=a.ownerDocument,d=a.nodeName,e=fa[d];return e?e:(b=c.body.appendChild(c.createElement(d)),e=r.css(b,"display"),b.parentNode.removeChild(b),"none"===e&&(e="block"),fa[d]=e,e)}function ha(a,b){for(var c,d,e=[],f=0,g=a.length;f<g;f++)d=a[f],d.style&&(c=d.style.display,b?("none"===c&&(e[f]=V.get(d,"display")||null,e[f]||(d.style.display="")),""===d.style.display&&ca(d)&&(e[f]=ga(d))):"none"!==c&&(e[f]="none",V.set(d,"display",c)));for(f=0;f<g;f++)null!=e[f]&&(a[f].style.display=e[f]);return a}r.fn.extend({show:function(){return ha(this,!0)},hide:function(){return ha(this)},toggle:function(a){return"boolean"==typeof a?a?this.show():this.hide():this.each(function(){ca(this)?r(this).show():r(this).hide()})}});var ia=/^(?:checkbox|radio)$/i,ja=/<([a-z][^\/\0>\x20\t\r\n\f]+)/i,ka=/^$|\/(?:java|ecma)script/i,la={option:[1,"<select multiple='multiple'>","</select>"],thead:[1,"<table>","</table>"],col:[2,"<table><colgroup>","</colgroup></table>"],tr:[2,"<table><tbody>","</tbody></table>"],td:[3,"<table><tbody><tr>","</tr></tbody></table>"],_default:[0,"",""]};la.optgroup=la.option,la.tbody=la.tfoot=la.colgroup=la.caption=la.thead,la.th=la.td;function ma(a,b){var c;return c="undefined"!=typeof a.getElementsByTagName?a.getElementsByTagName(b||"*"):"undefined"!=typeof a.querySelectorAll?a.querySelectorAll(b||"*"):[],void 0===b||b&&r.nodeName(a,b)?r.merge([a],c):c}function na(a,b){for(var c=0,d=a.length;c<d;c++)V.set(a[c],"globalEval",!b||V.get(b[c],"globalEval"))}var oa=/<|&#?\w+;/;function pa(a,b,c,d,e){for(var f,g,h,i,j,k,l=b.createDocumentFragment(),m=[],n=0,o=a.length;n<o;n++)if(f=a[n],f||0===f)if("object"===r.type(f))r.merge(m,f.nodeType?[f]:f);else if(oa.test(f)){g=g||l.appendChild(b.createElement("div")),h=(ja.exec(f)||["",""])[1].toLowerCase(),i=la[h]||la._default,g.innerHTML=i[1]+r.htmlPrefilter(f)+i[2],k=i[0];while(k--)g=g.lastChild;r.merge(m,g.childNodes),g=l.firstChild,g.textContent=""}else m.push(b.createTextNode(f));l.textContent="",n=0;while(f=m[n++])if(d&&r.inArray(f,d)>-1)e&&e.push(f);else if(j=r.contains(f.ownerDocument,f),g=ma(l.appendChild(f),"script"),j&&na(g),c){k=0;while(f=g[k++])ka.test(f.type||"")&&c.push(f)}return l}!function(){var a=d.createDocumentFragment(),b=a.appendChild(d.createElement("div")),c=d.createElement("input");c.setAttribute("type","radio"),c.setAttribute("checked","checked"),c.setAttribute("name","t"),b.appendChild(c),o.checkClone=b.cloneNode(!0).cloneNode(!0).lastChild.checked,b.innerHTML="<textarea>x</textarea>",o.noCloneChecked=!!b.cloneNode(!0).lastChild.defaultValue}();var qa=d.documentElement,ra=/^key/,sa=/^(?:mouse|pointer|contextmenu|drag|drop)|click/,ta=/^([^.]*)(?:\.(.+)|)/;function ua(){return!0}function va(){return!1}function wa(){try{return d.activeElement}catch(a){}}function xa(a,b,c,d,e,f){var g,h;if("object"==typeof b){"string"!=typeof c&&(d=d||c,c=void 0);for(h in b)xa(a,h,c,d,b[h],f);return a}if(null==d&&null==e?(e=c,d=c=void 0):null==e&&("string"==typeof c?(e=d,d=void 0):(e=d,d=c,c=void 0)),e===!1)e=va;else if(!e)return a;return 1===f&&(g=e,e=function(a){return r().off(a),g.apply(this,arguments)},e.guid=g.guid||(g.guid=r.guid++)),a.each(function(){r.event.add(this,b,e,d,c)})}r.event={global:{},add:function(a,b,c,d,e){var f,g,h,i,j,k,l,m,n,o,p,q=V.get(a);if(q){c.handler&&(f=c,c=f.handler,e=f.selector),e&&r.find.matchesSelector(qa,e),c.guid||(c.guid=r.guid++),(i=q.events)||(i=q.events={}),(g=q.handle)||(g=q.handle=function(b){return"undefined"!=typeof r&&r.event.triggered!==b.type?r.event.dispatch.apply(a,arguments):void 0}),b=(b||"").match(K)||[""],j=b.length;while(j--)h=ta.exec(b[j])||[],n=p=h[1],o=(h[2]||"").split(".").sort(),n&&(l=r.event.special[n]||{},n=(e?l.delegateType:l.bindType)||n,l=r.event.special[n]||{},k=r.extend({type:n,origType:p,data:d,handler:c,guid:c.guid,selector:e,needsContext:e&&r.expr.match.needsContext.test(e),namespace:o.join(".")},f),(m=i[n])||(m=i[n]=[],m.delegateCount=0,l.setup&&l.setup.call(a,d,o,g)!==!1||a.addEventListener&&a.addEventListener(n,g)),l.add&&(l.add.call(a,k),k.handler.guid||(k.handler.guid=c.guid)),e?m.splice(m.delegateCount++,0,k):m.push(k),r.event.global[n]=!0)}},remove:function(a,b,c,d,e){var f,g,h,i,j,k,l,m,n,o,p,q=V.hasData(a)&&V.get(a);if(q&&(i=q.events)){b=(b||"").match(K)||[""],j=b.length;while(j--)if(h=ta.exec(b[j])||[],n=p=h[1],o=(h[2]||"").split(".").sort(),n){l=r.event.special[n]||{},n=(d?l.delegateType:l.bindType)||n,m=i[n]||[],h=h[2]&&new RegExp("(^|\\.)"+o.join("\\.(?:.*\\.|)")+"(\\.|$)"),g=f=m.length;while(f--)k=m[f],!e&&p!==k.origType||c&&c.guid!==k.guid||h&&!h.test(k.namespace)||d&&d!==k.selector&&("**"!==d||!k.selector)||(m.splice(f,1),k.selector&&m.delegateCount--,l.remove&&l.remove.call(a,k));g&&!m.length&&(l.teardown&&l.teardown.call(a,o,q.handle)!==!1||r.removeEvent(a,n,q.handle),delete i[n])}else for(n in i)r.event.remove(a,n+b[j],c,d,!0);r.isEmptyObject(i)&&V.remove(a,"handle events")}},dispatch:function(a){var b=r.event.fix(a),c,d,e,f,g,h,i=new Array(arguments.length),j=(V.get(this,"events")||{})[b.type]||[],k=r.event.special[b.type]||{};for(i[0]=b,c=1;c<arguments.length;c++)i[c]=arguments[c];if(b.delegateTarget=this,!k.preDispatch||k.preDispatch.call(this,b)!==!1){h=r.event.handlers.call(this,b,j),c=0;while((f=h[c++])&&!b.isPropagationStopped()){b.currentTarget=f.elem,d=0;while((g=f.handlers[d++])&&!b.isImmediatePropagationStopped())b.rnamespace&&!b.rnamespace.test(g.namespace)||(b.handleObj=g,b.data=g.data,e=((r.event.special[g.origType]||{}).handle||g.handler).apply(f.elem,i),void 0!==e&&(b.result=e)===!1&&(b.preventDefault(),b.stopPropagation()))}return k.postDispatch&&k.postDispatch.call(this,b),b.result}},handlers:function(a,b){var c,d,e,f,g,h=[],i=b.delegateCount,j=a.target;if(i&&j.nodeType&&!("click"===a.type&&a.button>=1))for(;j!==this;j=j.parentNode||this)if(1===j.nodeType&&("click"!==a.type||j.disabled!==!0)){for(f=[],g={},c=0;c<i;c++)d=b[c],e=d.selector+" ",void 0===g[e]&&(g[e]=d.needsContext?r(e,this).index(j)>-1:r.find(e,this,null,[j]).length),g[e]&&f.push(d);f.length&&h.push({elem:j,handlers:f})}return j=this,i<b.length&&h.push({elem:j,handlers:b.slice(i)}),h},addProp:function(a,b){Object.defineProperty(r.Event.prototype,a,{enumerable:!0,configurable:!0,get:r.isFunction(b)?function(){if(this.originalEvent)return b(this.originalEvent)}:function(){if(this.originalEvent)return this.originalEvent[a]},set:function(b){Object.defineProperty(this,a,{enumerable:!0,configurable:!0,writable:!0,value:b})}})},fix:function(a){return a[r.expando]?a:new r.Event(a)},special:{load:{noBubble:!0},focus:{trigger:function(){if(this!==wa()&&this.focus)return this.focus(),!1},delegateType:"focusin"},blur:{trigger:function(){if(this===wa()&&this.blur)return this.blur(),!1},delegateType:"focusout"},click:{trigger:function(){if("checkbox"===this.type&&this.click&&r.nodeName(this,"input"))return this.click(),!1},_default:function(a){return r.nodeName(a.target,"a")}},beforeunload:{postDispatch:function(a){void 0!==a.result&&a.originalEvent&&(a.originalEvent.returnValue=a.result)}}}},r.removeEvent=function(a,b,c){a.removeEventListener&&a.removeEventListener(b,c)},r.Event=function(a,b){return this instanceof r.Event?(a&&a.type?(this.originalEvent=a,this.type=a.type,this.isDefaultPrevented=a.defaultPrevented||void 0===a.defaultPrevented&&a.returnValue===!1?ua:va,this.target=a.target&&3===a.target.nodeType?a.target.parentNode:a.target,this.currentTarget=a.currentTarget,this.relatedTarget=a.relatedTarget):this.type=a,b&&r.extend(this,b),this.timeStamp=a&&a.timeStamp||r.now(),void(this[r.expando]=!0)):new r.Event(a,b)},r.Event.prototype={constructor:r.Event,isDefaultPrevented:va,isPropagationStopped:va,isImmediatePropagationStopped:va,isSimulated:!1,preventDefault:function(){var a=this.originalEvent;this.isDefaultPrevented=ua,a&&!this.isSimulated&&a.preventDefault()},stopPropagation:function(){var a=this.originalEvent;this.isPropagationStopped=ua,a&&!this.isSimulated&&a.stopPropagation()},stopImmediatePropagation:function(){var a=this.originalEvent;this.isImmediatePropagationStopped=ua,a&&!this.isSimulated&&a.stopImmediatePropagation(),this.stopPropagation()}},r.each({altKey:!0,bubbles:!0,cancelable:!0,changedTouches:!0,ctrlKey:!0,detail:!0,eventPhase:!0,metaKey:!0,pageX:!0,pageY:!0,shiftKey:!0,view:!0,"char":!0,charCode:!0,key:!0,keyCode:!0,button:!0,buttons:!0,clientX:!0,clientY:!0,offsetX:!0,offsetY:!0,pointerId:!0,pointerType:!0,screenX:!0,screenY:!0,targetTouches:!0,toElement:!0,touches:!0,which:function(a){var b=a.button;return null==a.which&&ra.test(a.type)?null!=a.charCode?a.charCode:a.keyCode:!a.which&&void 0!==b&&sa.test(a.type)?1&b?1:2&b?3:4&b?2:0:a.which}},r.event.addProp),r.each({mouseenter:"mouseover",mouseleave:"mouseout",pointerenter:"pointerover",pointerleave:"pointerout"},function(a,b){r.event.special[a]={delegateType:b,bindType:b,handle:function(a){var c,d=this,e=a.relatedTarget,f=a.handleObj;return e&&(e===d||r.contains(d,e))||(a.type=f.origType,c=f.handler.apply(this,arguments),a.type=b),c}}}),r.fn.extend({on:function(a,b,c,d){return xa(this,a,b,c,d)},one:function(a,b,c,d){return xa(this,a,b,c,d,1)},off:function(a,b,c){var d,e;if(a&&a.preventDefault&&a.handleObj)return d=a.handleObj,r(a.delegateTarget).off(d.namespace?d.origType+"."+d.namespace:d.origType,d.selector,d.handler),this;if("object"==typeof a){for(e in a)this.off(e,b,a[e]);return this}return b!==!1&&"function"!=typeof b||(c=b,b=void 0),c===!1&&(c=va),this.each(function(){r.event.remove(this,a,c,b)})}});var ya=/<(?!area|br|col|embed|hr|img|input|link|meta|param)(([a-z][^\/\0>\x20\t\r\n\f]*)[^>]*)\/>/gi,za=/<script|<style|<link/i,Aa=/checked\s*(?:[^=]|=\s*.checked.)/i,Ba=/^true\/(.*)/,Ca=/^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g;function Da(a,b){return r.nodeName(a,"table")&&r.nodeName(11!==b.nodeType?b:b.firstChild,"tr")?a.getElementsByTagName("tbody")[0]||a:a}function Ea(a){return a.type=(null!==a.getAttribute("type"))+"/"+a.type,a}function Fa(a){var b=Ba.exec(a.type);return b?a.type=b[1]:a.removeAttribute("type"),a}function Ga(a,b){var c,d,e,f,g,h,i,j;if(1===b.nodeType){if(V.hasData(a)&&(f=V.access(a),g=V.set(b,f),j=f.events)){delete g.handle,g.events={};for(e in j)for(c=0,d=j[e].length;c<d;c++)r.event.add(b,e,j[e][c])}W.hasData(a)&&(h=W.access(a),i=r.extend({},h),W.set(b,i))}}function Ha(a,b){var c=b.nodeName.toLowerCase();"input"===c&&ia.test(a.type)?b.checked=a.checked:"input"!==c&&"textarea"!==c||(b.defaultValue=a.defaultValue)}function Ia(a,b,c,d){b=g.apply([],b);var e,f,h,i,j,k,l=0,m=a.length,n=m-1,q=b[0],s=r.isFunction(q);if(s||m>1&&"string"==typeof q&&!o.checkClone&&Aa.test(q))return a.each(function(e){var f=a.eq(e);s&&(b[0]=q.call(this,e,f.html())),Ia(f,b,c,d)});if(m&&(e=pa(b,a[0].ownerDocument,!1,a,d),f=e.firstChild,1===e.childNodes.length&&(e=f),f||d)){for(h=r.map(ma(e,"script"),Ea),i=h.length;l<m;l++)j=e,l!==n&&(j=r.clone(j,!0,!0),i&&r.merge(h,ma(j,"script"))),c.call(a[l],j,l);if(i)for(k=h[h.length-1].ownerDocument,r.map(h,Fa),l=0;l<i;l++)j=h[l],ka.test(j.type||"")&&!V.access(j,"globalEval")&&r.contains(k,j)&&(j.src?r._evalUrl&&r._evalUrl(j.src):p(j.textContent.replace(Ca,""),k))}return a}function Ja(a,b,c){for(var d,e=b?r.filter(b,a):a,f=0;null!=(d=e[f]);f++)c||1!==d.nodeType||r.cleanData(ma(d)),d.parentNode&&(c&&r.contains(d.ownerDocument,d)&&na(ma(d,"script")),d.parentNode.removeChild(d));return a}r.extend({htmlPrefilter:function(a){return a.replace(ya,"<$1></$2>")},clone:function(a,b,c){var d,e,f,g,h=a.cloneNode(!0),i=r.contains(a.ownerDocument,a);if(!(o.noCloneChecked||1!==a.nodeType&&11!==a.nodeType||r.isXMLDoc(a)))for(g=ma(h),f=ma(a),d=0,e=f.length;d<e;d++)Ha(f[d],g[d]);if(b)if(c)for(f=f||ma(a),g=g||ma(h),d=0,e=f.length;d<e;d++)Ga(f[d],g[d]);else Ga(a,h);return g=ma(h,"script"),g.length>0&&na(g,!i&&ma(a,"script")),h},cleanData:function(a){for(var b,c,d,e=r.event.special,f=0;void 0!==(c=a[f]);f++)if(T(c)){if(b=c[V.expando]){if(b.events)for(d in b.events)e[d]?r.event.remove(c,d):r.removeEvent(c,d,b.handle);c[V.expando]=void 0}c[W.expando]&&(c[W.expando]=void 0)}}}),r.fn.extend({detach:function(a){return Ja(this,a,!0)},remove:function(a){return Ja(this,a)},text:function(a){return S(this,function(a){return void 0===a?r.text(this):this.empty().each(function(){1!==this.nodeType&&11!==this.nodeType&&9!==this.nodeType||(this.textContent=a)})},null,a,arguments.length)},append:function(){return Ia(this,arguments,function(a){if(1===this.nodeType||11===this.nodeType||9===this.nodeType){var b=Da(this,a);b.appendChild(a)}})},prepend:function(){return Ia(this,arguments,function(a){if(1===this.nodeType||11===this.nodeType||9===this.nodeType){var b=Da(this,a);b.insertBefore(a,b.firstChild)}})},before:function(){return Ia(this,arguments,function(a){this.parentNode&&this.parentNode.insertBefore(a,this)})},after:function(){return Ia(this,arguments,function(a){this.parentNode&&this.parentNode.insertBefore(a,this.nextSibling)})},empty:function(){for(var a,b=0;null!=(a=this[b]);b++)1===a.nodeType&&(r.cleanData(ma(a,!1)),a.textContent="");return this},clone:function(a,b){return a=null!=a&&a,b=null==b?a:b,this.map(function(){return r.clone(this,a,b)})},html:function(a){return S(this,function(a){var b=this[0]||{},c=0,d=this.length;if(void 0===a&&1===b.nodeType)return b.innerHTML;if("string"==typeof a&&!za.test(a)&&!la[(ja.exec(a)||["",""])[1].toLowerCase()]){a=r.htmlPrefilter(a);try{for(;c<d;c++)b=this[c]||{},1===b.nodeType&&(r.cleanData(ma(b,!1)),b.innerHTML=a);b=0}catch(e){}}b&&this.empty().append(a)},null,a,arguments.length)},replaceWith:function(){var a=[];return Ia(this,arguments,function(b){var c=this.parentNode;r.inArray(this,a)<0&&(r.cleanData(ma(this)),c&&c.replaceChild(b,this))},a)}}),r.each({appendTo:"append",prependTo:"prepend",insertBefore:"before",insertAfter:"after",replaceAll:"replaceWith"},function(a,b){r.fn[a]=function(a){for(var c,d=[],e=r(a),f=e.length-1,g=0;g<=f;g++)c=g===f?this:this.clone(!0),r(e[g])[b](c),h.apply(d,c.get());return this.pushStack(d)}});var Ka=/^margin/,La=new RegExp("^("+_+")(?!px)[a-z%]+$","i"),Ma=function(b){var c=b.ownerDocument.defaultView;return c&&c.opener||(c=a),c.getComputedStyle(b)};!function(){function b(){if(i){i.style.cssText="box-sizing:border-box;position:relative;display:block;margin:auto;border:1px;padding:1px;top:1%;width:50%",i.innerHTML="",qa.appendChild(h);var b=a.getComputedStyle(i);c="1%"!==b.top,g="2px"===b.marginLeft,e="4px"===b.width,i.style.marginRight="50%",f="4px"===b.marginRight,qa.removeChild(h),i=null}}var c,e,f,g,h=d.createElement("div"),i=d.createElement("div");i.style&&(i.style.backgroundClip="content-box",i.cloneNode(!0).style.backgroundClip="",o.clearCloneStyle="content-box"===i.style.backgroundClip,h.style.cssText="border:0;width:8px;height:0;top:0;left:-9999px;padding:0;margin-top:1px;position:absolute",h.appendChild(i),r.extend(o,{pixelPosition:function(){return b(),c},boxSizingReliable:function(){return b(),e},pixelMarginRight:function(){return b(),f},reliableMarginLeft:function(){return b(),g}}))}();function Na(a,b,c){var d,e,f,g,h=a.style;return c=c||Ma(a),c&&(g=c.getPropertyValue(b)||c[b],""!==g||r.contains(a.ownerDocument,a)||(g=r.style(a,b)),!o.pixelMarginRight()&&La.test(g)&&Ka.test(b)&&(d=h.width,e=h.minWidth,f=h.maxWidth,h.minWidth=h.maxWidth=h.width=g,g=c.width,h.width=d,h.minWidth=e,h.maxWidth=f)),void 0!==g?g+"":g}function Oa(a,b){return{get:function(){return a()?void delete this.get:(this.get=b).apply(this,arguments)}}}var Pa=/^(none|table(?!-c[ea]).+)/,Qa={position:"absolute",visibility:"hidden",display:"block"},Ra={letterSpacing:"0",fontWeight:"400"},Sa=["Webkit","Moz","ms"],Ta=d.createElement("div").style;function Ua(a){if(a in Ta)return a;var b=a[0].toUpperCase()+a.slice(1),c=Sa.length;while(c--)if(a=Sa[c]+b,a in Ta)return a}function Va(a,b,c){var d=aa.exec(b);return d?Math.max(0,d[2]-(c||0))+(d[3]||"px"):b}function Wa(a,b,c,d,e){var f,g=0;for(f=c===(d?"border":"content")?4:"width"===b?1:0;f<4;f+=2)"margin"===c&&(g+=r.css(a,c+ba[f],!0,e)),d?("content"===c&&(g-=r.css(a,"padding"+ba[f],!0,e)),"margin"!==c&&(g-=r.css(a,"border"+ba[f]+"Width",!0,e))):(g+=r.css(a,"padding"+ba[f],!0,e),"padding"!==c&&(g+=r.css(a,"border"+ba[f]+"Width",!0,e)));return g}function Xa(a,b,c){var d,e=!0,f=Ma(a),g="border-box"===r.css(a,"boxSizing",!1,f);if(a.getClientRects().length&&(d=a.getBoundingClientRect()[b]),d<=0||null==d){if(d=Na(a,b,f),(d<0||null==d)&&(d=a.style[b]),La.test(d))return d;e=g&&(o.boxSizingReliable()||d===a.style[b]),d=parseFloat(d)||0}return d+Wa(a,b,c||(g?"border":"content"),e,f)+"px"}r.extend({cssHooks:{opacity:{get:function(a,b){if(b){var c=Na(a,"opacity");return""===c?"1":c}}}},cssNumber:{animationIterationCount:!0,columnCount:!0,fillOpacity:!0,flexGrow:!0,flexShrink:!0,fontWeight:!0,lineHeight:!0,opacity:!0,order:!0,orphans:!0,widows:!0,zIndex:!0,zoom:!0},cssProps:{"float":"cssFloat"},style:function(a,b,c,d){if(a&&3!==a.nodeType&&8!==a.nodeType&&a.style){var e,f,g,h=r.camelCase(b),i=a.style;return b=r.cssProps[h]||(r.cssProps[h]=Ua(h)||h),g=r.cssHooks[b]||r.cssHooks[h],void 0===c?g&&"get"in g&&void 0!==(e=g.get(a,!1,d))?e:i[b]:(f=typeof c,"string"===f&&(e=aa.exec(c))&&e[1]&&(c=ea(a,b,e),f="number"),null!=c&&c===c&&("number"===f&&(c+=e&&e[3]||(r.cssNumber[h]?"":"px")),o.clearCloneStyle||""!==c||0!==b.indexOf("background")||(i[b]="inherit"),g&&"set"in g&&void 0===(c=g.set(a,c,d))||(i[b]=c)),void 0)}},css:function(a,b,c,d){var e,f,g,h=r.camelCase(b);return b=r.cssProps[h]||(r.cssProps[h]=Ua(h)||h),g=r.cssHooks[b]||r.cssHooks[h],g&&"get"in g&&(e=g.get(a,!0,c)),void 0===e&&(e=Na(a,b,d)),"normal"===e&&b in Ra&&(e=Ra[b]),""===c||c?(f=parseFloat(e),c===!0||isFinite(f)?f||0:e):e}}),r.each(["height","width"],function(a,b){r.cssHooks[b]={get:function(a,c,d){if(c)return!Pa.test(r.css(a,"display"))||a.getClientRects().length&&a.getBoundingClientRect().width?Xa(a,b,d):da(a,Qa,function(){return Xa(a,b,d)})},set:function(a,c,d){var e,f=d&&Ma(a),g=d&&Wa(a,b,d,"border-box"===r.css(a,"boxSizing",!1,f),f);return g&&(e=aa.exec(c))&&"px"!==(e[3]||"px")&&(a.style[b]=c,c=r.css(a,b)),Va(a,c,g)}}}),r.cssHooks.marginLeft=Oa(o.reliableMarginLeft,function(a,b){if(b)return(parseFloat(Na(a,"marginLeft"))||a.getBoundingClientRect().left-da(a,{marginLeft:0},function(){return a.getBoundingClientRect().left}))+"px"}),r.each({margin:"",padding:"",border:"Width"},function(a,b){r.cssHooks[a+b]={expand:function(c){for(var d=0,e={},f="string"==typeof c?c.split(" "):[c];d<4;d++)e[a+ba[d]+b]=f[d]||f[d-2]||f[0];return e}},Ka.test(a)||(r.cssHooks[a+b].set=Va)}),r.fn.extend({css:function(a,b){return S(this,function(a,b,c){var d,e,f={},g=0;if(r.isArray(b)){for(d=Ma(a),e=b.length;g<e;g++)f[b[g]]=r.css(a,b[g],!1,d);return f}return void 0!==c?r.style(a,b,c):r.css(a,b)},a,b,arguments.length>1)}});function Ya(a,b,c,d,e){return new Ya.prototype.init(a,b,c,d,e)}r.Tween=Ya,Ya.prototype={constructor:Ya,init:function(a,b,c,d,e,f){this.elem=a,this.prop=c,this.easing=e||r.easing._default,this.options=b,this.start=this.now=this.cur(),this.end=d,this.unit=f||(r.cssNumber[c]?"":"px")},cur:function(){var a=Ya.propHooks[this.prop];return a&&a.get?a.get(this):Ya.propHooks._default.get(this)},run:function(a){var b,c=Ya.propHooks[this.prop];return this.options.duration?this.pos=b=r.easing[this.easing](a,this.options.duration*a,0,1,this.options.duration):this.pos=b=a,this.now=(this.end-this.start)*b+this.start,this.options.step&&this.options.step.call(this.elem,this.now,this),c&&c.set?c.set(this):Ya.propHooks._default.set(this),this}},Ya.prototype.init.prototype=Ya.prototype,Ya.propHooks={_default:{get:function(a){var b;return 1!==a.elem.nodeType||null!=a.elem[a.prop]&&null==a.elem.style[a.prop]?a.elem[a.prop]:(b=r.css(a.elem,a.prop,""),b&&"auto"!==b?b:0)},set:function(a){r.fx.step[a.prop]?r.fx.step[a.prop](a):1!==a.elem.nodeType||null==a.elem.style[r.cssProps[a.prop]]&&!r.cssHooks[a.prop]?a.elem[a.prop]=a.now:r.style(a.elem,a.prop,a.now+a.unit)}}},Ya.propHooks.scrollTop=Ya.propHooks.scrollLeft={set:function(a){a.elem.nodeType&&a.elem.parentNode&&(a.elem[a.prop]=a.now)}},r.easing={linear:function(a){return a},swing:function(a){return.5-Math.cos(a*Math.PI)/2},_default:"swing"},r.fx=Ya.prototype.init,r.fx.step={};var Za,$a,_a=/^(?:toggle|show|hide)$/,ab=/queueHooks$/;function bb(){$a&&(a.requestAnimationFrame(bb),r.fx.tick())}function cb(){return a.setTimeout(function(){Za=void 0}),Za=r.now()}function db(a,b){var c,d=0,e={height:a};for(b=b?1:0;d<4;d+=2-b)c=ba[d],e["margin"+c]=e["padding"+c]=a;return b&&(e.opacity=e.width=a),e}function eb(a,b,c){for(var d,e=(hb.tweeners[b]||[]).concat(hb.tweeners["*"]),f=0,g=e.length;f<g;f++)if(d=e[f].call(c,b,a))return d}function fb(a,b,c){var d,e,f,g,h,i,j,k,l="width"in b||"height"in b,m=this,n={},o=a.style,p=a.nodeType&&ca(a),q=V.get(a,"fxshow");c.queue||(g=r._queueHooks(a,"fx"),null==g.unqueued&&(g.unqueued=0,h=g.empty.fire,g.empty.fire=function(){g.unqueued||h()}),g.unqueued++,m.always(function(){m.always(function(){g.unqueued--,r.queue(a,"fx").length||g.empty.fire()})}));for(d in b)if(e=b[d],_a.test(e)){if(delete b[d],f=f||"toggle"===e,e===(p?"hide":"show")){if("show"!==e||!q||void 0===q[d])continue;p=!0}n[d]=q&&q[d]||r.style(a,d)}if(i=!r.isEmptyObject(b),i||!r.isEmptyObject(n)){l&&1===a.nodeType&&(c.overflow=[o.overflow,o.overflowX,o.overflowY],j=q&&q.display,null==j&&(j=V.get(a,"display")),k=r.css(a,"display"),"none"===k&&(j?k=j:(ha([a],!0),j=a.style.display||j,k=r.css(a,"display"),ha([a]))),("inline"===k||"inline-block"===k&&null!=j)&&"none"===r.css(a,"float")&&(i||(m.done(function(){o.display=j}),null==j&&(k=o.display,j="none"===k?"":k)),o.display="inline-block")),c.overflow&&(o.overflow="hidden",m.always(function(){o.overflow=c.overflow[0],o.overflowX=c.overflow[1],o.overflowY=c.overflow[2]})),i=!1;for(d in n)i||(q?"hidden"in q&&(p=q.hidden):q=V.access(a,"fxshow",{display:j}),f&&(q.hidden=!p),p&&ha([a],!0),m.done(function(){p||ha([a]),V.remove(a,"fxshow");for(d in n)r.style(a,d,n[d])})),i=eb(p?q[d]:0,d,m),d in q||(q[d]=i.start,p&&(i.end=i.start,i.start=0))}}function gb(a,b){var c,d,e,f,g;for(c in a)if(d=r.camelCase(c),e=b[d],f=a[c],r.isArray(f)&&(e=f[1],f=a[c]=f[0]),c!==d&&(a[d]=f,delete a[c]),g=r.cssHooks[d],g&&"expand"in g){f=g.expand(f),delete a[d];for(c in f)c in a||(a[c]=f[c],b[c]=e)}else b[d]=e}function hb(a,b,c){var d,e,f=0,g=hb.prefilters.length,h=r.Deferred().always(function(){delete i.elem}),i=function(){if(e)return!1;for(var b=Za||cb(),c=Math.max(0,j.startTime+j.duration-b),d=c/j.duration||0,f=1-d,g=0,i=j.tweens.length;g<i;g++)j.tweens[g].run(f);return h.notifyWith(a,[j,f,c]),f<1&&i?c:(h.resolveWith(a,[j]),!1)},j=h.promise({elem:a,props:r.extend({},b),opts:r.extend(!0,{specialEasing:{},easing:r.easing._default},c),originalProperties:b,originalOptions:c,startTime:Za||cb(),duration:c.duration,tweens:[],createTween:function(b,c){var d=r.Tween(a,j.opts,b,c,j.opts.specialEasing[b]||j.opts.easing);return j.tweens.push(d),d},stop:function(b){var c=0,d=b?j.tweens.length:0;if(e)return this;for(e=!0;c<d;c++)j.tweens[c].run(1);return b?(h.notifyWith(a,[j,1,0]),h.resolveWith(a,[j,b])):h.rejectWith(a,[j,b]),this}}),k=j.props;for(gb(k,j.opts.specialEasing);f<g;f++)if(d=hb.prefilters[f].call(j,a,k,j.opts))return r.isFunction(d.stop)&&(r._queueHooks(j.elem,j.opts.queue).stop=r.proxy(d.stop,d)),d;return r.map(k,eb,j),r.isFunction(j.opts.start)&&j.opts.start.call(a,j),r.fx.timer(r.extend(i,{elem:a,anim:j,queue:j.opts.queue})),j.progress(j.opts.progress).done(j.opts.done,j.opts.complete).fail(j.opts.fail).always(j.opts.always)}r.Animation=r.extend(hb,{tweeners:{"*":[function(a,b){var c=this.createTween(a,b);return ea(c.elem,a,aa.exec(b),c),c}]},tweener:function(a,b){r.isFunction(a)?(b=a,a=["*"]):a=a.match(K);for(var c,d=0,e=a.length;d<e;d++)c=a[d],hb.tweeners[c]=hb.tweeners[c]||[],hb.tweeners[c].unshift(b)},prefilters:[fb],prefilter:function(a,b){b?hb.prefilters.unshift(a):hb.prefilters.push(a)}}),r.speed=function(a,b,c){var e=a&&"object"==typeof a?r.extend({},a):{complete:c||!c&&b||r.isFunction(a)&&a,duration:a,easing:c&&b||b&&!r.isFunction(b)&&b};return r.fx.off||d.hidden?e.duration=0:"number"!=typeof e.duration&&(e.duration in r.fx.speeds?e.duration=r.fx.speeds[e.duration]:e.duration=r.fx.speeds._default),null!=e.queue&&e.queue!==!0||(e.queue="fx"),e.old=e.complete,e.complete=function(){r.isFunction(e.old)&&e.old.call(this),e.queue&&r.dequeue(this,e.queue)},e},r.fn.extend({fadeTo:function(a,b,c,d){return this.filter(ca).css("opacity",0).show().end().animate({opacity:b},a,c,d)},animate:function(a,b,c,d){var e=r.isEmptyObject(a),f=r.speed(b,c,d),g=function(){var b=hb(this,r.extend({},a),f);(e||V.get(this,"finish"))&&b.stop(!0)};return g.finish=g,e||f.queue===!1?this.each(g):this.queue(f.queue,g)},stop:function(a,b,c){var d=function(a){var b=a.stop;delete a.stop,b(c)};return"string"!=typeof a&&(c=b,b=a,a=void 0),b&&a!==!1&&this.queue(a||"fx",[]),this.each(function(){var b=!0,e=null!=a&&a+"queueHooks",f=r.timers,g=V.get(this);if(e)g[e]&&g[e].stop&&d(g[e]);else for(e in g)g[e]&&g[e].stop&&ab.test(e)&&d(g[e]);for(e=f.length;e--;)f[e].elem!==this||null!=a&&f[e].queue!==a||(f[e].anim.stop(c),b=!1,f.splice(e,1));!b&&c||r.dequeue(this,a)})},finish:function(a){return a!==!1&&(a=a||"fx"),this.each(function(){var b,c=V.get(this),d=c[a+"queue"],e=c[a+"queueHooks"],f=r.timers,g=d?d.length:0;for(c.finish=!0,r.queue(this,a,[]),e&&e.stop&&e.stop.call(this,!0),b=f.length;b--;)f[b].elem===this&&f[b].queue===a&&(f[b].anim.stop(!0),f.splice(b,1));for(b=0;b<g;b++)d[b]&&d[b].finish&&d[b].finish.call(this);delete c.finish})}}),r.each(["toggle","show","hide"],function(a,b){var c=r.fn[b];r.fn[b]=function(a,d,e){return null==a||"boolean"==typeof a?c.apply(this,arguments):this.animate(db(b,!0),a,d,e)}}),r.each({slideDown:db("show"),slideUp:db("hide"),slideToggle:db("toggle"),fadeIn:{opacity:"show"},fadeOut:{opacity:"hide"},fadeToggle:{opacity:"toggle"}},function(a,b){r.fn[a]=function(a,c,d){return this.animate(b,a,c,d)}}),r.timers=[],r.fx.tick=function(){var a,b=0,c=r.timers;for(Za=r.now();b<c.length;b++)a=c[b],a()||c[b]!==a||c.splice(b--,1);c.length||r.fx.stop(),Za=void 0},r.fx.timer=function(a){r.timers.push(a),a()?r.fx.start():r.timers.pop()},r.fx.interval=13,r.fx.start=function(){$a||($a=a.requestAnimationFrame?a.requestAnimationFrame(bb):a.setInterval(r.fx.tick,r.fx.interval))},r.fx.stop=function(){a.cancelAnimationFrame?a.cancelAnimationFrame($a):a.clearInterval($a),$a=null},r.fx.speeds={slow:600,fast:200,_default:400},r.fn.delay=function(b,c){return b=r.fx?r.fx.speeds[b]||b:b,c=c||"fx",this.queue(c,function(c,d){var e=a.setTimeout(c,b);d.stop=function(){a.clearTimeout(e)}})},function(){var a=d.createElement("input"),b=d.createElement("select"),c=b.appendChild(d.createElement("option"));a.type="checkbox",o.checkOn=""!==a.value,o.optSelected=c.selected,a=d.createElement("input"),a.value="t",a.type="radio",o.radioValue="t"===a.value}();var ib,jb=r.expr.attrHandle;r.fn.extend({attr:function(a,b){return S(this,r.attr,a,b,arguments.length>1)},removeAttr:function(a){return this.each(function(){r.removeAttr(this,a)})}}),r.extend({attr:function(a,b,c){var d,e,f=a.nodeType;if(3!==f&&8!==f&&2!==f)return"undefined"==typeof a.getAttribute?r.prop(a,b,c):(1===f&&r.isXMLDoc(a)||(e=r.attrHooks[b.toLowerCase()]||(r.expr.match.bool.test(b)?ib:void 0)),
void 0!==c?null===c?void r.removeAttr(a,b):e&&"set"in e&&void 0!==(d=e.set(a,c,b))?d:(a.setAttribute(b,c+""),c):e&&"get"in e&&null!==(d=e.get(a,b))?d:(d=r.find.attr(a,b),null==d?void 0:d))},attrHooks:{type:{set:function(a,b){if(!o.radioValue&&"radio"===b&&r.nodeName(a,"input")){var c=a.value;return a.setAttribute("type",b),c&&(a.value=c),b}}}},removeAttr:function(a,b){var c,d=0,e=b&&b.match(K);if(e&&1===a.nodeType)while(c=e[d++])a.removeAttribute(c)}}),ib={set:function(a,b,c){return b===!1?r.removeAttr(a,c):a.setAttribute(c,c),c}},r.each(r.expr.match.bool.source.match(/\w+/g),function(a,b){var c=jb[b]||r.find.attr;jb[b]=function(a,b,d){var e,f,g=b.toLowerCase();return d||(f=jb[g],jb[g]=e,e=null!=c(a,b,d)?g:null,jb[g]=f),e}});var kb=/^(?:input|select|textarea|button)$/i,lb=/^(?:a|area)$/i;r.fn.extend({prop:function(a,b){return S(this,r.prop,a,b,arguments.length>1)},removeProp:function(a){return this.each(function(){delete this[r.propFix[a]||a]})}}),r.extend({prop:function(a,b,c){var d,e,f=a.nodeType;if(3!==f&&8!==f&&2!==f)return 1===f&&r.isXMLDoc(a)||(b=r.propFix[b]||b,e=r.propHooks[b]),void 0!==c?e&&"set"in e&&void 0!==(d=e.set(a,c,b))?d:a[b]=c:e&&"get"in e&&null!==(d=e.get(a,b))?d:a[b]},propHooks:{tabIndex:{get:function(a){var b=r.find.attr(a,"tabindex");return b?parseInt(b,10):kb.test(a.nodeName)||lb.test(a.nodeName)&&a.href?0:-1}}},propFix:{"for":"htmlFor","class":"className"}}),o.optSelected||(r.propHooks.selected={get:function(a){var b=a.parentNode;return b&&b.parentNode&&b.parentNode.selectedIndex,null},set:function(a){var b=a.parentNode;b&&(b.selectedIndex,b.parentNode&&b.parentNode.selectedIndex)}}),r.each(["tabIndex","readOnly","maxLength","cellSpacing","cellPadding","rowSpan","colSpan","useMap","frameBorder","contentEditable"],function(){r.propFix[this.toLowerCase()]=this});function mb(a){var b=a.match(K)||[];return b.join(" ")}function nb(a){return a.getAttribute&&a.getAttribute("class")||""}r.fn.extend({addClass:function(a){var b,c,d,e,f,g,h,i=0;if(r.isFunction(a))return this.each(function(b){r(this).addClass(a.call(this,b,nb(this)))});if("string"==typeof a&&a){b=a.match(K)||[];while(c=this[i++])if(e=nb(c),d=1===c.nodeType&&" "+mb(e)+" "){g=0;while(f=b[g++])d.indexOf(" "+f+" ")<0&&(d+=f+" ");h=mb(d),e!==h&&c.setAttribute("class",h)}}return this},removeClass:function(a){var b,c,d,e,f,g,h,i=0;if(r.isFunction(a))return this.each(function(b){r(this).removeClass(a.call(this,b,nb(this)))});if(!arguments.length)return this.attr("class","");if("string"==typeof a&&a){b=a.match(K)||[];while(c=this[i++])if(e=nb(c),d=1===c.nodeType&&" "+mb(e)+" "){g=0;while(f=b[g++])while(d.indexOf(" "+f+" ")>-1)d=d.replace(" "+f+" "," ");h=mb(d),e!==h&&c.setAttribute("class",h)}}return this},toggleClass:function(a,b){var c=typeof a;return"boolean"==typeof b&&"string"===c?b?this.addClass(a):this.removeClass(a):r.isFunction(a)?this.each(function(c){r(this).toggleClass(a.call(this,c,nb(this),b),b)}):this.each(function(){var b,d,e,f;if("string"===c){d=0,e=r(this),f=a.match(K)||[];while(b=f[d++])e.hasClass(b)?e.removeClass(b):e.addClass(b)}else void 0!==a&&"boolean"!==c||(b=nb(this),b&&V.set(this,"__className__",b),this.setAttribute&&this.setAttribute("class",b||a===!1?"":V.get(this,"__className__")||""))})},hasClass:function(a){var b,c,d=0;b=" "+a+" ";while(c=this[d++])if(1===c.nodeType&&(" "+mb(nb(c))+" ").indexOf(b)>-1)return!0;return!1}});var ob=/\r/g;r.fn.extend({val:function(a){var b,c,d,e=this[0];{if(arguments.length)return d=r.isFunction(a),this.each(function(c){var e;1===this.nodeType&&(e=d?a.call(this,c,r(this).val()):a,null==e?e="":"number"==typeof e?e+="":r.isArray(e)&&(e=r.map(e,function(a){return null==a?"":a+""})),b=r.valHooks[this.type]||r.valHooks[this.nodeName.toLowerCase()],b&&"set"in b&&void 0!==b.set(this,e,"value")||(this.value=e))});if(e)return b=r.valHooks[e.type]||r.valHooks[e.nodeName.toLowerCase()],b&&"get"in b&&void 0!==(c=b.get(e,"value"))?c:(c=e.value,"string"==typeof c?c.replace(ob,""):null==c?"":c)}}}),r.extend({valHooks:{option:{get:function(a){var b=r.find.attr(a,"value");return null!=b?b:mb(r.text(a))}},select:{get:function(a){var b,c,d,e=a.options,f=a.selectedIndex,g="select-one"===a.type,h=g?null:[],i=g?f+1:e.length;for(d=f<0?i:g?f:0;d<i;d++)if(c=e[d],(c.selected||d===f)&&!c.disabled&&(!c.parentNode.disabled||!r.nodeName(c.parentNode,"optgroup"))){if(b=r(c).val(),g)return b;h.push(b)}return h},set:function(a,b){var c,d,e=a.options,f=r.makeArray(b),g=e.length;while(g--)d=e[g],(d.selected=r.inArray(r.valHooks.option.get(d),f)>-1)&&(c=!0);return c||(a.selectedIndex=-1),f}}}}),r.each(["radio","checkbox"],function(){r.valHooks[this]={set:function(a,b){if(r.isArray(b))return a.checked=r.inArray(r(a).val(),b)>-1}},o.checkOn||(r.valHooks[this].get=function(a){return null===a.getAttribute("value")?"on":a.value})});var pb=/^(?:focusinfocus|focusoutblur)$/;r.extend(r.event,{trigger:function(b,c,e,f){var g,h,i,j,k,m,n,o=[e||d],p=l.call(b,"type")?b.type:b,q=l.call(b,"namespace")?b.namespace.split("."):[];if(h=i=e=e||d,3!==e.nodeType&&8!==e.nodeType&&!pb.test(p+r.event.triggered)&&(p.indexOf(".")>-1&&(q=p.split("."),p=q.shift(),q.sort()),k=p.indexOf(":")<0&&"on"+p,b=b[r.expando]?b:new r.Event(p,"object"==typeof b&&b),b.isTrigger=f?2:3,b.namespace=q.join("."),b.rnamespace=b.namespace?new RegExp("(^|\\.)"+q.join("\\.(?:.*\\.|)")+"(\\.|$)"):null,b.result=void 0,b.target||(b.target=e),c=null==c?[b]:r.makeArray(c,[b]),n=r.event.special[p]||{},f||!n.trigger||n.trigger.apply(e,c)!==!1)){if(!f&&!n.noBubble&&!r.isWindow(e)){for(j=n.delegateType||p,pb.test(j+p)||(h=h.parentNode);h;h=h.parentNode)o.push(h),i=h;i===(e.ownerDocument||d)&&o.push(i.defaultView||i.parentWindow||a)}g=0;while((h=o[g++])&&!b.isPropagationStopped())b.type=g>1?j:n.bindType||p,m=(V.get(h,"events")||{})[b.type]&&V.get(h,"handle"),m&&m.apply(h,c),m=k&&h[k],m&&m.apply&&T(h)&&(b.result=m.apply(h,c),b.result===!1&&b.preventDefault());return b.type=p,f||b.isDefaultPrevented()||n._default&&n._default.apply(o.pop(),c)!==!1||!T(e)||k&&r.isFunction(e[p])&&!r.isWindow(e)&&(i=e[k],i&&(e[k]=null),r.event.triggered=p,e[p](),r.event.triggered=void 0,i&&(e[k]=i)),b.result}},simulate:function(a,b,c){var d=r.extend(new r.Event,c,{type:a,isSimulated:!0});r.event.trigger(d,null,b)}}),r.fn.extend({trigger:function(a,b){return this.each(function(){r.event.trigger(a,b,this)})},triggerHandler:function(a,b){var c=this[0];if(c)return r.event.trigger(a,b,c,!0)}}),r.each("blur focus focusin focusout resize scroll click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup contextmenu".split(" "),function(a,b){r.fn[b]=function(a,c){return arguments.length>0?this.on(b,null,a,c):this.trigger(b)}}),r.fn.extend({hover:function(a,b){return this.mouseenter(a).mouseleave(b||a)}}),o.focusin="onfocusin"in a,o.focusin||r.each({focus:"focusin",blur:"focusout"},function(a,b){var c=function(a){r.event.simulate(b,a.target,r.event.fix(a))};r.event.special[b]={setup:function(){var d=this.ownerDocument||this,e=V.access(d,b);e||d.addEventListener(a,c,!0),V.access(d,b,(e||0)+1)},teardown:function(){var d=this.ownerDocument||this,e=V.access(d,b)-1;e?V.access(d,b,e):(d.removeEventListener(a,c,!0),V.remove(d,b))}}});var qb=a.location,rb=r.now(),sb=/\?/;r.parseXML=function(b){var c;if(!b||"string"!=typeof b)return null;try{c=(new a.DOMParser).parseFromString(b,"text/xml")}catch(d){c=void 0}return c&&!c.getElementsByTagName("parsererror").length||r.error("Invalid XML: "+b),c};var tb=/\[\]$/,ub=/\r?\n/g,vb=/^(?:submit|button|image|reset|file)$/i,wb=/^(?:input|select|textarea|keygen)/i;function xb(a,b,c,d){var e;if(r.isArray(b))r.each(b,function(b,e){c||tb.test(a)?d(a,e):xb(a+"["+("object"==typeof e&&null!=e?b:"")+"]",e,c,d)});else if(c||"object"!==r.type(b))d(a,b);else for(e in b)xb(a+"["+e+"]",b[e],c,d)}r.param=function(a,b){var c,d=[],e=function(a,b){var c=r.isFunction(b)?b():b;d[d.length]=encodeURIComponent(a)+"="+encodeURIComponent(null==c?"":c)};if(r.isArray(a)||a.jquery&&!r.isPlainObject(a))r.each(a,function(){e(this.name,this.value)});else for(c in a)xb(c,a[c],b,e);return d.join("&")},r.fn.extend({serialize:function(){return r.param(this.serializeArray())},serializeArray:function(){return this.map(function(){var a=r.prop(this,"elements");return a?r.makeArray(a):this}).filter(function(){var a=this.type;return this.name&&!r(this).is(":disabled")&&wb.test(this.nodeName)&&!vb.test(a)&&(this.checked||!ia.test(a))}).map(function(a,b){var c=r(this).val();return null==c?null:r.isArray(c)?r.map(c,function(a){return{name:b.name,value:a.replace(ub,"\r\n")}}):{name:b.name,value:c.replace(ub,"\r\n")}}).get()}});var yb=/%20/g,zb=/#.*$/,Ab=/([?&])_=[^&]*/,Bb=/^(.*?):[ \t]*([^\r\n]*)$/gm,Cb=/^(?:about|app|app-storage|.+-extension|file|res|widget):$/,Db=/^(?:GET|HEAD)$/,Eb=/^\/\//,Fb={},Gb={},Hb="*/".concat("*"),Ib=d.createElement("a");Ib.href=qb.href;function Jb(a){return function(b,c){"string"!=typeof b&&(c=b,b="*");var d,e=0,f=b.toLowerCase().match(K)||[];if(r.isFunction(c))while(d=f[e++])"+"===d[0]?(d=d.slice(1)||"*",(a[d]=a[d]||[]).unshift(c)):(a[d]=a[d]||[]).push(c)}}function Kb(a,b,c,d){var e={},f=a===Gb;function g(h){var i;return e[h]=!0,r.each(a[h]||[],function(a,h){var j=h(b,c,d);return"string"!=typeof j||f||e[j]?f?!(i=j):void 0:(b.dataTypes.unshift(j),g(j),!1)}),i}return g(b.dataTypes[0])||!e["*"]&&g("*")}function Lb(a,b){var c,d,e=r.ajaxSettings.flatOptions||{};for(c in b)void 0!==b[c]&&((e[c]?a:d||(d={}))[c]=b[c]);return d&&r.extend(!0,a,d),a}function Mb(a,b,c){var d,e,f,g,h=a.contents,i=a.dataTypes;while("*"===i[0])i.shift(),void 0===d&&(d=a.mimeType||b.getResponseHeader("Content-Type"));if(d)for(e in h)if(h[e]&&h[e].test(d)){i.unshift(e);break}if(i[0]in c)f=i[0];else{for(e in c){if(!i[0]||a.converters[e+" "+i[0]]){f=e;break}g||(g=e)}f=f||g}if(f)return f!==i[0]&&i.unshift(f),c[f]}function Nb(a,b,c,d){var e,f,g,h,i,j={},k=a.dataTypes.slice();if(k[1])for(g in a.converters)j[g.toLowerCase()]=a.converters[g];f=k.shift();while(f)if(a.responseFields[f]&&(c[a.responseFields[f]]=b),!i&&d&&a.dataFilter&&(b=a.dataFilter(b,a.dataType)),i=f,f=k.shift())if("*"===f)f=i;else if("*"!==i&&i!==f){if(g=j[i+" "+f]||j["* "+f],!g)for(e in j)if(h=e.split(" "),h[1]===f&&(g=j[i+" "+h[0]]||j["* "+h[0]])){g===!0?g=j[e]:j[e]!==!0&&(f=h[0],k.unshift(h[1]));break}if(g!==!0)if(g&&a["throws"])b=g(b);else try{b=g(b)}catch(l){return{state:"parsererror",error:g?l:"No conversion from "+i+" to "+f}}}return{state:"success",data:b}}r.extend({active:0,lastModified:{},etag:{},ajaxSettings:{url:qb.href,type:"GET",isLocal:Cb.test(qb.protocol),global:!0,processData:!0,async:!0,contentType:"application/x-www-form-urlencoded; charset=UTF-8",accepts:{"*":Hb,text:"text/plain",html:"text/html",xml:"application/xml, text/xml",json:"application/json, text/javascript"},contents:{xml:/\bxml\b/,html:/\bhtml/,json:/\bjson\b/},responseFields:{xml:"responseXML",text:"responseText",json:"responseJSON"},converters:{"* text":String,"text html":!0,"text json":JSON.parse,"text xml":r.parseXML},flatOptions:{url:!0,context:!0}},ajaxSetup:function(a,b){return b?Lb(Lb(a,r.ajaxSettings),b):Lb(r.ajaxSettings,a)},ajaxPrefilter:Jb(Fb),ajaxTransport:Jb(Gb),ajax:function(b,c){"object"==typeof b&&(c=b,b=void 0),c=c||{};var e,f,g,h,i,j,k,l,m,n,o=r.ajaxSetup({},c),p=o.context||o,q=o.context&&(p.nodeType||p.jquery)?r(p):r.event,s=r.Deferred(),t=r.Callbacks("once memory"),u=o.statusCode||{},v={},w={},x="canceled",y={readyState:0,getResponseHeader:function(a){var b;if(k){if(!h){h={};while(b=Bb.exec(g))h[b[1].toLowerCase()]=b[2]}b=h[a.toLowerCase()]}return null==b?null:b},getAllResponseHeaders:function(){return k?g:null},setRequestHeader:function(a,b){return null==k&&(a=w[a.toLowerCase()]=w[a.toLowerCase()]||a,v[a]=b),this},overrideMimeType:function(a){return null==k&&(o.mimeType=a),this},statusCode:function(a){var b;if(a)if(k)y.always(a[y.status]);else for(b in a)u[b]=[u[b],a[b]];return this},abort:function(a){var b=a||x;return e&&e.abort(b),A(0,b),this}};if(s.promise(y),o.url=((b||o.url||qb.href)+"").replace(Eb,qb.protocol+"//"),o.type=c.method||c.type||o.method||o.type,o.dataTypes=(o.dataType||"*").toLowerCase().match(K)||[""],null==o.crossDomain){j=d.createElement("a");try{j.href=o.url,j.href=j.href,o.crossDomain=Ib.protocol+"//"+Ib.host!=j.protocol+"//"+j.host}catch(z){o.crossDomain=!0}}if(o.data&&o.processData&&"string"!=typeof o.data&&(o.data=r.param(o.data,o.traditional)),Kb(Fb,o,c,y),k)return y;l=r.event&&o.global,l&&0===r.active++&&r.event.trigger("ajaxStart"),o.type=o.type.toUpperCase(),o.hasContent=!Db.test(o.type),f=o.url.replace(zb,""),o.hasContent?o.data&&o.processData&&0===(o.contentType||"").indexOf("application/x-www-form-urlencoded")&&(o.data=o.data.replace(yb,"+")):(n=o.url.slice(f.length),o.data&&(f+=(sb.test(f)?"&":"?")+o.data,delete o.data),o.cache===!1&&(f=f.replace(Ab,"$1"),n=(sb.test(f)?"&":"?")+"_="+rb++ +n),o.url=f+n),o.ifModified&&(r.lastModified[f]&&y.setRequestHeader("If-Modified-Since",r.lastModified[f]),r.etag[f]&&y.setRequestHeader("If-None-Match",r.etag[f])),(o.data&&o.hasContent&&o.contentType!==!1||c.contentType)&&y.setRequestHeader("Content-Type",o.contentType),y.setRequestHeader("Accept",o.dataTypes[0]&&o.accepts[o.dataTypes[0]]?o.accepts[o.dataTypes[0]]+("*"!==o.dataTypes[0]?", "+Hb+"; q=0.01":""):o.accepts["*"]);for(m in o.headers)y.setRequestHeader(m,o.headers[m]);if(o.beforeSend&&(o.beforeSend.call(p,y,o)===!1||k))return y.abort();if(x="abort",t.add(o.complete),y.done(o.success),y.fail(o.error),e=Kb(Gb,o,c,y)){if(y.readyState=1,l&&q.trigger("ajaxSend",[y,o]),k)return y;o.async&&o.timeout>0&&(i=a.setTimeout(function(){y.abort("timeout")},o.timeout));try{k=!1,e.send(v,A)}catch(z){if(k)throw z;A(-1,z)}}else A(-1,"No Transport");function A(b,c,d,h){var j,m,n,v,w,x=c;k||(k=!0,i&&a.clearTimeout(i),e=void 0,g=h||"",y.readyState=b>0?4:0,j=b>=200&&b<300||304===b,d&&(v=Mb(o,y,d)),v=Nb(o,v,y,j),j?(o.ifModified&&(w=y.getResponseHeader("Last-Modified"),w&&(r.lastModified[f]=w),w=y.getResponseHeader("etag"),w&&(r.etag[f]=w)),204===b||"HEAD"===o.type?x="nocontent":304===b?x="notmodified":(x=v.state,m=v.data,n=v.error,j=!n)):(n=x,!b&&x||(x="error",b<0&&(b=0))),y.status=b,y.statusText=(c||x)+"",j?s.resolveWith(p,[m,x,y]):s.rejectWith(p,[y,x,n]),y.statusCode(u),u=void 0,l&&q.trigger(j?"ajaxSuccess":"ajaxError",[y,o,j?m:n]),t.fireWith(p,[y,x]),l&&(q.trigger("ajaxComplete",[y,o]),--r.active||r.event.trigger("ajaxStop")))}return y},getJSON:function(a,b,c){return r.get(a,b,c,"json")},getScript:function(a,b){return r.get(a,void 0,b,"script")}}),r.each(["get","post"],function(a,b){r[b]=function(a,c,d,e){return r.isFunction(c)&&(e=e||d,d=c,c=void 0),r.ajax(r.extend({url:a,type:b,dataType:e,data:c,success:d},r.isPlainObject(a)&&a))}}),r._evalUrl=function(a){return r.ajax({url:a,type:"GET",dataType:"script",cache:!0,async:!1,global:!1,"throws":!0})},r.fn.extend({wrapAll:function(a){var b;return this[0]&&(r.isFunction(a)&&(a=a.call(this[0])),b=r(a,this[0].ownerDocument).eq(0).clone(!0),this[0].parentNode&&b.insertBefore(this[0]),b.map(function(){var a=this;while(a.firstElementChild)a=a.firstElementChild;return a}).append(this)),this},wrapInner:function(a){return r.isFunction(a)?this.each(function(b){r(this).wrapInner(a.call(this,b))}):this.each(function(){var b=r(this),c=b.contents();c.length?c.wrapAll(a):b.append(a)})},wrap:function(a){var b=r.isFunction(a);return this.each(function(c){r(this).wrapAll(b?a.call(this,c):a)})},unwrap:function(a){return this.parent(a).not("body").each(function(){r(this).replaceWith(this.childNodes)}),this}}),r.expr.pseudos.hidden=function(a){return!r.expr.pseudos.visible(a)},r.expr.pseudos.visible=function(a){return!!(a.offsetWidth||a.offsetHeight||a.getClientRects().length)},r.ajaxSettings.xhr=function(){try{return new a.XMLHttpRequest}catch(b){}};var Ob={0:200,1223:204},Pb=r.ajaxSettings.xhr();o.cors=!!Pb&&"withCredentials"in Pb,o.ajax=Pb=!!Pb,r.ajaxTransport(function(b){var c,d;if(o.cors||Pb&&!b.crossDomain)return{send:function(e,f){var g,h=b.xhr();if(h.open(b.type,b.url,b.async,b.username,b.password),b.xhrFields)for(g in b.xhrFields)h[g]=b.xhrFields[g];b.mimeType&&h.overrideMimeType&&h.overrideMimeType(b.mimeType),b.crossDomain||e["X-Requested-With"]||(e["X-Requested-With"]="XMLHttpRequest");for(g in e)h.setRequestHeader(g,e[g]);c=function(a){return function(){c&&(c=d=h.onload=h.onerror=h.onabort=h.onreadystatechange=null,"abort"===a?h.abort():"error"===a?"number"!=typeof h.status?f(0,"error"):f(h.status,h.statusText):f(Ob[h.status]||h.status,h.statusText,"text"!==(h.responseType||"text")||"string"!=typeof h.responseText?{binary:h.response}:{text:h.responseText},h.getAllResponseHeaders()))}},h.onload=c(),d=h.onerror=c("error"),void 0!==h.onabort?h.onabort=d:h.onreadystatechange=function(){4===h.readyState&&a.setTimeout(function(){c&&d()})},c=c("abort");try{h.send(b.hasContent&&b.data||null)}catch(i){if(c)throw i}},abort:function(){c&&c()}}}),r.ajaxPrefilter(function(a){a.crossDomain&&(a.contents.script=!1)}),r.ajaxSetup({accepts:{script:"text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"},contents:{script:/\b(?:java|ecma)script\b/},converters:{"text script":function(a){return r.globalEval(a),a}}}),r.ajaxPrefilter("script",function(a){void 0===a.cache&&(a.cache=!1),a.crossDomain&&(a.type="GET")}),r.ajaxTransport("script",function(a){if(a.crossDomain){var b,c;return{send:function(e,f){b=r("<script>").prop({charset:a.scriptCharset,src:a.url}).on("load error",c=function(a){b.remove(),c=null,a&&f("error"===a.type?404:200,a.type)}),d.head.appendChild(b[0])},abort:function(){c&&c()}}}});var Qb=[],Rb=/(=)\?(?=&|$)|\?\?/;r.ajaxSetup({jsonp:"callback",jsonpCallback:function(){var a=Qb.pop()||r.expando+"_"+rb++;return this[a]=!0,a}}),r.ajaxPrefilter("json jsonp",function(b,c,d){var e,f,g,h=b.jsonp!==!1&&(Rb.test(b.url)?"url":"string"==typeof b.data&&0===(b.contentType||"").indexOf("application/x-www-form-urlencoded")&&Rb.test(b.data)&&"data");if(h||"jsonp"===b.dataTypes[0])return e=b.jsonpCallback=r.isFunction(b.jsonpCallback)?b.jsonpCallback():b.jsonpCallback,h?b[h]=b[h].replace(Rb,"$1"+e):b.jsonp!==!1&&(b.url+=(sb.test(b.url)?"&":"?")+b.jsonp+"="+e),b.converters["script json"]=function(){return g||r.error(e+" was not called"),g[0]},b.dataTypes[0]="json",f=a[e],a[e]=function(){g=arguments},d.always(function(){void 0===f?r(a).removeProp(e):a[e]=f,b[e]&&(b.jsonpCallback=c.jsonpCallback,Qb.push(e)),g&&r.isFunction(f)&&f(g[0]),g=f=void 0}),"script"}),o.createHTMLDocument=function(){var a=d.implementation.createHTMLDocument("").body;return a.innerHTML="<form></form><form></form>",2===a.childNodes.length}(),r.parseHTML=function(a,b,c){if("string"!=typeof a)return[];"boolean"==typeof b&&(c=b,b=!1);var e,f,g;return b||(o.createHTMLDocument?(b=d.implementation.createHTMLDocument(""),e=b.createElement("base"),e.href=d.location.href,b.head.appendChild(e)):b=d),f=B.exec(a),g=!c&&[],f?[b.createElement(f[1])]:(f=pa([a],b,g),g&&g.length&&r(g).remove(),r.merge([],f.childNodes))},r.fn.load=function(a,b,c){var d,e,f,g=this,h=a.indexOf(" ");return h>-1&&(d=mb(a.slice(h)),a=a.slice(0,h)),r.isFunction(b)?(c=b,b=void 0):b&&"object"==typeof b&&(e="POST"),g.length>0&&r.ajax({url:a,type:e||"GET",dataType:"html",data:b}).done(function(a){f=arguments,g.html(d?r("<div>").append(r.parseHTML(a)).find(d):a)}).always(c&&function(a,b){g.each(function(){c.apply(this,f||[a.responseText,b,a])})}),this},r.each(["ajaxStart","ajaxStop","ajaxComplete","ajaxError","ajaxSuccess","ajaxSend"],function(a,b){r.fn[b]=function(a){return this.on(b,a)}}),r.expr.pseudos.animated=function(a){return r.grep(r.timers,function(b){return a===b.elem}).length};function Sb(a){return r.isWindow(a)?a:9===a.nodeType&&a.defaultView}r.offset={setOffset:function(a,b,c){var d,e,f,g,h,i,j,k=r.css(a,"position"),l=r(a),m={};"static"===k&&(a.style.position="relative"),h=l.offset(),f=r.css(a,"top"),i=r.css(a,"left"),j=("absolute"===k||"fixed"===k)&&(f+i).indexOf("auto")>-1,j?(d=l.position(),g=d.top,e=d.left):(g=parseFloat(f)||0,e=parseFloat(i)||0),r.isFunction(b)&&(b=b.call(a,c,r.extend({},h))),null!=b.top&&(m.top=b.top-h.top+g),null!=b.left&&(m.left=b.left-h.left+e),"using"in b?b.using.call(a,m):l.css(m)}},r.fn.extend({offset:function(a){if(arguments.length)return void 0===a?this:this.each(function(b){r.offset.setOffset(this,a,b)});var b,c,d,e,f=this[0];if(f)return f.getClientRects().length?(d=f.getBoundingClientRect(),d.width||d.height?(e=f.ownerDocument,c=Sb(e),b=e.documentElement,{top:d.top+c.pageYOffset-b.clientTop,left:d.left+c.pageXOffset-b.clientLeft}):d):{top:0,left:0}},position:function(){if(this[0]){var a,b,c=this[0],d={top:0,left:0};return"fixed"===r.css(c,"position")?b=c.getBoundingClientRect():(a=this.offsetParent(),b=this.offset(),r.nodeName(a[0],"html")||(d=a.offset()),d={top:d.top+r.css(a[0],"borderTopWidth",!0),left:d.left+r.css(a[0],"borderLeftWidth",!0)}),{top:b.top-d.top-r.css(c,"marginTop",!0),left:b.left-d.left-r.css(c,"marginLeft",!0)}}},offsetParent:function(){return this.map(function(){var a=this.offsetParent;while(a&&"static"===r.css(a,"position"))a=a.offsetParent;return a||qa})}}),r.each({scrollLeft:"pageXOffset",scrollTop:"pageYOffset"},function(a,b){var c="pageYOffset"===b;r.fn[a]=function(d){return S(this,function(a,d,e){var f=Sb(a);return void 0===e?f?f[b]:a[d]:void(f?f.scrollTo(c?f.pageXOffset:e,c?e:f.pageYOffset):a[d]=e)},a,d,arguments.length)}}),r.each(["top","left"],function(a,b){r.cssHooks[b]=Oa(o.pixelPosition,function(a,c){if(c)return c=Na(a,b),La.test(c)?r(a).position()[b]+"px":c})}),r.each({Height:"height",Width:"width"},function(a,b){r.each({padding:"inner"+a,content:b,"":"outer"+a},function(c,d){r.fn[d]=function(e,f){var g=arguments.length&&(c||"boolean"!=typeof e),h=c||(e===!0||f===!0?"margin":"border");return S(this,function(b,c,e){var f;return r.isWindow(b)?0===d.indexOf("outer")?b["inner"+a]:b.document.documentElement["client"+a]:9===b.nodeType?(f=b.documentElement,Math.max(b.body["scroll"+a],f["scroll"+a],b.body["offset"+a],f["offset"+a],f["client"+a])):void 0===e?r.css(b,c,h):r.style(b,c,e,h)},b,g?e:void 0,g)}})}),r.fn.extend({bind:function(a,b,c){return this.on(a,null,b,c)},unbind:function(a,b){return this.off(a,null,b)},delegate:function(a,b,c,d){return this.on(b,a,c,d)},undelegate:function(a,b,c){return 1===arguments.length?this.off(a,"**"):this.off(b,a||"**",c)}}),r.parseJSON=JSON.parse,"function"==typeof define&&define.amd&&define("jquery",[],function(){return r});var Tb=a.jQuery,Ub=a.$;return r.noConflict=function(b){return a.$===r&&(a.$=Ub),b&&a.jQuery===r&&(a.jQuery=Tb),r},b||(a.jQuery=a.$=r),r});

/*! jQuery Migrate v1.2.1 | (c) 2005, 2013 jQuery Foundation, Inc. and other contributors | jquery.org/license */
jQuery.migrateMute===void 0&&(jQuery.migrateMute=!0),function(e,t,n){function r(n){var r=t.console;i[n]||(i[n]=!0,e.migrateWarnings.push(n),r&&r.warn&&!e.migrateMute&&(r.warn("JQMIGRATE: "+n),e.migrateTrace&&r.trace&&r.trace()))}function a(t,a,i,o){if(Object.defineProperty)try{return Object.defineProperty(t,a,{configurable:!0,enumerable:!0,get:function(){return r(o),i},set:function(e){r(o),i=e}}),n}catch(s){}e._definePropertyBroken=!0,t[a]=i}var i={};e.migrateWarnings=[],!e.migrateMute&&t.console&&t.console.log&&t.console.log("JQMIGRATE: Logging is active"),e.migrateTrace===n&&(e.migrateTrace=!0),e.migrateReset=function(){i={},e.migrateWarnings.length=0},"BackCompat"===document.compatMode&&r("jQuery is not compatible with Quirks Mode");var o=e("<input/>",{size:1}).attr("size")&&e.attrFn,s=e.attr,u=e.attrHooks.value&&e.attrHooks.value.get||function(){return null},c=e.attrHooks.value&&e.attrHooks.value.set||function(){return n},l=/^(?:input|button)$/i,d=/^[238]$/,p=/^(?:autofocus|autoplay|async|checked|controls|defer|disabled|hidden|loop|multiple|open|readonly|required|scoped|selected)$/i,f=/^(?:checked|selected)$/i;a(e,"attrFn",o||{},"jQuery.attrFn is deprecated"),e.attr=function(t,a,i,u){var c=a.toLowerCase(),g=t&&t.nodeType;return u&&(4>s.length&&r("jQuery.fn.attr( props, pass ) is deprecated"),t&&!d.test(g)&&(o?a in o:e.isFunction(e.fn[a])))?e(t)[a](i):("type"===a&&i!==n&&l.test(t.nodeName)&&t.parentNode&&r("Can't change the 'type' of an input or button in IE 6/7/8"),!e.attrHooks[c]&&p.test(c)&&(e.attrHooks[c]={get:function(t,r){var a,i=e.prop(t,r);return i===!0||"boolean"!=typeof i&&(a=t.getAttributeNode(r))&&a.nodeValue!==!1?r.toLowerCase():n},set:function(t,n,r){var a;return n===!1?e.removeAttr(t,r):(a=e.propFix[r]||r,a in t&&(t[a]=!0),t.setAttribute(r,r.toLowerCase())),r}},f.test(c)&&r("jQuery.fn.attr('"+c+"') may use property instead of attribute")),s.call(e,t,a,i))},e.attrHooks.value={get:function(e,t){var n=(e.nodeName||"").toLowerCase();return"button"===n?u.apply(this,arguments):("input"!==n&&"option"!==n&&r("jQuery.fn.attr('value') no longer gets properties"),t in e?e.value:null)},set:function(e,t){var a=(e.nodeName||"").toLowerCase();return"button"===a?c.apply(this,arguments):("input"!==a&&"option"!==a&&r("jQuery.fn.attr('value', val) no longer sets properties"),e.value=t,n)}};var g,h,v=e.fn.init,m=e.parseJSON,y=/^([^<]*)(<[\w\W]+>)([^>]*)$/;e.fn.init=function(t,n,a){var i;return t&&"string"==typeof t&&!e.isPlainObject(n)&&(i=y.exec(e.trim(t)))&&i[0]&&("<"!==t.charAt(0)&&r("$(html) HTML strings must start with '<' character"),i[3]&&r("$(html) HTML text after last tag is ignored"),"#"===i[0].charAt(0)&&(r("HTML string cannot start with a '#' character"),e.error("JQMIGRATE: Invalid selector string (XSS)")),n&&n.context&&(n=n.context),e.parseHTML)?v.call(this,e.parseHTML(i[2],n,!0),n,a):v.apply(this,arguments)},e.fn.init.prototype=e.fn,e.parseJSON=function(e){return e||null===e?m.apply(this,arguments):(r("jQuery.parseJSON requires a valid JSON string"),null)},e.uaMatch=function(e){e=e.toLowerCase();var t=/(chrome)[ \/]([\w.]+)/.exec(e)||/(webkit)[ \/]([\w.]+)/.exec(e)||/(opera)(?:.*version|)[ \/]([\w.]+)/.exec(e)||/(msie) ([\w.]+)/.exec(e)||0>e.indexOf("compatible")&&/(mozilla)(?:.*? rv:([\w.]+)|)/.exec(e)||[];return{browser:t[1]||"",version:t[2]||"0"}},e.browser||(g=e.uaMatch(navigator.userAgent),h={},g.browser&&(h[g.browser]=!0,h.version=g.version),h.chrome?h.webkit=!0:h.webkit&&(h.safari=!0),e.browser=h),a(e,"browser",e.browser,"jQuery.browser is deprecated"),e.sub=function(){function t(e,n){return new t.fn.init(e,n)}e.extend(!0,t,this),t.superclass=this,t.fn=t.prototype=this(),t.fn.constructor=t,t.sub=this.sub,t.fn.init=function(r,a){return a&&a instanceof e&&!(a instanceof t)&&(a=t(a)),e.fn.init.call(this,r,a,n)},t.fn.init.prototype=t.fn;var n=t(document);return r("jQuery.sub() is deprecated"),t},e.ajaxSetup({converters:{"text json":e.parseJSON}});var b=e.fn.data;e.fn.data=function(t){var a,i,o=this[0];return!o||"events"!==t||1!==arguments.length||(a=e.data(o,t),i=e._data(o,t),a!==n&&a!==i||i===n)?b.apply(this,arguments):(r("Use of jQuery.fn.data('events') is deprecated"),i)};var j=/\/(java|ecma)script/i,w=e.fn.andSelf||e.fn.addBack;e.fn.andSelf=function(){return r("jQuery.fn.andSelf() replaced by jQuery.fn.addBack()"),w.apply(this,arguments)},e.clean||(e.clean=function(t,a,i,o){a=a||document,a=!a.nodeType&&a[0]||a,a=a.ownerDocument||a,r("jQuery.clean() is deprecated");var s,u,c,l,d=[];if(e.merge(d,e.buildFragment(t,a).childNodes),i)for(c=function(e){return!e.type||j.test(e.type)?o?o.push(e.parentNode?e.parentNode.removeChild(e):e):i.appendChild(e):n},s=0;null!=(u=d[s]);s++)e.nodeName(u,"script")&&c(u)||(i.appendChild(u),u.getElementsByTagName!==n&&(l=e.grep(e.merge([],u.getElementsByTagName("script")),c),d.splice.apply(d,[s+1,0].concat(l)),s+=l.length));return d});var Q=e.event.add,x=e.event.remove,k=e.event.trigger,N=e.fn.toggle,T=e.fn.live,M=e.fn.die,S="ajaxStart|ajaxStop|ajaxSend|ajaxComplete|ajaxError|ajaxSuccess",C=RegExp("\\b(?:"+S+")\\b"),H=/(?:^|\s)hover(\.\S+|)\b/,A=function(t){return"string"!=typeof t||e.event.special.hover?t:(H.test(t)&&r("'hover' pseudo-event is deprecated, use 'mouseenter mouseleave'"),t&&t.replace(H,"mouseenter$1 mouseleave$1"))};e.event.props&&"attrChange"!==e.event.props[0]&&e.event.props.unshift("attrChange","attrName","relatedNode","srcElement"),e.event.dispatch&&a(e.event,"handle",e.event.dispatch,"jQuery.event.handle is undocumented and deprecated"),e.event.add=function(e,t,n,a,i){e!==document&&C.test(t)&&r("AJAX events should be attached to document: "+t),Q.call(this,e,A(t||""),n,a,i)},e.event.remove=function(e,t,n,r,a){x.call(this,e,A(t)||"",n,r,a)},e.fn.error=function(){var e=Array.prototype.slice.call(arguments,0);return r("jQuery.fn.error() is deprecated"),e.splice(0,0,"error"),arguments.length?this.bind.apply(this,e):(this.triggerHandler.apply(this,e),this)},e.fn.toggle=function(t,n){if(!e.isFunction(t)||!e.isFunction(n))return N.apply(this,arguments);r("jQuery.fn.toggle(handler, handler...) is deprecated");var a=arguments,i=t.guid||e.guid++,o=0,s=function(n){var r=(e._data(this,"lastToggle"+t.guid)||0)%o;return e._data(this,"lastToggle"+t.guid,r+1),n.preventDefault(),a[r].apply(this,arguments)||!1};for(s.guid=i;a.length>o;)a[o++].guid=i;return this.click(s)},e.fn.live=function(t,n,a){return r("jQuery.fn.live() is deprecated"),T?T.apply(this,arguments):(e(this.context).on(t,this.selector,n,a),this)},e.fn.die=function(t,n){return r("jQuery.fn.die() is deprecated"),M?M.apply(this,arguments):(e(this.context).off(t,this.selector||"**",n),this)},e.event.trigger=function(e,t,n,a){return n||C.test(e)||r("Global events are undocumented and deprecated"),k.call(this,e,t,n||document,a)},e.each(S.split("|"),function(t,n){e.event.special[n]={setup:function(){var t=this;return t!==document&&(e.event.add(document,n+"."+e.guid,function(){e.event.trigger(n,null,t,!0)}),e._data(this,n,e.guid++)),!1},teardown:function(){return this!==document&&e.event.remove(document,n+"."+e._data(this,n)),!1}}})}(jQuery,window);

/*! device.js 0.2.7 */
(function(){var a,b,c,d,e,f,g,h,i,j;b=window.device,a={},window.device=a,d=window.document.documentElement,j=window.navigator.userAgent.toLowerCase(),a.ios=function(){return a.iphone()||a.ipod()||a.ipad()},a.iphone=function(){return!a.windows()&&e("iphone")},a.ipod=function(){return e("ipod")},a.ipad=function(){return e("ipad")},a.android=function(){return!a.windows()&&e("android")},a.androidPhone=function(){return a.android()&&e("mobile")},a.androidTablet=function(){return a.android()&&!e("mobile")},a.blackberry=function(){return e("blackberry")||e("bb10")||e("rim")},a.blackberryPhone=function(){return a.blackberry()&&!e("tablet")},a.blackberryTablet=function(){return a.blackberry()&&e("tablet")},a.windows=function(){return e("windows")},a.windowsPhone=function(){return a.windows()&&e("phone")},a.windowsTablet=function(){return a.windows()&&e("touch")&&!a.windowsPhone()},a.fxos=function(){return(e("(mobile;")||e("(tablet;"))&&e("; rv:")},a.fxosPhone=function(){return a.fxos()&&e("mobile")},a.fxosTablet=function(){return a.fxos()&&e("tablet")},a.meego=function(){return e("meego")},a.cordova=function(){return window.cordova&&"file:"===location.protocol},a.nodeWebkit=function(){return"object"==typeof window.process},a.mobile=function(){return a.androidPhone()||a.iphone()||a.ipod()||a.windowsPhone()||a.blackberryPhone()||a.fxosPhone()||a.meego()},a.tablet=function(){return a.ipad()||a.androidTablet()||a.blackberryTablet()||a.windowsTablet()||a.fxosTablet()},a.desktop=function(){return!a.tablet()&&!a.mobile()},a.television=function(){var a;for(television=["googletv","viera","smarttv","internet.tv","netcast","nettv","appletv","boxee","kylo","roku","dlnadoc","roku","pov_tv","hbbtv","ce-html"],a=0;a<television.length;){if(e(television[a]))return!0;a++}return!1},a.portrait=function(){return window.innerHeight/window.innerWidth>1},a.landscape=function(){return window.innerHeight/window.innerWidth<1},a.noConflict=function(){return window.device=b,this},e=function(a){return-1!==j.indexOf(a)},g=function(a){var b;return b=new RegExp(a,"i"),d.className.match(b)},c=function(a){var b=null;g(a)||(b=d.className.replace(/^\s+|\s+$/g,""),d.className=b+" "+a)},i=function(a){g(a)&&(d.className=d.className.replace(" "+a,""))},a.ios()?a.ipad()?c("ios ipad tablet"):a.iphone()?c("ios iphone mobile"):a.ipod()&&c("ios ipod mobile"):a.android()?c(a.androidTablet()?"android tablet":"android mobile"):a.blackberry()?c(a.blackberryTablet()?"blackberry tablet":"blackberry mobile"):a.windows()?c(a.windowsTablet()?"windows tablet":a.windowsPhone()?"windows mobile":"desktop"):a.fxos()?c(a.fxosTablet()?"fxos tablet":"fxos mobile"):a.meego()?c("meego mobile"):a.nodeWebkit()?c("node-webkit"):a.television()?c("television"):a.desktop()&&c("desktop"),a.cordova()&&c("cordova"),f=function(){a.landscape()?(i("portrait"),c("landscape")):(i("landscape"),c("portrait"))},h=Object.prototype.hasOwnProperty.call(window,"onorientationchange")?"orientationchange":"resize",window.addEventListener?window.addEventListener(h,f,!1):window.attachEvent?window.attachEvent(h,f):window[h]=f,f(),"function"==typeof define&&"object"==typeof define.amd&&define.amd?define(function(){return a}):"undefined"!=typeof module&&module.exports?module.exports=a:window.device=a}).call(this);

/* svg4everybody.legacy.min.js */
!function(a,b){"function"==typeof define&&define.amd?define([],function(){return a.svg4everybody=b()}):"object"==typeof module&&module.exports?module.exports=b():a.svg4everybody=b()}(this,function(){function a(a,b,c){if(c){var d=document.createDocumentFragment(),e=!b.hasAttribute("viewBox")&&c.getAttribute("viewBox");e&&b.setAttribute("viewBox",e);for(var f=c.cloneNode(!0);f.childNodes.length;)d.appendChild(f.firstChild);a.appendChild(d)}}function b(b){b.onreadystatechange=function(){if(4===b.readyState){var c=b._cachedDocument;c||(c=b._cachedDocument=document.implementation.createHTMLDocument(""),c.body.innerHTML=b.responseText,b._cachedTarget={}),b._embeds.splice(0).map(function(d){var e=b._cachedTarget[d.id];e||(e=b._cachedTarget[d.id]=c.getElementById(d.id)),a(d.parent,d.svg,e)})}},b.onreadystatechange()}function c(c){function e(){for(var c=0;c<r.length;){var j=r[c],k=j.parentNode,l=d(k);if(l){var m=j.getAttribute("xlink:href")||j.getAttribute("href");if(!m&&h.attributeName&&(m=j.getAttribute(h.attributeName)),f){var n=document.createElement("img");n.style.cssText="display:inline-block;height:100%;width:100%",n.setAttribute("width",l.getAttribute("width")||l.clientWidth),n.setAttribute("height",l.getAttribute("height")||l.clientHeight),n.src=g(m,l,j),k.replaceChild(n,j)}else if(i)if(!h.validate||h.validate(m,l,j)){k.removeChild(j);var o=m.split("#"),t=o.shift(),u=o.join("#");if(t.length){var v=p[t];v||(v=p[t]=new XMLHttpRequest,v.open("GET",t),v.send(),v._embeds=[]),v._embeds.push({parent:k,svg:l,id:u}),b(v)}else a(k,l,document.getElementById(u))}else++c,++s}else++c}(!r.length||r.length-s>0)&&q(e,67)}var f,g,h=Object(c);g=h.fallback||function(a){return a.replace(/\?[^#]+/,"").replace("#",".").replace(/^\./,"")+".png"+(/\?[^#]+/.exec(a)||[""])[0]},f="nosvg"in h?h.nosvg:/\bMSIE [1-8]\b/.test(navigator.userAgent),f&&(document.createElement("svg"),document.createElement("use"));var i,j=/\bMSIE [1-8]\.0\b/,k=/\bTrident\/[567]\b|\bMSIE (?:9|10)\.0\b/,l=/\bAppleWebKit\/(\d+)\b/,m=/\bEdge\/12\.(\d+)\b/,n=/\bEdge\/.(\d+)\b/,o=window.top!==window.self;i="polyfill"in h?h.polyfill:j.test(navigator.userAgent)||k.test(navigator.userAgent)||(navigator.userAgent.match(m)||[])[1]<10547||(navigator.userAgent.match(l)||[])[1]<537||n.test(navigator.userAgent)&&o;var p={},q=window.requestAnimationFrame||setTimeout,r=document.getElementsByTagName("use"),s=0;i&&e()}function d(a){for(var b=a;"svg"!==b.nodeName.toLowerCase()&&(b=b.parentNode););return b}return c});

/*! jQuery Simple Waypoint 1.0.0 by github.com/thecheg/ */
(function($){
	jQuery.fn.simpleWaypoint = function(options) {
		options = $.extend({
			position: 0,
			onDown: function() {},
			onUp: function() {}
		}, options);

		var element = $(this),
			position = 0;

		if (typeof options.position == 'function') {
			position = options.position.call(this);
		} else {
			position = options.position;
		}

		$(window).on('resize',function() {
			if (typeof options.position == 'function') {
				position = options.position.call(this);
			} else {
				position = options.position;
			}
		});

		var activate = function(){
			$(window).on('scroll',function() {
				if ($(window).scrollTop() > position) {
					if (typeof options.onDown == 'function') {
						options.onDown.call(this);
					}
				} else {
					if (typeof options.onUp == 'function') {
						options.onUp.call(this);
					}
				}
			});
		}
		return this.each(activate);
	};
})(jQuery);

// Ion.RangeSlider
// version 2.3.1 Build: 382
// © Denis Ineshin, 2019
// https://github.com/IonDen
//
// Project page:    http://ionden.com/a/plugins/ion.rangeSlider/en.html
// GitHub page:     https://github.com/IonDen/ion.rangeSlider
//
// Released under MIT licence:
// http://ionden.com/a/plugins/licence-en.html
// =====================================================================================================================

;(function(factory) {
	if ((typeof jQuery === 'undefined' || !jQuery) && typeof define === "function" && define.amd) {
		define(["jquery"], function (jQuery) {
			return factory(jQuery, document, window, navigator);
		});
	} else if ((typeof jQuery === 'undefined' || !jQuery) && typeof exports === "object") {
		factory(require("jquery"), document, window, navigator);
	} else {
		factory(jQuery, document, window, navigator);
	}
} (function ($, document, window, navigator, undefined) {
	"use strict";

	// =================================================================================================================
	// Service

	var plugin_count = 0;

	// IE8 fix
	var is_old_ie = (function () {
		var n = navigator.userAgent,
			r = /msie\s\d+/i,
			v;
		if (n.search(r) > 0) {
			v = r.exec(n).toString();
			v = v.split(" ")[1];
			if (v < 9) {
				$("html").addClass("lt-ie9");
				return true;
			}
		}
		return false;
	} ());
	if (!Function.prototype.bind) {
		Function.prototype.bind = function bind(that) {

			var target = this;
			var slice = [].slice;

			if (typeof target != "function") {
				throw new TypeError();
			}

			var args = slice.call(arguments, 1),
				bound = function () {

					if (this instanceof bound) {

						var F = function(){};
						F.prototype = target.prototype;
						var self = new F();

						var result = target.apply(
							self,
							args.concat(slice.call(arguments))
						);
						if (Object(result) === result) {
							return result;
						}
						return self;

					} else {

						return target.apply(
							that,
							args.concat(slice.call(arguments))
						);

					}

				};

			return bound;
		};
	}
	if (!Array.prototype.indexOf) {
		Array.prototype.indexOf = function(searchElement, fromIndex) {
			var k;
			if (this == null) {
				throw new TypeError('"this" is null or not defined');
			}
			var O = Object(this);
			var len = O.length >>> 0;
			if (len === 0) {
				return -1;
			}
			var n = +fromIndex || 0;
			if (Math.abs(n) === Infinity) {
				n = 0;
			}
			if (n >= len) {
				return -1;
			}
			k = Math.max(n >= 0 ? n : len - Math.abs(n), 0);
			while (k < len) {
				if (k in O && O[k] === searchElement) {
					return k;
				}
				k++;
			}
			return -1;
		};
	}



	// =================================================================================================================
	// Template

	var base_html =
		'<span class="irs">' +
		'<span class="irs-line" tabindex="0"></span>' +
		'<span class="irs-min">0</span><span class="irs-max">1</span>' +
		'<span class="irs-from">0</span><span class="irs-to">0</span><span class="irs-single">0</span>' +
		'</span>' +
		'<span class="irs-grid"></span>';

	var single_html =
		'<span class="irs-bar irs-bar--single"></span>' +
		'<span class="irs-shadow shadow-single"></span>' +
		'<span class="irs-handle single"><i></i><i></i><i></i></span>';

	var double_html =
		'<span class="irs-bar"></span>' +
		'<span class="irs-shadow shadow-from"></span>' +
		'<span class="irs-shadow shadow-to"></span>' +
		'<span class="irs-handle from"><i></i><i></i><i></i></span>' +
		'<span class="irs-handle to"><i></i><i></i><i></i></span>';

	var disable_html =
		'<span class="irs-disable-mask"></span>';



	// =================================================================================================================
	// Core

	/**
	 * Main plugin constructor
	 *
	 * @param input {Object} link to base input element
	 * @param options {Object} slider config
	 * @param plugin_count {Number}
	 * @constructor
	 */
	var IonRangeSlider = function (input, options, plugin_count) {
		this.VERSION = "2.3.1";
		this.input = input;
		this.plugin_count = plugin_count;
		this.current_plugin = 0;
		this.calc_count = 0;
		this.update_tm = 0;
		this.old_from = 0;
		this.old_to = 0;
		this.old_min_interval = null;
		this.raf_id = null;
		this.dragging = false;
		this.force_redraw = false;
		this.no_diapason = false;
		this.has_tab_index = true;
		this.is_key = false;
		this.is_update = false;
		this.is_start = true;
		this.is_finish = false;
		this.is_active = false;
		this.is_resize = false;
		this.is_click = false;

		options = options || {};

		// cache for links to all DOM elements
		this.$cache = {
			win: $(window),
			body: $(document.body),
			input: $(input),
			cont: null,
			rs: null,
			min: null,
			max: null,
			from: null,
			to: null,
			single: null,
			bar: null,
			line: null,
			s_single: null,
			s_from: null,
			s_to: null,
			shad_single: null,
			shad_from: null,
			shad_to: null,
			edge: null,
			grid: null,
			grid_labels: []
		};

		// storage for measure variables
		this.coords = {
			// left
			x_gap: 0,
			x_pointer: 0,

			// width
			w_rs: 0,
			w_rs_old: 0,
			w_handle: 0,

			// percents
			p_gap: 0,
			p_gap_left: 0,
			p_gap_right: 0,
			p_step: 0,
			p_pointer: 0,
			p_handle: 0,
			p_single_fake: 0,
			p_single_real: 0,
			p_from_fake: 0,
			p_from_real: 0,
			p_to_fake: 0,
			p_to_real: 0,
			p_bar_x: 0,
			p_bar_w: 0,

			// grid
			grid_gap: 0,
			big_num: 0,
			big: [],
			big_w: [],
			big_p: [],
			big_x: []
		};

		// storage for labels measure variables
		this.labels = {
			// width
			w_min: 0,
			w_max: 0,
			w_from: 0,
			w_to: 0,
			w_single: 0,

			// percents
			p_min: 0,
			p_max: 0,
			p_from_fake: 0,
			p_from_left: 0,
			p_to_fake: 0,
			p_to_left: 0,
			p_single_fake: 0,
			p_single_left: 0
		};



		/**
		 * get and validate config
		 */
		var $inp = this.$cache.input,
			val = $inp.prop("value"),
			config, config_from_data, prop;

		// default config
		config = {
			skin: "flat",
			type: "single",

			min: 10,
			max: 100,
			from: null,
			to: null,
			step: 1,

			min_interval: 0,
			max_interval: 0,
			drag_interval: false,

			values: [],
			p_values: [],

			from_fixed: false,
			from_min: null,
			from_max: null,
			from_shadow: false,

			to_fixed: false,
			to_min: null,
			to_max: null,
			to_shadow: false,

			prettify_enabled: true,
			prettify_separator: " ",
			prettify: null,

			force_edges: false,

			keyboard: true,

			grid: false,
			grid_margin: true,
			grid_num: 4,
			grid_snap: false,

			hide_min_max: false,
			hide_from_to: false,

			prefix: "",
			postfix: "",
			max_postfix: "",
			decorate_both: true,
			values_separator: " — ",

			input_values_separator: ";",

			disable: false,
			block: false,

			extra_classes: "",

			scope: null,
			onStart: null,
			onChange: null,
			onFinish: null,
			onUpdate: null
		};


		// check if base element is input
		if ($inp[0].nodeName !== "INPUT") {
			console && console.warn && console.warn("Base element should be <input>!", $inp[0]);
		}


		// config from data-attributes extends js config
		config_from_data = {
			skin: $inp.data("skin"),
			type: $inp.data("type"),

			min: $inp.data("min"),
			max: $inp.data("max"),
			from: $inp.data("from"),
			to: $inp.data("to"),
			step: $inp.data("step"),

			min_interval: $inp.data("minInterval"),
			max_interval: $inp.data("maxInterval"),
			drag_interval: $inp.data("dragInterval"),

			values: $inp.data("values"),

			from_fixed: $inp.data("fromFixed"),
			from_min: $inp.data("fromMin"),
			from_max: $inp.data("fromMax"),
			from_shadow: $inp.data("fromShadow"),

			to_fixed: $inp.data("toFixed"),
			to_min: $inp.data("toMin"),
			to_max: $inp.data("toMax"),
			to_shadow: $inp.data("toShadow"),

			prettify_enabled: $inp.data("prettifyEnabled"),
			prettify_separator: $inp.data("prettifySeparator"),

			force_edges: $inp.data("forceEdges"),

			keyboard: $inp.data("keyboard"),

			grid: $inp.data("grid"),
			grid_margin: $inp.data("gridMargin"),
			grid_num: $inp.data("gridNum"),
			grid_snap: $inp.data("gridSnap"),

			hide_min_max: $inp.data("hideMinMax"),
			hide_from_to: $inp.data("hideFromTo"),

			prefix: $inp.data("prefix"),
			postfix: $inp.data("postfix"),
			max_postfix: $inp.data("maxPostfix"),
			decorate_both: $inp.data("decorateBoth"),
			values_separator: $inp.data("valuesSeparator"),

			input_values_separator: $inp.data("inputValuesSeparator"),

			disable: $inp.data("disable"),
			block: $inp.data("block"),

			extra_classes: $inp.data("extraClasses"),
		};
		config_from_data.values = config_from_data.values && config_from_data.values.split(",");

		for (prop in config_from_data) {
			if (config_from_data.hasOwnProperty(prop)) {
				if (config_from_data[prop] === undefined || config_from_data[prop] === "") {
					delete config_from_data[prop];
				}
			}
		}


		// input value extends default config
		if (val !== undefined && val !== "") {
			val = val.split(config_from_data.input_values_separator || options.input_values_separator || ";");

			if (val[0] && val[0] == +val[0]) {
				val[0] = +val[0];
			}
			if (val[1] && val[1] == +val[1]) {
				val[1] = +val[1];
			}

			if (options && options.values && options.values.length) {
				config.from = val[0] && options.values.indexOf(val[0]);
				config.to = val[1] && options.values.indexOf(val[1]);
			} else {
				config.from = val[0] && +val[0];
				config.to = val[1] && +val[1];
			}
		}



		// js config extends default config
		$.extend(config, options);


		// data config extends config
		$.extend(config, config_from_data);
		this.options = config;



		// validate config, to be sure that all data types are correct
		this.update_check = {};
		this.validate();



		// default result object, returned to callbacks
		this.result = {
			input: this.$cache.input,
			slider: null,

			min: this.options.min,
			max: this.options.max,

			from: this.options.from,
			from_percent: 0,
			from_value: null,

			to: this.options.to,
			to_percent: 0,
			to_value: null
		};



		this.init();
	};

	IonRangeSlider.prototype = {

		/**
		 * Starts or updates the plugin instance
		 *
		 * @param [is_update] {boolean}
		 */
		init: function (is_update) {
			this.no_diapason = false;
			this.coords.p_step = this.convertToPercent(this.options.step, true);

			this.target = "base";

			this.toggleInput();
			this.append();
			this.setMinMax();

			if (is_update) {
				this.force_redraw = true;
				this.calc(true);

				// callbacks called
				this.callOnUpdate();
			} else {
				this.force_redraw = true;
				this.calc(true);

				// callbacks called
				this.callOnStart();
			}

			this.updateScene();
		},

		/**
		 * Appends slider template to a DOM
		 */
		append: function () {
			var container_html = '<span class="irs irs--' + this.options.skin + ' js-irs-' + this.plugin_count + ' ' + this.options.extra_classes + '"></span>';
			this.$cache.input.before(container_html);
			this.$cache.input.prop("readonly", true);
			this.$cache.cont = this.$cache.input.prev();
			this.result.slider = this.$cache.cont;

			this.$cache.cont.html(base_html);
			this.$cache.rs = this.$cache.cont.find(".irs");
			this.$cache.min = this.$cache.cont.find(".irs-min");
			this.$cache.max = this.$cache.cont.find(".irs-max");
			this.$cache.from = this.$cache.cont.find(".irs-from");
			this.$cache.to = this.$cache.cont.find(".irs-to");
			this.$cache.single = this.$cache.cont.find(".irs-single");
			this.$cache.line = this.$cache.cont.find(".irs-line");
			this.$cache.grid = this.$cache.cont.find(".irs-grid");

			if (this.options.type === "single") {
				this.$cache.cont.append(single_html);
				this.$cache.bar = this.$cache.cont.find(".irs-bar");
				this.$cache.edge = this.$cache.cont.find(".irs-bar-edge");
				this.$cache.s_single = this.$cache.cont.find(".single");
				this.$cache.from[0].style.visibility = "hidden";
				this.$cache.to[0].style.visibility = "hidden";
				this.$cache.shad_single = this.$cache.cont.find(".shadow-single");
			} else {
				this.$cache.cont.append(double_html);
				this.$cache.bar = this.$cache.cont.find(".irs-bar");
				this.$cache.s_from = this.$cache.cont.find(".from");
				this.$cache.s_to = this.$cache.cont.find(".to");
				this.$cache.shad_from = this.$cache.cont.find(".shadow-from");
				this.$cache.shad_to = this.$cache.cont.find(".shadow-to");

				this.setTopHandler();
			}

			if (this.options.hide_from_to) {
				this.$cache.from[0].style.display = "none";
				this.$cache.to[0].style.display = "none";
				this.$cache.single[0].style.display = "none";
			}

			this.appendGrid();

			if (this.options.disable) {
				this.appendDisableMask();
				this.$cache.input[0].disabled = true;
			} else {
				this.$cache.input[0].disabled = false;
				this.removeDisableMask();
				this.bindEvents();
			}

			// block only if not disabled
			if (!this.options.disable) {
				if (this.options.block) {
					this.appendDisableMask();
				} else {
					this.removeDisableMask();
				}
			}

			if (this.options.drag_interval) {
				this.$cache.bar[0].style.cursor = "ew-resize";
			}
		},

		/**
		 * Determine which handler has a priority
		 * works only for double slider type
		 */
		setTopHandler: function () {
			var min = this.options.min,
				max = this.options.max,
				from = this.options.from,
				to = this.options.to;

			if (from > min && to === max) {
				this.$cache.s_from.addClass("type_last");
			} else if (to < max) {
				this.$cache.s_to.addClass("type_last");
			}
		},

		/**
		 * Determine which handles was clicked last
		 * and which handler should have hover effect
		 *
		 * @param target {String}
		 */
		changeLevel: function (target) {
			switch (target) {
				case "single":
					this.coords.p_gap = this.toFixed(this.coords.p_pointer - this.coords.p_single_fake);
					this.$cache.s_single.addClass("state_hover");
					break;
				case "from":
					this.coords.p_gap = this.toFixed(this.coords.p_pointer - this.coords.p_from_fake);
					this.$cache.s_from.addClass("state_hover");
					this.$cache.s_from.addClass("type_last");
					this.$cache.s_to.removeClass("type_last");
					break;
				case "to":
					this.coords.p_gap = this.toFixed(this.coords.p_pointer - this.coords.p_to_fake);
					this.$cache.s_to.addClass("state_hover");
					this.$cache.s_to.addClass("type_last");
					this.$cache.s_from.removeClass("type_last");
					break;
				case "both":
					this.coords.p_gap_left = this.toFixed(this.coords.p_pointer - this.coords.p_from_fake);
					this.coords.p_gap_right = this.toFixed(this.coords.p_to_fake - this.coords.p_pointer);
					this.$cache.s_to.removeClass("type_last");
					this.$cache.s_from.removeClass("type_last");
					break;
			}
		},

		/**
		 * Then slider is disabled
		 * appends extra layer with opacity
		 */
		appendDisableMask: function () {
			this.$cache.cont.append(disable_html);
			this.$cache.cont.addClass("irs-disabled");
		},

		/**
		 * Then slider is not disabled
		 * remove disable mask
		 */
		removeDisableMask: function () {
			this.$cache.cont.remove(".irs-disable-mask");
			this.$cache.cont.removeClass("irs-disabled");
		},

		/**
		 * Remove slider instance
		 * and unbind all events
		 */
		remove: function () {
			this.$cache.cont.remove();
			this.$cache.cont = null;

			this.$cache.line.off("keydown.irs_" + this.plugin_count);

			this.$cache.body.off("touchmove.irs_" + this.plugin_count);
			this.$cache.body.off("mousemove.irs_" + this.plugin_count);

			this.$cache.win.off("touchend.irs_" + this.plugin_count);
			this.$cache.win.off("mouseup.irs_" + this.plugin_count);

			if (is_old_ie) {
				this.$cache.body.off("mouseup.irs_" + this.plugin_count);
				this.$cache.body.off("mouseleave.irs_" + this.plugin_count);
			}

			this.$cache.grid_labels = [];
			this.coords.big = [];
			this.coords.big_w = [];
			this.coords.big_p = [];
			this.coords.big_x = [];

			cancelAnimationFrame(this.raf_id);
		},

		/**
		 * bind all slider events
		 */
		bindEvents: function () {
			if (this.no_diapason) {
				return;
			}

			this.$cache.body.on("touchmove.irs_" + this.plugin_count, this.pointerMove.bind(this));
			this.$cache.body.on("mousemove.irs_" + this.plugin_count, this.pointerMove.bind(this));

			this.$cache.win.on("touchend.irs_" + this.plugin_count, this.pointerUp.bind(this));
			this.$cache.win.on("mouseup.irs_" + this.plugin_count, this.pointerUp.bind(this));

			this.$cache.line.on("touchstart.irs_" + this.plugin_count, this.pointerClick.bind(this, "click"));
			this.$cache.line.on("mousedown.irs_" + this.plugin_count, this.pointerClick.bind(this, "click"));

			this.$cache.line.on("focus.irs_" + this.plugin_count, this.pointerFocus.bind(this));

			if (this.options.drag_interval && this.options.type === "double") {
				this.$cache.bar.on("touchstart.irs_" + this.plugin_count, this.pointerDown.bind(this, "both"));
				this.$cache.bar.on("mousedown.irs_" + this.plugin_count, this.pointerDown.bind(this, "both"));
			} else {
				this.$cache.bar.on("touchstart.irs_" + this.plugin_count, this.pointerClick.bind(this, "click"));
				this.$cache.bar.on("mousedown.irs_" + this.plugin_count, this.pointerClick.bind(this, "click"));
			}

			if (this.options.type === "single") {
				this.$cache.single.on("touchstart.irs_" + this.plugin_count, this.pointerDown.bind(this, "single"));
				this.$cache.s_single.on("touchstart.irs_" + this.plugin_count, this.pointerDown.bind(this, "single"));
				this.$cache.shad_single.on("touchstart.irs_" + this.plugin_count, this.pointerClick.bind(this, "click"));

				this.$cache.single.on("mousedown.irs_" + this.plugin_count, this.pointerDown.bind(this, "single"));
				this.$cache.s_single.on("mousedown.irs_" + this.plugin_count, this.pointerDown.bind(this, "single"));
				this.$cache.edge.on("mousedown.irs_" + this.plugin_count, this.pointerClick.bind(this, "click"));
				this.$cache.shad_single.on("mousedown.irs_" + this.plugin_count, this.pointerClick.bind(this, "click"));
			} else {
				this.$cache.single.on("touchstart.irs_" + this.plugin_count, this.pointerDown.bind(this, null));
				this.$cache.single.on("mousedown.irs_" + this.plugin_count, this.pointerDown.bind(this, null));

				this.$cache.from.on("touchstart.irs_" + this.plugin_count, this.pointerDown.bind(this, "from"));
				this.$cache.s_from.on("touchstart.irs_" + this.plugin_count, this.pointerDown.bind(this, "from"));
				this.$cache.to.on("touchstart.irs_" + this.plugin_count, this.pointerDown.bind(this, "to"));
				this.$cache.s_to.on("touchstart.irs_" + this.plugin_count, this.pointerDown.bind(this, "to"));
				this.$cache.shad_from.on("touchstart.irs_" + this.plugin_count, this.pointerClick.bind(this, "click"));
				this.$cache.shad_to.on("touchstart.irs_" + this.plugin_count, this.pointerClick.bind(this, "click"));

				this.$cache.from.on("mousedown.irs_" + this.plugin_count, this.pointerDown.bind(this, "from"));
				this.$cache.s_from.on("mousedown.irs_" + this.plugin_count, this.pointerDown.bind(this, "from"));
				this.$cache.to.on("mousedown.irs_" + this.plugin_count, this.pointerDown.bind(this, "to"));
				this.$cache.s_to.on("mousedown.irs_" + this.plugin_count, this.pointerDown.bind(this, "to"));
				this.$cache.shad_from.on("mousedown.irs_" + this.plugin_count, this.pointerClick.bind(this, "click"));
				this.$cache.shad_to.on("mousedown.irs_" + this.plugin_count, this.pointerClick.bind(this, "click"));
			}

			if (this.options.keyboard) {
				this.$cache.line.on("keydown.irs_" + this.plugin_count, this.key.bind(this, "keyboard"));
			}

			if (is_old_ie) {
				this.$cache.body.on("mouseup.irs_" + this.plugin_count, this.pointerUp.bind(this));
				this.$cache.body.on("mouseleave.irs_" + this.plugin_count, this.pointerUp.bind(this));
			}
		},

		/**
		 * Focus with tabIndex
		 *
		 * @param e {Object} event object
		 */
		pointerFocus: function (e) {
			if (!this.target) {
				var x;
				var $handle;

				if (this.options.type === "single") {
					$handle = this.$cache.single;
				} else {
					$handle = this.$cache.from;
				}

				x = $handle.offset().left;
				x += ($handle.width() / 2) - 1;

				this.pointerClick("single", {preventDefault: function () {}, pageX: x});
			}
		},

		/**
		 * Mousemove or touchmove
		 * only for handlers
		 *
		 * @param e {Object} event object
		 */
		pointerMove: function (e) {
			if (!this.dragging) {
				return;
			}

			var x = e.pageX || e.originalEvent.touches && e.originalEvent.touches[0].pageX;
			this.coords.x_pointer = x - this.coords.x_gap;

			this.calc();
		},

		/**
		 * Mouseup or touchend
		 * only for handlers
		 *
		 * @param e {Object} event object
		 */
		pointerUp: function (e) {
			if (this.current_plugin !== this.plugin_count) {
				return;
			}

			if (this.is_active) {
				this.is_active = false;
			} else {
				return;
			}

			this.$cache.cont.find(".state_hover").removeClass("state_hover");

			this.force_redraw = true;

			if (is_old_ie) {
				$("*").prop("unselectable", false);
			}

			this.updateScene();
			this.restoreOriginalMinInterval();

			// callbacks call
			if ($.contains(this.$cache.cont[0], e.target) || this.dragging) {
				this.callOnFinish();
			}

			this.dragging = false;
		},

		/**
		 * Mousedown or touchstart
		 * only for handlers
		 *
		 * @param target {String|null}
		 * @param e {Object} event object
		 */
		pointerDown: function (target, e) {
			e.preventDefault();
			var x = e.pageX || e.originalEvent.touches && e.originalEvent.touches[0].pageX;
			if (e.button === 2) {
				return;
			}

			if (target === "both") {
				this.setTempMinInterval();
			}

			if (!target) {
				target = this.target || "from";
			}

			this.current_plugin = this.plugin_count;
			this.target = target;

			this.is_active = true;
			this.dragging = true;

			this.coords.x_gap = this.$cache.rs.offset().left;
			this.coords.x_pointer = x - this.coords.x_gap;

			this.calcPointerPercent();
			this.changeLevel(target);

			if (is_old_ie) {
				$("*").prop("unselectable", true);
			}

			this.$cache.line.trigger("focus");

			this.updateScene();
		},

		/**
		 * Mousedown or touchstart
		 * for other slider elements, like diapason line
		 *
		 * @param target {String}
		 * @param e {Object} event object
		 */
		pointerClick: function (target, e) {
			e.preventDefault();
			var x = e.pageX || e.originalEvent.touches && e.originalEvent.touches[0].pageX;
			if (e.button === 2) {
				return;
			}

			this.current_plugin = this.plugin_count;
			this.target = target;

			this.is_click = true;
			this.coords.x_gap = this.$cache.rs.offset().left;
			this.coords.x_pointer = +(x - this.coords.x_gap).toFixed();

			this.force_redraw = true;
			this.calc();

			this.$cache.line.trigger("focus");
		},

		/**
		 * Keyborard controls for focused slider
		 *
		 * @param target {String}
		 * @param e {Object} event object
		 * @returns {boolean|undefined}
		 */
		key: function (target, e) {
			if (this.current_plugin !== this.plugin_count || e.altKey || e.ctrlKey || e.shiftKey || e.metaKey) {
				return;
			}

			switch (e.which) {
				case 83: // W
				case 65: // A
				case 40: // DOWN
				case 37: // LEFT
					e.preventDefault();
					this.moveByKey(false);
					break;

				case 87: // S
				case 68: // D
				case 38: // UP
				case 39: // RIGHT
					e.preventDefault();
					this.moveByKey(true);
					break;
			}

			return true;
		},

		/**
		 * Move by key
		 *
		 * @param right {boolean} direction to move
		 */
		moveByKey: function (right) {
			var p = this.coords.p_pointer;
			var p_step = (this.options.max - this.options.min) / 100;
			p_step = this.options.step / p_step;

			if (right) {
				p += p_step;
			} else {
				p -= p_step;
			}

			this.coords.x_pointer = this.toFixed(this.coords.w_rs / 100 * p);
			this.is_key = true;
			this.calc();
		},

		/**
		 * Set visibility and content
		 * of Min and Max labels
		 */
		setMinMax: function () {
			if (!this.options) {
				return;
			}

			if (this.options.hide_min_max) {
				this.$cache.min[0].style.display = "none";
				this.$cache.max[0].style.display = "none";
				return;
			}

			if (this.options.values.length) {
				this.$cache.min.html(this.decorate(this.options.p_values[this.options.min]));
				this.$cache.max.html(this.decorate(this.options.p_values[this.options.max]));
			} else {
				var min_pretty = this._prettify(this.options.min);
				var max_pretty = this._prettify(this.options.max);

				this.result.min_pretty = min_pretty;
				this.result.max_pretty = max_pretty;

				this.$cache.min.html(this.decorate(min_pretty, this.options.min));
				this.$cache.max.html(this.decorate(max_pretty, this.options.max));
			}

			this.labels.w_min = this.$cache.min.outerWidth(false);
			this.labels.w_max = this.$cache.max.outerWidth(false);
		},

		/**
		 * Then dragging interval, prevent interval collapsing
		 * using min_interval option
		 */
		setTempMinInterval: function () {
			var interval = this.result.to - this.result.from;

			if (this.old_min_interval === null) {
				this.old_min_interval = this.options.min_interval;
			}

			this.options.min_interval = interval;
		},

		/**
		 * Restore min_interval option to original
		 */
		restoreOriginalMinInterval: function () {
			if (this.old_min_interval !== null) {
				this.options.min_interval = this.old_min_interval;
				this.old_min_interval = null;
			}
		},



		// =============================================================================================================
		// Calculations

		/**
		 * All calculations and measures start here
		 *
		 * @param update {boolean=}
		 */
		calc: function (update) {
			if (!this.options) {
				return;
			}

			this.calc_count++;

			if (this.calc_count === 10 || update) {
				this.calc_count = 0;
				this.coords.w_rs = this.$cache.rs.outerWidth(false);

				this.calcHandlePercent();
			}

			if (!this.coords.w_rs) {
				return;
			}

			this.calcPointerPercent();
			var handle_x = this.getHandleX();


			if (this.target === "both") {
				this.coords.p_gap = 0;
				handle_x = this.getHandleX();
			}

			if (this.target === "click") {
				this.coords.p_gap = this.coords.p_handle / 2;
				handle_x = this.getHandleX();

				if (this.options.drag_interval) {
					this.target = "both_one";
				} else {
					this.target = this.chooseHandle(handle_x);
				}
			}

			switch (this.target) {
				case "base":
					var w = (this.options.max - this.options.min) / 100,
						f = (this.result.from - this.options.min) / w,
						t = (this.result.to - this.options.min) / w;

					this.coords.p_single_real = this.toFixed(f);
					this.coords.p_from_real = this.toFixed(f);
					this.coords.p_to_real = this.toFixed(t);

					this.coords.p_single_real = this.checkDiapason(this.coords.p_single_real, this.options.from_min, this.options.from_max);
					this.coords.p_from_real = this.checkDiapason(this.coords.p_from_real, this.options.from_min, this.options.from_max);
					this.coords.p_to_real = this.checkDiapason(this.coords.p_to_real, this.options.to_min, this.options.to_max);

					this.coords.p_single_fake = this.convertToFakePercent(this.coords.p_single_real);
					this.coords.p_from_fake = this.convertToFakePercent(this.coords.p_from_real);
					this.coords.p_to_fake = this.convertToFakePercent(this.coords.p_to_real);

					this.target = null;

					break;

				case "single":
					if (this.options.from_fixed) {
						break;
					}

					this.coords.p_single_real = this.convertToRealPercent(handle_x);
					this.coords.p_single_real = this.calcWithStep(this.coords.p_single_real);
					this.coords.p_single_real = this.checkDiapason(this.coords.p_single_real, this.options.from_min, this.options.from_max);

					this.coords.p_single_fake = this.convertToFakePercent(this.coords.p_single_real);

					break;

				case "from":
					if (this.options.from_fixed) {
						break;
					}

					this.coords.p_from_real = this.convertToRealPercent(handle_x);
					this.coords.p_from_real = this.calcWithStep(this.coords.p_from_real);
					if (this.coords.p_from_real > this.coords.p_to_real) {
						this.coords.p_from_real = this.coords.p_to_real;
					}
					this.coords.p_from_real = this.checkDiapason(this.coords.p_from_real, this.options.from_min, this.options.from_max);
					this.coords.p_from_real = this.checkMinInterval(this.coords.p_from_real, this.coords.p_to_real, "from");
					this.coords.p_from_real = this.checkMaxInterval(this.coords.p_from_real, this.coords.p_to_real, "from");

					this.coords.p_from_fake = this.convertToFakePercent(this.coords.p_from_real);

					break;

				case "to":
					if (this.options.to_fixed) {
						break;
					}

					this.coords.p_to_real = this.convertToRealPercent(handle_x);
					this.coords.p_to_real = this.calcWithStep(this.coords.p_to_real);
					if (this.coords.p_to_real < this.coords.p_from_real) {
						this.coords.p_to_real = this.coords.p_from_real;
					}
					this.coords.p_to_real = this.checkDiapason(this.coords.p_to_real, this.options.to_min, this.options.to_max);
					this.coords.p_to_real = this.checkMinInterval(this.coords.p_to_real, this.coords.p_from_real, "to");
					this.coords.p_to_real = this.checkMaxInterval(this.coords.p_to_real, this.coords.p_from_real, "to");

					this.coords.p_to_fake = this.convertToFakePercent(this.coords.p_to_real);

					break;

				case "both":
					if (this.options.from_fixed || this.options.to_fixed) {
						break;
					}

					handle_x = this.toFixed(handle_x + (this.coords.p_handle * 0.001));

					this.coords.p_from_real = this.convertToRealPercent(handle_x) - this.coords.p_gap_left;
					this.coords.p_from_real = this.calcWithStep(this.coords.p_from_real);
					this.coords.p_from_real = this.checkDiapason(this.coords.p_from_real, this.options.from_min, this.options.from_max);
					this.coords.p_from_real = this.checkMinInterval(this.coords.p_from_real, this.coords.p_to_real, "from");
					this.coords.p_from_fake = this.convertToFakePercent(this.coords.p_from_real);

					this.coords.p_to_real = this.convertToRealPercent(handle_x) + this.coords.p_gap_right;
					this.coords.p_to_real = this.calcWithStep(this.coords.p_to_real);
					this.coords.p_to_real = this.checkDiapason(this.coords.p_to_real, this.options.to_min, this.options.to_max);
					this.coords.p_to_real = this.checkMinInterval(this.coords.p_to_real, this.coords.p_from_real, "to");
					this.coords.p_to_fake = this.convertToFakePercent(this.coords.p_to_real);

					break;

				case "both_one":
					if (this.options.from_fixed || this.options.to_fixed) {
						break;
					}

					var real_x = this.convertToRealPercent(handle_x),
						from = this.result.from_percent,
						to = this.result.to_percent,
						full = to - from,
						half = full / 2,
						new_from = real_x - half,
						new_to = real_x + half;

					if (new_from < 0) {
						new_from = 0;
						new_to = new_from + full;
					}

					if (new_to > 100) {
						new_to = 100;
						new_from = new_to - full;
					}

					this.coords.p_from_real = this.calcWithStep(new_from);
					this.coords.p_from_real = this.checkDiapason(this.coords.p_from_real, this.options.from_min, this.options.from_max);
					this.coords.p_from_fake = this.convertToFakePercent(this.coords.p_from_real);

					this.coords.p_to_real = this.calcWithStep(new_to);
					this.coords.p_to_real = this.checkDiapason(this.coords.p_to_real, this.options.to_min, this.options.to_max);
					this.coords.p_to_fake = this.convertToFakePercent(this.coords.p_to_real);

					break;
			}

			if (this.options.type === "single") {
				this.coords.p_bar_x = (this.coords.p_handle / 2);
				this.coords.p_bar_w = this.coords.p_single_fake;

				this.result.from_percent = this.coords.p_single_real;
				this.result.from = this.convertToValue(this.coords.p_single_real);
				this.result.from_pretty = this._prettify(this.result.from);

				if (this.options.values.length) {
					this.result.from_value = this.options.values[this.result.from];
				}
			} else {
				this.coords.p_bar_x = this.toFixed(this.coords.p_from_fake + (this.coords.p_handle / 2));
				this.coords.p_bar_w = this.toFixed(this.coords.p_to_fake - this.coords.p_from_fake);

				this.result.from_percent = this.coords.p_from_real;
				this.result.from = this.convertToValue(this.coords.p_from_real);
				this.result.from_pretty = this._prettify(this.result.from);
				this.result.to_percent = this.coords.p_to_real;
				this.result.to = this.convertToValue(this.coords.p_to_real);
				this.result.to_pretty = this._prettify(this.result.to);

				if (this.options.values.length) {
					this.result.from_value = this.options.values[this.result.from];
					this.result.to_value = this.options.values[this.result.to];
				}
			}

			this.calcMinMax();
			this.calcLabels();
		},


		/**
		 * calculates pointer X in percent
		 */
		calcPointerPercent: function () {
			if (!this.coords.w_rs) {
				this.coords.p_pointer = 0;
				return;
			}

			if (this.coords.x_pointer < 0 || isNaN(this.coords.x_pointer)  ) {
				this.coords.x_pointer = 0;
			} else if (this.coords.x_pointer > this.coords.w_rs) {
				this.coords.x_pointer = this.coords.w_rs;
			}

			this.coords.p_pointer = this.toFixed(this.coords.x_pointer / this.coords.w_rs * 100);
		},

		convertToRealPercent: function (fake) {
			var full = 100 - this.coords.p_handle;
			return fake / full * 100;
		},

		convertToFakePercent: function (real) {
			var full = 100 - this.coords.p_handle;
			return real / 100 * full;
		},

		getHandleX: function () {
			var max = 100 - this.coords.p_handle,
				x = this.toFixed(this.coords.p_pointer - this.coords.p_gap);

			if (x < 0) {
				x = 0;
			} else if (x > max) {
				x = max;
			}

			return x;
		},

		calcHandlePercent: function () {
			if (this.options.type === "single") {
				this.coords.w_handle = this.$cache.s_single.outerWidth(false);
			} else {
				this.coords.w_handle = this.$cache.s_from.outerWidth(false);
			}

			this.coords.p_handle = this.toFixed(this.coords.w_handle / this.coords.w_rs * 100);
		},

		/**
		 * Find closest handle to pointer click
		 *
		 * @param real_x {Number}
		 * @returns {String}
		 */
		chooseHandle: function (real_x) {
			if (this.options.type === "single") {
				return "single";
			} else {
				var m_point = this.coords.p_from_real + ((this.coords.p_to_real - this.coords.p_from_real) / 2);
				if (real_x >= m_point) {
					return this.options.to_fixed ? "from" : "to";
				} else {
					return this.options.from_fixed ? "to" : "from";
				}
			}
		},

		/**
		 * Measure Min and Max labels width in percent
		 */
		calcMinMax: function () {
			if (!this.coords.w_rs) {
				return;
			}

			this.labels.p_min = this.labels.w_min / this.coords.w_rs * 100;
			this.labels.p_max = this.labels.w_max / this.coords.w_rs * 100;
		},

		/**
		 * Measure labels width and X in percent
		 */
		calcLabels: function () {
			if (!this.coords.w_rs || this.options.hide_from_to) {
				return;
			}

			if (this.options.type === "single") {

				this.labels.w_single = this.$cache.single.outerWidth(false);
				this.labels.p_single_fake = this.labels.w_single / this.coords.w_rs * 100;
				this.labels.p_single_left = this.coords.p_single_fake + (this.coords.p_handle / 2) - (this.labels.p_single_fake / 2);
				this.labels.p_single_left = this.checkEdges(this.labels.p_single_left, this.labels.p_single_fake);

			} else {

				this.labels.w_from = this.$cache.from.outerWidth(false);
				this.labels.p_from_fake = this.labels.w_from / this.coords.w_rs * 100;
				this.labels.p_from_left = this.coords.p_from_fake + (this.coords.p_handle / 2) - (this.labels.p_from_fake / 2);
				this.labels.p_from_left = this.toFixed(this.labels.p_from_left);
				this.labels.p_from_left = this.checkEdges(this.labels.p_from_left, this.labels.p_from_fake);

				this.labels.w_to = this.$cache.to.outerWidth(false);
				this.labels.p_to_fake = this.labels.w_to / this.coords.w_rs * 100;
				this.labels.p_to_left = this.coords.p_to_fake + (this.coords.p_handle / 2) - (this.labels.p_to_fake / 2);
				this.labels.p_to_left = this.toFixed(this.labels.p_to_left);
				this.labels.p_to_left = this.checkEdges(this.labels.p_to_left, this.labels.p_to_fake);

				this.labels.w_single = this.$cache.single.outerWidth(false);
				this.labels.p_single_fake = this.labels.w_single / this.coords.w_rs * 100;
				this.labels.p_single_left = ((this.labels.p_from_left + this.labels.p_to_left + this.labels.p_to_fake) / 2) - (this.labels.p_single_fake / 2);
				this.labels.p_single_left = this.toFixed(this.labels.p_single_left);
				this.labels.p_single_left = this.checkEdges(this.labels.p_single_left, this.labels.p_single_fake);

			}
		},



		// =============================================================================================================
		// Drawings

		/**
		 * Main function called in request animation frame
		 * to update everything
		 */
		updateScene: function () {
			if (this.raf_id) {
				cancelAnimationFrame(this.raf_id);
				this.raf_id = null;
			}

			clearTimeout(this.update_tm);
			this.update_tm = null;

			if (!this.options) {
				return;
			}

			this.drawHandles();

			if (this.is_active) {
				this.raf_id = requestAnimationFrame(this.updateScene.bind(this));
			} else {
				this.update_tm = setTimeout(this.updateScene.bind(this), 300);
			}
		},

		/**
		 * Draw handles
		 */
		drawHandles: function () {
			this.coords.w_rs = this.$cache.rs.outerWidth(false);

			if (!this.coords.w_rs) {
				return;
			}

			if (this.coords.w_rs !== this.coords.w_rs_old) {
				this.target = "base";
				this.is_resize = true;
			}

			if (this.coords.w_rs !== this.coords.w_rs_old || this.force_redraw) {
				this.setMinMax();
				this.calc(true);
				this.drawLabels();
				if (this.options.grid) {
					this.calcGridMargin();
					this.calcGridLabels();
				}
				this.force_redraw = true;
				this.coords.w_rs_old = this.coords.w_rs;
				this.drawShadow();
			}

			if (!this.coords.w_rs) {
				return;
			}

			if (!this.dragging && !this.force_redraw && !this.is_key) {
				return;
			}

			if (this.old_from !== this.result.from || this.old_to !== this.result.to || this.force_redraw || this.is_key) {

				this.drawLabels();

				this.$cache.bar[0].style.left = this.coords.p_bar_x + "%";
				this.$cache.bar[0].style.width = this.coords.p_bar_w + "%";

				if (this.options.type === "single") {
					this.$cache.bar[0].style.left = 0;
					this.$cache.bar[0].style.width = this.coords.p_bar_w + this.coords.p_bar_x + "%";

					this.$cache.s_single[0].style.left = this.coords.p_single_fake + "%";

					this.$cache.single[0].style.left = this.labels.p_single_left + "%";
				} else {
					this.$cache.s_from[0].style.left = this.coords.p_from_fake + "%";
					this.$cache.s_to[0].style.left = this.coords.p_to_fake + "%";

					if (this.old_from !== this.result.from || this.force_redraw) {
						this.$cache.from[0].style.left = this.labels.p_from_left + "%";
					}
					if (this.old_to !== this.result.to || this.force_redraw) {
						this.$cache.to[0].style.left = this.labels.p_to_left + "%";
					}

					this.$cache.single[0].style.left = this.labels.p_single_left + "%";
				}

				this.writeToInput();

				if ((this.old_from !== this.result.from || this.old_to !== this.result.to) && !this.is_start) {
					this.$cache.input.trigger("change");
					this.$cache.input.trigger("input");
				}

				this.old_from = this.result.from;
				this.old_to = this.result.to;

				// callbacks call
				if (!this.is_resize && !this.is_update && !this.is_start && !this.is_finish) {
					this.callOnChange();
				}
				if (this.is_key || this.is_click) {
					this.is_key = false;
					this.is_click = false;
					this.callOnFinish();
				}

				this.is_update = false;
				this.is_resize = false;
				this.is_finish = false;
			}

			this.is_start = false;
			this.is_key = false;
			this.is_click = false;
			this.force_redraw = false;
		},

		/**
		 * Draw labels
		 * measure labels collisions
		 * collapse close labels
		 */
		drawLabels: function () {
			if (!this.options) {
				return;
			}

			var values_num = this.options.values.length;
			var p_values = this.options.p_values;
			var text_single;
			var text_from;
			var text_to;
			var from_pretty;
			var to_pretty;

			if (this.options.hide_from_to) {
				return;
			}

			if (this.options.type === "single") {

				if (values_num) {
					text_single = this.decorate(p_values[this.result.from]);
					this.$cache.single.html(text_single);
				} else {
					from_pretty = this._prettify(this.result.from);

					text_single = this.decorate(from_pretty, this.result.from);
					this.$cache.single.html(text_single);
				}

				this.calcLabels();

				if (this.labels.p_single_left < this.labels.p_min + 1) {
					this.$cache.min[0].style.visibility = "hidden";
				} else {
					this.$cache.min[0].style.visibility = "visible";
				}

				if (this.labels.p_single_left + this.labels.p_single_fake > 100 - this.labels.p_max - 1) {
					this.$cache.max[0].style.visibility = "hidden";
				} else {
					this.$cache.max[0].style.visibility = "visible";
				}

			} else {

				if (values_num) {

					if (this.options.decorate_both) {
						text_single = this.decorate(p_values[this.result.from]);
						text_single += this.options.values_separator;
						text_single += this.decorate(p_values[this.result.to]);
					} else {
						text_single = this.decorate(p_values[this.result.from] + this.options.values_separator + p_values[this.result.to]);
					}
					text_from = this.decorate(p_values[this.result.from]);
					text_to = this.decorate(p_values[this.result.to]);

					this.$cache.single.html(text_single);
					this.$cache.from.html(text_from);
					this.$cache.to.html(text_to);

				} else {
					from_pretty = this._prettify(this.result.from);
					to_pretty = this._prettify(this.result.to);

					if (this.options.decorate_both) {
						text_single = this.decorate(from_pretty, this.result.from);
						text_single += this.options.values_separator;
						text_single += this.decorate(to_pretty, this.result.to);
					} else {
						text_single = this.decorate(from_pretty + this.options.values_separator + to_pretty, this.result.to);
					}
					text_from = this.decorate(from_pretty, this.result.from);
					text_to = this.decorate(to_pretty, this.result.to);

					this.$cache.single.html(text_single);
					this.$cache.from.html(text_from);
					this.$cache.to.html(text_to);

				}

				this.calcLabels();

				var min = Math.min(this.labels.p_single_left, this.labels.p_from_left),
					single_left = this.labels.p_single_left + this.labels.p_single_fake,
					to_left = this.labels.p_to_left + this.labels.p_to_fake,
					max = Math.max(single_left, to_left);

				if (this.labels.p_from_left + this.labels.p_from_fake >= this.labels.p_to_left) {
					this.$cache.from[0].style.visibility = "hidden";
					this.$cache.to[0].style.visibility = "hidden";
					this.$cache.single[0].style.visibility = "visible";

					if (this.result.from === this.result.to) {
						if (this.target === "from") {
							this.$cache.from[0].style.visibility = "visible";
						} else if (this.target === "to") {
							this.$cache.to[0].style.visibility = "visible";
						} else if (!this.target) {
							this.$cache.from[0].style.visibility = "visible";
						}
						this.$cache.single[0].style.visibility = "hidden";
						max = to_left;
					} else {
						this.$cache.from[0].style.visibility = "hidden";
						this.$cache.to[0].style.visibility = "hidden";
						this.$cache.single[0].style.visibility = "visible";
						max = Math.max(single_left, to_left);
					}
				} else {
					this.$cache.from[0].style.visibility = "visible";
					this.$cache.to[0].style.visibility = "visible";
					this.$cache.single[0].style.visibility = "hidden";
				}

				if (min < this.labels.p_min + 1) {
					this.$cache.min[0].style.visibility = "hidden";
				} else {
					this.$cache.min[0].style.visibility = "visible";
				}

				if (max > 100 - this.labels.p_max - 1) {
					this.$cache.max[0].style.visibility = "hidden";
				} else {
					this.$cache.max[0].style.visibility = "visible";
				}

			}
		},

		/**
		 * Draw shadow intervals
		 */
		drawShadow: function () {
			var o = this.options,
				c = this.$cache,

				is_from_min = typeof o.from_min === "number" && !isNaN(o.from_min),
				is_from_max = typeof o.from_max === "number" && !isNaN(o.from_max),
				is_to_min = typeof o.to_min === "number" && !isNaN(o.to_min),
				is_to_max = typeof o.to_max === "number" && !isNaN(o.to_max),

				from_min,
				from_max,
				to_min,
				to_max;

			if (o.type === "single") {
				if (o.from_shadow && (is_from_min || is_from_max)) {
					from_min = this.convertToPercent(is_from_min ? o.from_min : o.min);
					from_max = this.convertToPercent(is_from_max ? o.from_max : o.max) - from_min;
					from_min = this.toFixed(from_min - (this.coords.p_handle / 100 * from_min));
					from_max = this.toFixed(from_max - (this.coords.p_handle / 100 * from_max));
					from_min = from_min + (this.coords.p_handle / 2);

					c.shad_single[0].style.display = "block";
					c.shad_single[0].style.left = from_min + "%";
					c.shad_single[0].style.width = from_max + "%";
				} else {
					c.shad_single[0].style.display = "none";
				}
			} else {
				if (o.from_shadow && (is_from_min || is_from_max)) {
					from_min = this.convertToPercent(is_from_min ? o.from_min : o.min);
					from_max = this.convertToPercent(is_from_max ? o.from_max : o.max) - from_min;
					from_min = this.toFixed(from_min - (this.coords.p_handle / 100 * from_min));
					from_max = this.toFixed(from_max - (this.coords.p_handle / 100 * from_max));
					from_min = from_min + (this.coords.p_handle / 2);

					c.shad_from[0].style.display = "block";
					c.shad_from[0].style.left = from_min + "%";
					c.shad_from[0].style.width = from_max + "%";
				} else {
					c.shad_from[0].style.display = "none";
				}

				if (o.to_shadow && (is_to_min || is_to_max)) {
					to_min = this.convertToPercent(is_to_min ? o.to_min : o.min);
					to_max = this.convertToPercent(is_to_max ? o.to_max : o.max) - to_min;
					to_min = this.toFixed(to_min - (this.coords.p_handle / 100 * to_min));
					to_max = this.toFixed(to_max - (this.coords.p_handle / 100 * to_max));
					to_min = to_min + (this.coords.p_handle / 2);

					c.shad_to[0].style.display = "block";
					c.shad_to[0].style.left = to_min + "%";
					c.shad_to[0].style.width = to_max + "%";
				} else {
					c.shad_to[0].style.display = "none";
				}
			}
		},



		/**
		 * Write values to input element
		 */
		writeToInput: function () {
			if (this.options.type === "single") {
				if (this.options.values.length) {
					this.$cache.input.prop("value", this.result.from_value);
				} else {
					this.$cache.input.prop("value", this.result.from);
				}
				this.$cache.input.data("from", this.result.from);
			} else {
				if (this.options.values.length) {
					this.$cache.input.prop("value", this.result.from_value + this.options.input_values_separator + this.result.to_value);
				} else {
					this.$cache.input.prop("value", this.result.from + this.options.input_values_separator + this.result.to);
				}
				this.$cache.input.data("from", this.result.from);
				this.$cache.input.data("to", this.result.to);
			}
		},



		// =============================================================================================================
		// Callbacks

		callOnStart: function () {
			this.writeToInput();

			if (this.options.onStart && typeof this.options.onStart === "function") {
				if (this.options.scope) {
					this.options.onStart.call(this.options.scope, this.result);
				} else {
					this.options.onStart(this.result);
				}
			}
		},
		callOnChange: function () {
			this.writeToInput();

			if (this.options.onChange && typeof this.options.onChange === "function") {
				if (this.options.scope) {
					this.options.onChange.call(this.options.scope, this.result);
				} else {
					this.options.onChange(this.result);
				}
			}
		},
		callOnFinish: function () {
			this.writeToInput();

			if (this.options.onFinish && typeof this.options.onFinish === "function") {
				if (this.options.scope) {
					this.options.onFinish.call(this.options.scope, this.result);
				} else {
					this.options.onFinish(this.result);
				}
			}
		},
		callOnUpdate: function () {
			this.writeToInput();

			if (this.options.onUpdate && typeof this.options.onUpdate === "function") {
				if (this.options.scope) {
					this.options.onUpdate.call(this.options.scope, this.result);
				} else {
					this.options.onUpdate(this.result);
				}
			}
		},




		// =============================================================================================================
		// Service methods

		toggleInput: function () {
			this.$cache.input.toggleClass("irs-hidden-input");

			if (this.has_tab_index) {
				this.$cache.input.prop("tabindex", -1);
			} else {
				this.$cache.input.removeProp("tabindex");
			}

			this.has_tab_index = !this.has_tab_index;
		},

		/**
		 * Convert real value to percent
		 *
		 * @param value {Number} X in real
		 * @param no_min {boolean=} don't use min value
		 * @returns {Number} X in percent
		 */
		convertToPercent: function (value, no_min) {
			var diapason = this.options.max - this.options.min,
				one_percent = diapason / 100,
				val, percent;

			if (!diapason) {
				this.no_diapason = true;
				return 0;
			}

			if (no_min) {
				val = value;
			} else {
				val = value - this.options.min;
			}

			percent = val / one_percent;

			return this.toFixed(percent);
		},

		/**
		 * Convert percent to real values
		 *
		 * @param percent {Number} X in percent
		 * @returns {Number} X in real
		 */
		convertToValue: function (percent) {
			var min = this.options.min,
				max = this.options.max,
				min_decimals = min.toString().split(".")[1],
				max_decimals = max.toString().split(".")[1],
				min_length, max_length,
				avg_decimals = 0,
				abs = 0;

			if (percent === 0) {
				return this.options.min;
			}
			if (percent === 100) {
				return this.options.max;
			}


			if (min_decimals) {
				min_length = min_decimals.length;
				avg_decimals = min_length;
			}
			if (max_decimals) {
				max_length = max_decimals.length;
				avg_decimals = max_length;
			}
			if (min_length && max_length) {
				avg_decimals = (min_length >= max_length) ? min_length : max_length;
			}

			if (min < 0) {
				abs = Math.abs(min);
				min = +(min + abs).toFixed(avg_decimals);
				max = +(max + abs).toFixed(avg_decimals);
			}

			var number = ((max - min) / 100 * percent) + min,
				string = this.options.step.toString().split(".")[1],
				result;

			if (string) {
				number = +number.toFixed(string.length);
			} else {
				number = number / this.options.step;
				number = number * this.options.step;

				number = +number.toFixed(0);
			}

			if (abs) {
				number -= abs;
			}

			if (string) {
				result = +number.toFixed(string.length);
			} else {
				result = this.toFixed(number);
			}

			if (result < this.options.min) {
				result = this.options.min;
			} else if (result > this.options.max) {
				result = this.options.max;
			}

			return result;
		},

		/**
		 * Round percent value with step
		 *
		 * @param percent {Number}
		 * @returns percent {Number} rounded
		 */
		calcWithStep: function (percent) {
			var rounded = Math.round(percent / this.coords.p_step) * this.coords.p_step;

			if (rounded > 100) {
				rounded = 100;
			}
			if (percent === 100) {
				rounded = 100;
			}

			return this.toFixed(rounded);
		},

		checkMinInterval: function (p_current, p_next, type) {
			var o = this.options,
				current,
				next;

			if (!o.min_interval) {
				return p_current;
			}

			current = this.convertToValue(p_current);
			next = this.convertToValue(p_next);

			if (type === "from") {

				if (next - current < o.min_interval) {
					current = next - o.min_interval;
				}

			} else {

				if (current - next < o.min_interval) {
					current = next + o.min_interval;
				}

			}

			return this.convertToPercent(current);
		},

		checkMaxInterval: function (p_current, p_next, type) {
			var o = this.options,
				current,
				next;

			if (!o.max_interval) {
				return p_current;
			}

			current = this.convertToValue(p_current);
			next = this.convertToValue(p_next);

			if (type === "from") {

				if (next - current > o.max_interval) {
					current = next - o.max_interval;
				}

			} else {

				if (current - next > o.max_interval) {
					current = next + o.max_interval;
				}

			}

			return this.convertToPercent(current);
		},

		checkDiapason: function (p_num, min, max) {
			var num = this.convertToValue(p_num),
				o = this.options;

			if (typeof min !== "number") {
				min = o.min;
			}

			if (typeof max !== "number") {
				max = o.max;
			}

			if (num < min) {
				num = min;
			}

			if (num > max) {
				num = max;
			}

			return this.convertToPercent(num);
		},

		toFixed: function (num) {
			num = num.toFixed(20);
			return +num;
		},

		_prettify: function (num) {
			if (!this.options.prettify_enabled) {
				return num;
			}

			if (this.options.prettify && typeof this.options.prettify === "function") {
				return this.options.prettify(num);
			} else {
				return this.prettify(num);
			}
		},

		prettify: function (num) {
			var n = num.toString();
			return n.replace(/(\d{1,3}(?=(?:\d\d\d)+(?!\d)))/g, "$1" + this.options.prettify_separator);
		},

		checkEdges: function (left, width) {
			if (!this.options.force_edges) {
				return this.toFixed(left);
			}

			if (left < 0) {
				left = 0;
			} else if (left > 100 - width) {
				left = 100 - width;
			}

			return this.toFixed(left);
		},

		validate: function () {
			var o = this.options,
				r = this.result,
				v = o.values,
				vl = v.length,
				value,
				i;

			if (typeof o.min === "string") o.min = +o.min;
			if (typeof o.max === "string") o.max = +o.max;
			if (typeof o.from === "string") o.from = +o.from;
			if (typeof o.to === "string") o.to = +o.to;
			if (typeof o.step === "string") o.step = +o.step;

			if (typeof o.from_min === "string") o.from_min = +o.from_min;
			if (typeof o.from_max === "string") o.from_max = +o.from_max;
			if (typeof o.to_min === "string") o.to_min = +o.to_min;
			if (typeof o.to_max === "string") o.to_max = +o.to_max;

			if (typeof o.grid_num === "string") o.grid_num = +o.grid_num;

			if (o.max < o.min) {
				o.max = o.min;
			}

			if (vl) {
				o.p_values = [];
				o.min = 0;
				o.max = vl - 1;
				o.step = 1;
				o.grid_num = o.max;
				o.grid_snap = true;

				for (i = 0; i < vl; i++) {
					value = +v[i];

					if (!isNaN(value)) {
						v[i] = value;
						value = this._prettify(value);
					} else {
						value = v[i];
					}

					o.p_values.push(value);
				}
			}

			if (typeof o.from !== "number" || isNaN(o.from)) {
				o.from = o.min;
			}

			if (typeof o.to !== "number" || isNaN(o.to)) {
				o.to = o.max;
			}

			if (o.type === "single") {

				if (o.from < o.min) o.from = o.min;
				if (o.from > o.max) o.from = o.max;

			} else {

				if (o.from < o.min) o.from = o.min;
				if (o.from > o.max) o.from = o.max;

				if (o.to < o.min) o.to = o.min;
				if (o.to > o.max) o.to = o.max;

				if (this.update_check.from) {

					if (this.update_check.from !== o.from) {
						if (o.from > o.to) o.from = o.to;
					}
					if (this.update_check.to !== o.to) {
						if (o.to < o.from) o.to = o.from;
					}

				}

				if (o.from > o.to) o.from = o.to;
				if (o.to < o.from) o.to = o.from;

			}

			if (typeof o.step !== "number" || isNaN(o.step) || !o.step || o.step < 0) {
				o.step = 1;
			}

			if (typeof o.from_min === "number" && o.from < o.from_min) {
				o.from = o.from_min;
			}

			if (typeof o.from_max === "number" && o.from > o.from_max) {
				o.from = o.from_max;
			}

			if (typeof o.to_min === "number" && o.to < o.to_min) {
				o.to = o.to_min;
			}

			if (typeof o.to_max === "number" && o.from > o.to_max) {
				o.to = o.to_max;
			}

			if (r) {
				if (r.min !== o.min) {
					r.min = o.min;
				}

				if (r.max !== o.max) {
					r.max = o.max;
				}

				if (r.from < r.min || r.from > r.max) {
					r.from = o.from;
				}

				if (r.to < r.min || r.to > r.max) {
					r.to = o.to;
				}
			}

			if (typeof o.min_interval !== "number" || isNaN(o.min_interval) || !o.min_interval || o.min_interval < 0) {
				o.min_interval = 0;
			}

			if (typeof o.max_interval !== "number" || isNaN(o.max_interval) || !o.max_interval || o.max_interval < 0) {
				o.max_interval = 0;
			}

			if (o.min_interval && o.min_interval > o.max - o.min) {
				o.min_interval = o.max - o.min;
			}

			if (o.max_interval && o.max_interval > o.max - o.min) {
				o.max_interval = o.max - o.min;
			}
		},

		decorate: function (num, original) {
			var decorated = "",
				o = this.options;

			if (o.prefix) {
				decorated += o.prefix;
			}

			decorated += num;

			if (o.max_postfix) {
				if (o.values.length && num === o.p_values[o.max]) {
					decorated += o.max_postfix;
					if (o.postfix) {
						decorated += " ";
					}
				} else if (original === o.max) {
					decorated += o.max_postfix;
					if (o.postfix) {
						decorated += " ";
					}
				}
			}

			if (o.postfix) {
				decorated += o.postfix;
			}

			return decorated;
		},

		updateFrom: function () {
			this.result.from = this.options.from;
			this.result.from_percent = this.convertToPercent(this.result.from);
			this.result.from_pretty = this._prettify(this.result.from);
			if (this.options.values) {
				this.result.from_value = this.options.values[this.result.from];
			}
		},

		updateTo: function () {
			this.result.to = this.options.to;
			this.result.to_percent = this.convertToPercent(this.result.to);
			this.result.to_pretty = this._prettify(this.result.to);
			if (this.options.values) {
				this.result.to_value = this.options.values[this.result.to];
			}
		},

		updateResult: function () {
			this.result.min = this.options.min;
			this.result.max = this.options.max;
			this.updateFrom();
			this.updateTo();
		},


		// =============================================================================================================
		// Grid

		appendGrid: function () {
			if (!this.options.grid) {
				return;
			}

			var o = this.options,
				i, z,

				total = o.max - o.min,
				big_num = o.grid_num,
				big_p = 0,
				big_w = 0,

				small_max = 4,
				local_small_max,
				small_p,
				small_w = 0,

				result,
				html = '';



			this.calcGridMargin();

			if (o.grid_snap) {
				big_num = total / o.step;
			}

			if (big_num > 50) big_num = 50;
			big_p = this.toFixed(100 / big_num);

			if (big_num > 4) {
				small_max = 3;
			}
			if (big_num > 7) {
				small_max = 2;
			}
			if (big_num > 14) {
				small_max = 1;
			}
			if (big_num > 28) {
				small_max = 0;
			}

			for (i = 0; i < big_num + 1; i++) {
				local_small_max = small_max;

				big_w = this.toFixed(big_p * i);

				if (big_w > 100) {
					big_w = 100;
				}
				this.coords.big[i] = big_w;

				small_p = (big_w - (big_p * (i - 1))) / (local_small_max + 1);

				for (z = 1; z <= local_small_max; z++) {
					if (big_w === 0) {
						break;
					}

					small_w = this.toFixed(big_w - (small_p * z));

					html += '<span class="irs-grid-pol small" style="left: ' + small_w + '%"></span>';
				}

				html += '<span class="irs-grid-pol" style="left: ' + big_w + '%"></span>';

				result = this.convertToValue(big_w);
				if (o.values.length) {
					result = o.p_values[result];
				} else {
					result = this._prettify(result);
				}

				html += '<span class="irs-grid-text js-grid-text-' + i + '" style="left: ' + big_w + '%">' + result + '</span>';
			}
			this.coords.big_num = Math.ceil(big_num + 1);



			this.$cache.cont.addClass("irs-with-grid");
			this.$cache.grid.html(html);
			this.cacheGridLabels();
		},

		cacheGridLabels: function () {
			var $label, i,
				num = this.coords.big_num;

			for (i = 0; i < num; i++) {
				$label = this.$cache.grid.find(".js-grid-text-" + i);
				this.$cache.grid_labels.push($label);
			}

			this.calcGridLabels();
		},

		calcGridLabels: function () {
			var i, label, start = [], finish = [],
				num = this.coords.big_num;

			for (i = 0; i < num; i++) {
				this.coords.big_w[i] = this.$cache.grid_labels[i].outerWidth(false);
				this.coords.big_p[i] = this.toFixed(this.coords.big_w[i] / this.coords.w_rs * 100);
				this.coords.big_x[i] = this.toFixed(this.coords.big_p[i] / 2);

				start[i] = this.toFixed(this.coords.big[i] - this.coords.big_x[i]);
				finish[i] = this.toFixed(start[i] + this.coords.big_p[i]);
			}

			if (this.options.force_edges) {
				if (start[0] < -this.coords.grid_gap) {
					start[0] = -this.coords.grid_gap;
					finish[0] = this.toFixed(start[0] + this.coords.big_p[0]);

					this.coords.big_x[0] = this.coords.grid_gap;
				}

				if (finish[num - 1] > 100 + this.coords.grid_gap) {
					finish[num - 1] = 100 + this.coords.grid_gap;
					start[num - 1] = this.toFixed(finish[num - 1] - this.coords.big_p[num - 1]);

					this.coords.big_x[num - 1] = this.toFixed(this.coords.big_p[num - 1] - this.coords.grid_gap);
				}
			}

			this.calcGridCollision(2, start, finish);
			this.calcGridCollision(4, start, finish);

			for (i = 0; i < num; i++) {
				label = this.$cache.grid_labels[i][0];

				if (this.coords.big_x[i] !== Number.POSITIVE_INFINITY) {
					label.style.marginLeft = -this.coords.big_x[i] + "%";
				}
			}
		},

		// Collisions Calc Beta
		// TODO: Refactor then have plenty of time
		calcGridCollision: function (step, start, finish) {
			var i, next_i, label,
				num = this.coords.big_num;

			for (i = 0; i < num; i += step) {
				next_i = i + (step / 2);
				if (next_i >= num) {
					break;
				}

				label = this.$cache.grid_labels[next_i][0];

				if (finish[i] <= start[next_i]) {
					label.style.visibility = "visible";
				} else {
					label.style.visibility = "hidden";
				}
			}
		},

		calcGridMargin: function () {
			if (!this.options.grid_margin) {
				return;
			}

			this.coords.w_rs = this.$cache.rs.outerWidth(false);
			if (!this.coords.w_rs) {
				return;
			}

			if (this.options.type === "single") {
				this.coords.w_handle = this.$cache.s_single.outerWidth(false);
			} else {
				this.coords.w_handle = this.$cache.s_from.outerWidth(false);
			}
			this.coords.p_handle = this.toFixed(this.coords.w_handle  / this.coords.w_rs * 100);
			this.coords.grid_gap = this.toFixed((this.coords.p_handle / 2) - 0.1);

			this.$cache.grid[0].style.width = this.toFixed(100 - this.coords.p_handle) + "%";
			this.$cache.grid[0].style.left = this.coords.grid_gap + "%";
		},



		// =============================================================================================================
		// Public methods

		update: function (options) {
			if (!this.input) {
				return;
			}

			this.is_update = true;

			this.options.from = this.result.from;
			this.options.to = this.result.to;
			this.update_check.from = this.result.from;
			this.update_check.to = this.result.to;

			this.options = $.extend(this.options, options);
			this.validate();
			this.updateResult(options);

			this.toggleInput();
			this.remove();
			this.init(true);
		},

		reset: function () {
			if (!this.input) {
				return;
			}

			this.updateResult();
			this.update();
		},

		destroy: function () {
			if (!this.input) {
				return;
			}

			this.toggleInput();
			this.$cache.input.prop("readonly", false);
			$.data(this.input, "ionRangeSlider", null);

			this.remove();
			this.input = null;
			this.options = null;
		}
	};

	$.fn.ionRangeSlider = function (options) {
		return this.each(function() {
			if (!$.data(this, "ionRangeSlider")) {
				$.data(this, "ionRangeSlider", new IonRangeSlider(this, options, plugin_count++));
			}
		});
	};



	// =================================================================================================================
	// http://paulirish.com/2011/requestanimationframe-for-smart-animating/
	// http://my.opera.com/emoller/blog/2011/12/20/requestanimationframe-for-smart-er-animating

	// requestAnimationFrame polyfill by Erik Möller. fixes from Paul Irish and Tino Zijdel

	// MIT license

	(function() {
		var lastTime = 0;
		var vendors = ['ms', 'moz', 'webkit', 'o'];
		for(var x = 0; x < vendors.length && !window.requestAnimationFrame; ++x) {
			window.requestAnimationFrame = window[vendors[x]+'RequestAnimationFrame'];
			window.cancelAnimationFrame = window[vendors[x]+'CancelAnimationFrame']
				|| window[vendors[x]+'CancelRequestAnimationFrame'];
		}

		if (!window.requestAnimationFrame)
			window.requestAnimationFrame = function(callback, element) {
				var currTime = new Date().getTime();
				var timeToCall = Math.max(0, 16 - (currTime - lastTime));
				var id = window.setTimeout(function() { callback(currTime + timeToCall); },
					timeToCall);
				lastTime = currTime + timeToCall;
				return id;
			};

		if (!window.cancelAnimationFrame)
			window.cancelAnimationFrame = function(id) {
				clearTimeout(id);
			};
	}());

}));


/**
 * Swiper 5.3.6
 * Most modern mobile touch slider and framework with hardware accelerated transitions
 * http://swiperjs.com
 *
 * Copyright 2014-2020 Vladimir Kharlampidi
 *
 * Released under the MIT License
 *
 * Released on: February 29, 2020
 */

(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
	typeof define === 'function' && define.amd ? define(factory) :
	(global = global || self, global.Swiper = factory());
}(this, function () { 'use strict';

	/**
	 * SSR Window 1.0.1
	 * Better handling for window object in SSR environment
	 * https://github.com/nolimits4web/ssr-window
	 *
	 * Copyright 2018, Vladimir Kharlampidi
	 *
	 * Licensed under MIT
	 *
	 * Released on: July 18, 2018
	 */
	var doc = (typeof document === 'undefined') ? {
		body: {},
		addEventListener: function addEventListener() {},
		removeEventListener: function removeEventListener() {},
		activeElement: {
			blur: function blur() {},
			nodeName: '',
		},
		querySelector: function querySelector() {
			return null;
		},
		querySelectorAll: function querySelectorAll() {
			return [];
		},
		getElementById: function getElementById() {
			return null;
		},
		createEvent: function createEvent() {
			return {
				initEvent: function initEvent() {},
			};
		},
		createElement: function createElement() {
			return {
				children: [],
				childNodes: [],
				style: {},
				setAttribute: function setAttribute() {},
				getElementsByTagName: function getElementsByTagName() {
					return [];
				},
			};
		},
		location: { hash: '' },
	} : document; // eslint-disable-line

	var win = (typeof window === 'undefined') ? {
		document: doc,
		navigator: {
			userAgent: '',
		},
		location: {},
		history: {},
		CustomEvent: function CustomEvent() {
			return this;
		},
		addEventListener: function addEventListener() {},
		removeEventListener: function removeEventListener() {},
		getComputedStyle: function getComputedStyle() {
			return {
				getPropertyValue: function getPropertyValue() {
					return '';
				},
			};
		},
		Image: function Image() {},
		Date: function Date() {},
		screen: {},
		setTimeout: function setTimeout() {},
		clearTimeout: function clearTimeout() {},
	} : window; // eslint-disable-line

	/**
	 * Dom7 2.1.3
	 * Minimalistic JavaScript library for DOM manipulation, with a jQuery-compatible API
	 * http://framework7.io/docs/dom.html
	 *
	 * Copyright 2019, Vladimir Kharlampidi
	 * The iDangero.us
	 * http://www.idangero.us/
	 *
	 * Licensed under MIT
	 *
	 * Released on: February 11, 2019
	 */

	var Dom7 = function Dom7(arr) {
		var self = this;
		// Create array-like object
		for (var i = 0; i < arr.length; i += 1) {
			self[i] = arr[i];
		}
		self.length = arr.length;
		// Return collection with methods
		return this;
	};

	function $(selector, context) {
		var arr = [];
		var i = 0;
		if (selector && !context) {
			if (selector instanceof Dom7) {
				return selector;
			}
		}
		if (selector) {
				// String
			if (typeof selector === 'string') {
				var els;
				var tempParent;
				var html = selector.trim();
				if (html.indexOf('<') >= 0 && html.indexOf('>') >= 0) {
					var toCreate = 'div';
					if (html.indexOf('<li') === 0) { toCreate = 'ul'; }
					if (html.indexOf('<tr') === 0) { toCreate = 'tbody'; }
					if (html.indexOf('<td') === 0 || html.indexOf('<th') === 0) { toCreate = 'tr'; }
					if (html.indexOf('<tbody') === 0) { toCreate = 'table'; }
					if (html.indexOf('<option') === 0) { toCreate = 'select'; }
					tempParent = doc.createElement(toCreate);
					tempParent.innerHTML = html;
					for (i = 0; i < tempParent.childNodes.length; i += 1) {
						arr.push(tempParent.childNodes[i]);
					}
				} else {
					if (!context && selector[0] === '#' && !selector.match(/[ .<>:~]/)) {
						// Pure ID selector
						els = [doc.getElementById(selector.trim().split('#')[1])];
					} else {
						// Other selectors
						els = (context || doc).querySelectorAll(selector.trim());
					}
					for (i = 0; i < els.length; i += 1) {
						if (els[i]) { arr.push(els[i]); }
					}
				}
			} else if (selector.nodeType || selector === win || selector === doc) {
				// Node/element
				arr.push(selector);
			} else if (selector.length > 0 && selector[0].nodeType) {
				// Array of elements or instance of Dom
				for (i = 0; i < selector.length; i += 1) {
					arr.push(selector[i]);
				}
			}
		}
		return new Dom7(arr);
	}

	$.fn = Dom7.prototype;
	$.Class = Dom7;
	$.Dom7 = Dom7;

	function unique(arr) {
		var uniqueArray = [];
		for (var i = 0; i < arr.length; i += 1) {
			if (uniqueArray.indexOf(arr[i]) === -1) { uniqueArray.push(arr[i]); }
		}
		return uniqueArray;
	}

	// Classes and attributes
	function addClass(className) {
		if (typeof className === 'undefined') {
			return this;
		}
		var classes = className.split(' ');
		for (var i = 0; i < classes.length; i += 1) {
			for (var j = 0; j < this.length; j += 1) {
				if (typeof this[j] !== 'undefined' && typeof this[j].classList !== 'undefined') { this[j].classList.add(classes[i]); }
			}
		}
		return this;
	}
	function removeClass(className) {
		var classes = className.split(' ');
		for (var i = 0; i < classes.length; i += 1) {
			for (var j = 0; j < this.length; j += 1) {
				if (typeof this[j] !== 'undefined' && typeof this[j].classList !== 'undefined') { this[j].classList.remove(classes[i]); }
			}
		}
		return this;
	}
	function hasClass(className) {
		if (!this[0]) { return false; }
		return this[0].classList.contains(className);
	}
	function toggleClass(className) {
		var classes = className.split(' ');
		for (var i = 0; i < classes.length; i += 1) {
			for (var j = 0; j < this.length; j += 1) {
				if (typeof this[j] !== 'undefined' && typeof this[j].classList !== 'undefined') { this[j].classList.toggle(classes[i]); }
			}
		}
		return this;
	}
	function attr(attrs, value) {
		var arguments$1 = arguments;

		if (arguments.length === 1 && typeof attrs === 'string') {
			// Get attr
			if (this[0]) { return this[0].getAttribute(attrs); }
			return undefined;
		}

		// Set attrs
		for (var i = 0; i < this.length; i += 1) {
			if (arguments$1.length === 2) {
				// String
				this[i].setAttribute(attrs, value);
			} else {
				// Object
				// eslint-disable-next-line
				for (var attrName in attrs) {
					this[i][attrName] = attrs[attrName];
					this[i].setAttribute(attrName, attrs[attrName]);
				}
			}
		}
		return this;
	}
	// eslint-disable-next-line
	function removeAttr(attr) {
		for (var i = 0; i < this.length; i += 1) {
			this[i].removeAttribute(attr);
		}
		return this;
	}
	function data(key, value) {
		var el;
		if (typeof value === 'undefined') {
			el = this[0];
			// Get value
			if (el) {
				if (el.dom7ElementDataStorage && (key in el.dom7ElementDataStorage)) {
					return el.dom7ElementDataStorage[key];
				}

				var dataKey = el.getAttribute(("data-" + key));
				if (dataKey) {
					return dataKey;
				}
				return undefined;
			}
			return undefined;
		}

		// Set value
		for (var i = 0; i < this.length; i += 1) {
			el = this[i];
			if (!el.dom7ElementDataStorage) { el.dom7ElementDataStorage = {}; }
			el.dom7ElementDataStorage[key] = value;
		}
		return this;
	}
	// Transforms
	// eslint-disable-next-line
	function transform(transform) {
		for (var i = 0; i < this.length; i += 1) {
			var elStyle = this[i].style;
			elStyle.webkitTransform = transform;
			elStyle.transform = transform;
		}
		return this;
	}
	function transition(duration) {
		if (typeof duration !== 'string') {
			duration = duration + "ms"; // eslint-disable-line
		}
		for (var i = 0; i < this.length; i += 1) {
			var elStyle = this[i].style;
			elStyle.webkitTransitionDuration = duration;
			elStyle.transitionDuration = duration;
		}
		return this;
	}
	// Events
	function on() {
		var assign;

		var args = [], len = arguments.length;
		while ( len-- ) args[ len ] = arguments[ len ];
		var eventType = args[0];
		var targetSelector = args[1];
		var listener = args[2];
		var capture = args[3];
		if (typeof args[1] === 'function') {
			(assign = args, eventType = assign[0], listener = assign[1], capture = assign[2]);
			targetSelector = undefined;
		}
		if (!capture) { capture = false; }

		function handleLiveEvent(e) {
			var target = e.target;
			if (!target) { return; }
			var eventData = e.target.dom7EventData || [];
			if (eventData.indexOf(e) < 0) {
				eventData.unshift(e);
			}
			if ($(target).is(targetSelector)) { listener.apply(target, eventData); }
			else {
				var parents = $(target).parents(); // eslint-disable-line
				for (var k = 0; k < parents.length; k += 1) {
					if ($(parents[k]).is(targetSelector)) { listener.apply(parents[k], eventData); }
				}
			}
		}
		function handleEvent(e) {
			var eventData = e && e.target ? e.target.dom7EventData || [] : [];
			if (eventData.indexOf(e) < 0) {
				eventData.unshift(e);
			}
			listener.apply(this, eventData);
		}
		var events = eventType.split(' ');
		var j;
		for (var i = 0; i < this.length; i += 1) {
			var el = this[i];
			if (!targetSelector) {
				for (j = 0; j < events.length; j += 1) {
					var event = events[j];
					if (!el.dom7Listeners) { el.dom7Listeners = {}; }
					if (!el.dom7Listeners[event]) { el.dom7Listeners[event] = []; }
					el.dom7Listeners[event].push({
						listener: listener,
						proxyListener: handleEvent,
					});
					el.addEventListener(event, handleEvent, capture);
				}
			} else {
				// Live events
				for (j = 0; j < events.length; j += 1) {
					var event$1 = events[j];
					if (!el.dom7LiveListeners) { el.dom7LiveListeners = {}; }
					if (!el.dom7LiveListeners[event$1]) { el.dom7LiveListeners[event$1] = []; }
					el.dom7LiveListeners[event$1].push({
						listener: listener,
						proxyListener: handleLiveEvent,
					});
					el.addEventListener(event$1, handleLiveEvent, capture);
				}
			}
		}
		return this;
	}
	function off() {
		var assign;

		var args = [], len = arguments.length;
		while ( len-- ) args[ len ] = arguments[ len ];
		var eventType = args[0];
		var targetSelector = args[1];
		var listener = args[2];
		var capture = args[3];
		if (typeof args[1] === 'function') {
			(assign = args, eventType = assign[0], listener = assign[1], capture = assign[2]);
			targetSelector = undefined;
		}
		if (!capture) { capture = false; }

		var events = eventType.split(' ');
		for (var i = 0; i < events.length; i += 1) {
			var event = events[i];
			for (var j = 0; j < this.length; j += 1) {
				var el = this[j];
				var handlers = (void 0);
				if (!targetSelector && el.dom7Listeners) {
					handlers = el.dom7Listeners[event];
				} else if (targetSelector && el.dom7LiveListeners) {
					handlers = el.dom7LiveListeners[event];
				}
				if (handlers && handlers.length) {
					for (var k = handlers.length - 1; k >= 0; k -= 1) {
						var handler = handlers[k];
						if (listener && handler.listener === listener) {
							el.removeEventListener(event, handler.proxyListener, capture);
							handlers.splice(k, 1);
						} else if (listener && handler.listener && handler.listener.dom7proxy && handler.listener.dom7proxy === listener) {
							el.removeEventListener(event, handler.proxyListener, capture);
							handlers.splice(k, 1);
						} else if (!listener) {
							el.removeEventListener(event, handler.proxyListener, capture);
							handlers.splice(k, 1);
						}
					}
				}
			}
		}
		return this;
	}
	function trigger() {
		var args = [], len = arguments.length;
		while ( len-- ) args[ len ] = arguments[ len ];

		var events = args[0].split(' ');
		var eventData = args[1];
		for (var i = 0; i < events.length; i += 1) {
			var event = events[i];
			for (var j = 0; j < this.length; j += 1) {
				var el = this[j];
				var evt = (void 0);
				try {
					evt = new win.CustomEvent(event, {
						detail: eventData,
						bubbles: true,
						cancelable: true,
					});
				} catch (e) {
					evt = doc.createEvent('Event');
					evt.initEvent(event, true, true);
					evt.detail = eventData;
				}
				// eslint-disable-next-line
				el.dom7EventData = args.filter(function (data, dataIndex) { return dataIndex > 0; });
				el.dispatchEvent(evt);
				el.dom7EventData = [];
				delete el.dom7EventData;
			}
		}
		return this;
	}
	function transitionEnd(callback) {
		var events = ['webkitTransitionEnd', 'transitionend'];
		var dom = this;
		var i;
		function fireCallBack(e) {
			/* jshint validthis:true */
			if (e.target !== this) { return; }
			callback.call(this, e);
			for (i = 0; i < events.length; i += 1) {
				dom.off(events[i], fireCallBack);
			}
		}
		if (callback) {
			for (i = 0; i < events.length; i += 1) {
				dom.on(events[i], fireCallBack);
			}
		}
		return this;
	}
	function outerWidth(includeMargins) {
		if (this.length > 0) {
			if (includeMargins) {
				// eslint-disable-next-line
				var styles = this.styles();
				return this[0].offsetWidth + parseFloat(styles.getPropertyValue('margin-right')) + parseFloat(styles.getPropertyValue('margin-left'));
			}
			return this[0].offsetWidth;
		}
		return null;
	}
	function outerHeight(includeMargins) {
		if (this.length > 0) {
			if (includeMargins) {
				// eslint-disable-next-line
				var styles = this.styles();
				return this[0].offsetHeight + parseFloat(styles.getPropertyValue('margin-top')) + parseFloat(styles.getPropertyValue('margin-bottom'));
			}
			return this[0].offsetHeight;
		}
		return null;
	}
	function offset() {
		if (this.length > 0) {
			var el = this[0];
			var box = el.getBoundingClientRect();
			var body = doc.body;
			var clientTop = el.clientTop || body.clientTop || 0;
			var clientLeft = el.clientLeft || body.clientLeft || 0;
			var scrollTop = el === win ? win.scrollY : el.scrollTop;
			var scrollLeft = el === win ? win.scrollX : el.scrollLeft;
			return {
				top: (box.top + scrollTop) - clientTop,
				left: (box.left + scrollLeft) - clientLeft,
			};
		}

		return null;
	}
	function styles() {
		if (this[0]) { return win.getComputedStyle(this[0], null); }
		return {};
	}
	function css(props, value) {
		var i;
		if (arguments.length === 1) {
			if (typeof props === 'string') {
				if (this[0]) { return win.getComputedStyle(this[0], null).getPropertyValue(props); }
			} else {
				for (i = 0; i < this.length; i += 1) {
					// eslint-disable-next-line
					for (var prop in props) {
						this[i].style[prop] = props[prop];
					}
				}
				return this;
			}
		}
		if (arguments.length === 2 && typeof props === 'string') {
			for (i = 0; i < this.length; i += 1) {
				this[i].style[props] = value;
			}
			return this;
		}
		return this;
	}
	// Iterate over the collection passing elements to `callback`
	function each(callback) {
		// Don't bother continuing without a callback
		if (!callback) { return this; }
		// Iterate over the current collection
		for (var i = 0; i < this.length; i += 1) {
			// If the callback returns false
			if (callback.call(this[i], i, this[i]) === false) {
				// End the loop early
				return this;
			}
		}
		// Return `this` to allow chained DOM operations
		return this;
	}
	function filter(callback) {
		var matchedItems = [];
		var dom = this;
		for (var i = 0; i < dom.length; i += 1) {
			if (callback.call(dom[i], i, dom[i])) { matchedItems.push(dom[i]); }
		}
		return new Dom7(matchedItems);
	}
	// eslint-disable-next-line
	function html(html) {
		if (typeof html === 'undefined') {
			return this[0] ? this[0].innerHTML : undefined;
		}

		for (var i = 0; i < this.length; i += 1) {
			this[i].innerHTML = html;
		}
		return this;
	}
	// eslint-disable-next-line
	function text(text) {
		if (typeof text === 'undefined') {
			if (this[0]) {
				return this[0].textContent.trim();
			}
			return null;
		}

		for (var i = 0; i < this.length; i += 1) {
			this[i].textContent = text;
		}
		return this;
	}
	function is(selector) {
		var el = this[0];
		var compareWith;
		var i;
		if (!el || typeof selector === 'undefined') { return false; }
		if (typeof selector === 'string') {
			if (el.matches) { return el.matches(selector); }
			else if (el.webkitMatchesSelector) { return el.webkitMatchesSelector(selector); }
			else if (el.msMatchesSelector) { return el.msMatchesSelector(selector); }

			compareWith = $(selector);
			for (i = 0; i < compareWith.length; i += 1) {
				if (compareWith[i] === el) { return true; }
			}
			return false;
		} else if (selector === doc) { return el === doc; }
		else if (selector === win) { return el === win; }

		if (selector.nodeType || selector instanceof Dom7) {
			compareWith = selector.nodeType ? [selector] : selector;
			for (i = 0; i < compareWith.length; i += 1) {
				if (compareWith[i] === el) { return true; }
			}
			return false;
		}
		return false;
	}
	function index() {
		var child = this[0];
		var i;
		if (child) {
			i = 0;
			// eslint-disable-next-line
			while ((child = child.previousSibling) !== null) {
				if (child.nodeType === 1) { i += 1; }
			}
			return i;
		}
		return undefined;
	}
	// eslint-disable-next-line
	function eq(index) {
		if (typeof index === 'undefined') { return this; }
		var length = this.length;
		var returnIndex;
		if (index > length - 1) {
			return new Dom7([]);
		}
		if (index < 0) {
			returnIndex = length + index;
			if (returnIndex < 0) { return new Dom7([]); }
			return new Dom7([this[returnIndex]]);
		}
		return new Dom7([this[index]]);
	}
	function append() {
		var args = [], len = arguments.length;
		while ( len-- ) args[ len ] = arguments[ len ];

		var newChild;

		for (var k = 0; k < args.length; k += 1) {
			newChild = args[k];
			for (var i = 0; i < this.length; i += 1) {
				if (typeof newChild === 'string') {
					var tempDiv = doc.createElement('div');
					tempDiv.innerHTML = newChild;
					while (tempDiv.firstChild) {
						this[i].appendChild(tempDiv.firstChild);
					}
				} else if (newChild instanceof Dom7) {
					for (var j = 0; j < newChild.length; j += 1) {
						this[i].appendChild(newChild[j]);
					}
				} else {
					this[i].appendChild(newChild);
				}
			}
		}

		return this;
	}
	function prepend(newChild) {
		var i;
		var j;
		for (i = 0; i < this.length; i += 1) {
			if (typeof newChild === 'string') {
				var tempDiv = doc.createElement('div');
				tempDiv.innerHTML = newChild;
				for (j = tempDiv.childNodes.length - 1; j >= 0; j -= 1) {
					this[i].insertBefore(tempDiv.childNodes[j], this[i].childNodes[0]);
				}
			} else if (newChild instanceof Dom7) {
				for (j = 0; j < newChild.length; j += 1) {
					this[i].insertBefore(newChild[j], this[i].childNodes[0]);
				}
			} else {
				this[i].insertBefore(newChild, this[i].childNodes[0]);
			}
		}
		return this;
	}
	function next(selector) {
		if (this.length > 0) {
			if (selector) {
				if (this[0].nextElementSibling && $(this[0].nextElementSibling).is(selector)) {
					return new Dom7([this[0].nextElementSibling]);
				}
				return new Dom7([]);
			}

			if (this[0].nextElementSibling) { return new Dom7([this[0].nextElementSibling]); }
			return new Dom7([]);
		}
		return new Dom7([]);
	}
	function nextAll(selector) {
		var nextEls = [];
		var el = this[0];
		if (!el) { return new Dom7([]); }
		while (el.nextElementSibling) {
			var next = el.nextElementSibling; // eslint-disable-line
			if (selector) {
				if ($(next).is(selector)) { nextEls.push(next); }
			} else { nextEls.push(next); }
			el = next;
		}
		return new Dom7(nextEls);
	}
	function prev(selector) {
		if (this.length > 0) {
			var el = this[0];
			if (selector) {
				if (el.previousElementSibling && $(el.previousElementSibling).is(selector)) {
					return new Dom7([el.previousElementSibling]);
				}
				return new Dom7([]);
			}

			if (el.previousElementSibling) { return new Dom7([el.previousElementSibling]); }
			return new Dom7([]);
		}
		return new Dom7([]);
	}
	function prevAll(selector) {
		var prevEls = [];
		var el = this[0];
		if (!el) { return new Dom7([]); }
		while (el.previousElementSibling) {
			var prev = el.previousElementSibling; // eslint-disable-line
			if (selector) {
				if ($(prev).is(selector)) { prevEls.push(prev); }
			} else { prevEls.push(prev); }
			el = prev;
		}
		return new Dom7(prevEls);
	}
	function parent(selector) {
		var parents = []; // eslint-disable-line
		for (var i = 0; i < this.length; i += 1) {
			if (this[i].parentNode !== null) {
				if (selector) {
					if ($(this[i].parentNode).is(selector)) { parents.push(this[i].parentNode); }
				} else {
					parents.push(this[i].parentNode);
				}
			}
		}
		return $(unique(parents));
	}
	function parents(selector) {
		var parents = []; // eslint-disable-line
		for (var i = 0; i < this.length; i += 1) {
			var parent = this[i].parentNode; // eslint-disable-line
			while (parent) {
				if (selector) {
					if ($(parent).is(selector)) { parents.push(parent); }
				} else {
					parents.push(parent);
				}
				parent = parent.parentNode;
			}
		}
		return $(unique(parents));
	}
	function closest(selector) {
		var closest = this; // eslint-disable-line
		if (typeof selector === 'undefined') {
			return new Dom7([]);
		}
		if (!closest.is(selector)) {
			closest = closest.parents(selector).eq(0);
		}
		return closest;
	}
	function find(selector) {
		var foundElements = [];
		for (var i = 0; i < this.length; i += 1) {
			var found = this[i].querySelectorAll(selector);
			for (var j = 0; j < found.length; j += 1) {
				foundElements.push(found[j]);
			}
		}
		return new Dom7(foundElements);
	}
	function children(selector) {
		var children = []; // eslint-disable-line
		for (var i = 0; i < this.length; i += 1) {
			var childNodes = this[i].childNodes;

			for (var j = 0; j < childNodes.length; j += 1) {
				if (!selector) {
					if (childNodes[j].nodeType === 1) { children.push(childNodes[j]); }
				} else if (childNodes[j].nodeType === 1 && $(childNodes[j]).is(selector)) {
					children.push(childNodes[j]);
				}
			}
		}
		return new Dom7(unique(children));
	}
	function remove() {
		for (var i = 0; i < this.length; i += 1) {
			if (this[i].parentNode) { this[i].parentNode.removeChild(this[i]); }
		}
		return this;
	}
	function add() {
		var args = [], len = arguments.length;
		while ( len-- ) args[ len ] = arguments[ len ];

		var dom = this;
		var i;
		var j;
		for (i = 0; i < args.length; i += 1) {
			var toAdd = $(args[i]);
			for (j = 0; j < toAdd.length; j += 1) {
				dom[dom.length] = toAdd[j];
				dom.length += 1;
			}
		}
		return dom;
	}

	var Methods = {
		addClass: addClass,
		removeClass: removeClass,
		hasClass: hasClass,
		toggleClass: toggleClass,
		attr: attr,
		removeAttr: removeAttr,
		data: data,
		transform: transform,
		transition: transition,
		on: on,
		off: off,
		trigger: trigger,
		transitionEnd: transitionEnd,
		outerWidth: outerWidth,
		outerHeight: outerHeight,
		offset: offset,
		css: css,
		each: each,
		html: html,
		text: text,
		is: is,
		index: index,
		eq: eq,
		append: append,
		prepend: prepend,
		next: next,
		nextAll: nextAll,
		prev: prev,
		prevAll: prevAll,
		parent: parent,
		parents: parents,
		closest: closest,
		find: find,
		children: children,
		filter: filter,
		remove: remove,
		add: add,
		styles: styles,
	};

	Object.keys(Methods).forEach(function (methodName) {
		$.fn[methodName] = $.fn[methodName] || Methods[methodName];
	});

	var Utils = {
		deleteProps: function deleteProps(obj) {
			var object = obj;
			Object.keys(object).forEach(function (key) {
				try {
					object[key] = null;
				} catch (e) {
					// no getter for object
				}
				try {
					delete object[key];
				} catch (e) {
					// something got wrong
				}
			});
		},
		nextTick: function nextTick(callback, delay) {
			if ( delay === void 0 ) delay = 0;

			return setTimeout(callback, delay);
		},
		now: function now() {
			return Date.now();
		},
		getTranslate: function getTranslate(el, axis) {
			if ( axis === void 0 ) axis = 'x';

			var matrix;
			var curTransform;
			var transformMatrix;

			var curStyle = win.getComputedStyle(el, null);

			if (win.WebKitCSSMatrix) {
				curTransform = curStyle.transform || curStyle.webkitTransform;
				if (curTransform.split(',').length > 6) {
					curTransform = curTransform.split(', ').map(function (a) { return a.replace(',', '.'); }).join(', ');
				}
				// Some old versions of Webkit choke when 'none' is passed; pass
				// empty string instead in this case
				transformMatrix = new win.WebKitCSSMatrix(curTransform === 'none' ? '' : curTransform);
			} else {
				transformMatrix = curStyle.MozTransform || curStyle.OTransform || curStyle.MsTransform || curStyle.msTransform || curStyle.transform || curStyle.getPropertyValue('transform').replace('translate(', 'matrix(1, 0, 0, 1,');
				matrix = transformMatrix.toString().split(',');
			}

			if (axis === 'x') {
				// Latest Chrome and webkits Fix
				if (win.WebKitCSSMatrix) { curTransform = transformMatrix.m41; }
				// Crazy IE10 Matrix
				else if (matrix.length === 16) { curTransform = parseFloat(matrix[12]); }
				// Normal Browsers
				else { curTransform = parseFloat(matrix[4]); }
			}
			if (axis === 'y') {
				// Latest Chrome and webkits Fix
				if (win.WebKitCSSMatrix) { curTransform = transformMatrix.m42; }
				// Crazy IE10 Matrix
				else if (matrix.length === 16) { curTransform = parseFloat(matrix[13]); }
				// Normal Browsers
				else { curTransform = parseFloat(matrix[5]); }
			}
			return curTransform || 0;
		},
		parseUrlQuery: function parseUrlQuery(url) {
			var query = {};
			var urlToParse = url || win.location.href;
			var i;
			var params;
			var param;
			var length;
			if (typeof urlToParse === 'string' && urlToParse.length) {
				urlToParse = urlToParse.indexOf('?') > -1 ? urlToParse.replace(/\S*\?/, '') : '';
				params = urlToParse.split('&').filter(function (paramsPart) { return paramsPart !== ''; });
				length = params.length;

				for (i = 0; i < length; i += 1) {
					param = params[i].replace(/#\S+/g, '').split('=');
					query[decodeURIComponent(param[0])] = typeof param[1] === 'undefined' ? undefined : decodeURIComponent(param[1]) || '';
				}
			}
			return query;
		},
		isObject: function isObject(o) {
			return typeof o === 'object' && o !== null && o.constructor && o.constructor === Object;
		},
		extend: function extend() {
			var args = [], len$1 = arguments.length;
			while ( len$1-- ) args[ len$1 ] = arguments[ len$1 ];

			var to = Object(args[0]);
			for (var i = 1; i < args.length; i += 1) {
				var nextSource = args[i];
				if (nextSource !== undefined && nextSource !== null) {
					var keysArray = Object.keys(Object(nextSource));
					for (var nextIndex = 0, len = keysArray.length; nextIndex < len; nextIndex += 1) {
						var nextKey = keysArray[nextIndex];
						var desc = Object.getOwnPropertyDescriptor(nextSource, nextKey);
						if (desc !== undefined && desc.enumerable) {
							if (Utils.isObject(to[nextKey]) && Utils.isObject(nextSource[nextKey])) {
								Utils.extend(to[nextKey], nextSource[nextKey]);
							} else if (!Utils.isObject(to[nextKey]) && Utils.isObject(nextSource[nextKey])) {
								to[nextKey] = {};
								Utils.extend(to[nextKey], nextSource[nextKey]);
							} else {
								to[nextKey] = nextSource[nextKey];
							}
						}
					}
				}
			}
			return to;
		},
	};

	var Support = (function Support() {
		return {
			touch: (win.Modernizr && win.Modernizr.touch === true) || (function checkTouch() {
				return !!((win.navigator.maxTouchPoints > 0) || ('ontouchstart' in win) || (win.DocumentTouch && doc instanceof win.DocumentTouch));
			}()),

			pointerEvents: !!win.PointerEvent && ('maxTouchPoints' in win.navigator) && win.navigator.maxTouchPoints > 0,

			observer: (function checkObserver() {
				return ('MutationObserver' in win || 'WebkitMutationObserver' in win);
			}()),

			passiveListener: (function checkPassiveListener() {
				var supportsPassive = false;
				try {
					var opts = Object.defineProperty({}, 'passive', {
						// eslint-disable-next-line
						get: function get() {
							supportsPassive = true;
						},
					});
					win.addEventListener('testPassiveListener', null, opts);
				} catch (e) {
					// No support
				}
				return supportsPassive;
			}()),

			gestures: (function checkGestures() {
				return 'ongesturestart' in win;
			}()),
		};
	}());

	var SwiperClass = function SwiperClass(params) {
		if ( params === void 0 ) params = {};

		var self = this;
		self.params = params;

		// Events
		self.eventsListeners = {};

		if (self.params && self.params.on) {
			Object.keys(self.params.on).forEach(function (eventName) {
				self.on(eventName, self.params.on[eventName]);
			});
		}
	};

	var staticAccessors = { components: { configurable: true } };

	SwiperClass.prototype.on = function on (events, handler, priority) {
		var self = this;
		if (typeof handler !== 'function') { return self; }
		var method = priority ? 'unshift' : 'push';
		events.split(' ').forEach(function (event) {
			if (!self.eventsListeners[event]) { self.eventsListeners[event] = []; }
			self.eventsListeners[event][method](handler);
		});
		return self;
	};

	SwiperClass.prototype.once = function once (events, handler, priority) {
		var self = this;
		if (typeof handler !== 'function') { return self; }
		function onceHandler() {
				var args = [], len = arguments.length;
				while ( len-- ) args[ len ] = arguments[ len ];

			self.off(events, onceHandler);
			if (onceHandler.f7proxy) {
				delete onceHandler.f7proxy;
			}
			handler.apply(self, args);
		}
		onceHandler.f7proxy = handler;
		return self.on(events, onceHandler, priority);
	};

	SwiperClass.prototype.off = function off (events, handler) {
		var self = this;
		if (!self.eventsListeners) { return self; }
		events.split(' ').forEach(function (event) {
			if (typeof handler === 'undefined') {
				self.eventsListeners[event] = [];
			} else if (self.eventsListeners[event] && self.eventsListeners[event].length) {
				self.eventsListeners[event].forEach(function (eventHandler, index) {
					if (eventHandler === handler || (eventHandler.f7proxy && eventHandler.f7proxy === handler)) {
						self.eventsListeners[event].splice(index, 1);
					}
				});
			}
		});
		return self;
	};

	SwiperClass.prototype.emit = function emit () {
			var args = [], len = arguments.length;
			while ( len-- ) args[ len ] = arguments[ len ];

		var self = this;
		if (!self.eventsListeners) { return self; }
		var events;
		var data;
		var context;
		if (typeof args[0] === 'string' || Array.isArray(args[0])) {
			events = args[0];
			data = args.slice(1, args.length);
			context = self;
		} else {
			events = args[0].events;
			data = args[0].data;
			context = args[0].context || self;
		}
		var eventsArray = Array.isArray(events) ? events : events.split(' ');
		eventsArray.forEach(function (event) {
			if (self.eventsListeners && self.eventsListeners[event]) {
				var handlers = [];
				self.eventsListeners[event].forEach(function (eventHandler) {
					handlers.push(eventHandler);
				});
				handlers.forEach(function (eventHandler) {
					eventHandler.apply(context, data);
				});
			}
		});
		return self;
	};

	SwiperClass.prototype.useModulesParams = function useModulesParams (instanceParams) {
		var instance = this;
		if (!instance.modules) { return; }
		Object.keys(instance.modules).forEach(function (moduleName) {
			var module = instance.modules[moduleName];
			// Extend params
			if (module.params) {
				Utils.extend(instanceParams, module.params);
			}
		});
	};

	SwiperClass.prototype.useModules = function useModules (modulesParams) {
			if ( modulesParams === void 0 ) modulesParams = {};

		var instance = this;
		if (!instance.modules) { return; }
		Object.keys(instance.modules).forEach(function (moduleName) {
			var module = instance.modules[moduleName];
			var moduleParams = modulesParams[moduleName] || {};
			// Extend instance methods and props
			if (module.instance) {
				Object.keys(module.instance).forEach(function (modulePropName) {
					var moduleProp = module.instance[modulePropName];
					if (typeof moduleProp === 'function') {
						instance[modulePropName] = moduleProp.bind(instance);
					} else {
						instance[modulePropName] = moduleProp;
					}
				});
			}
			// Add event listeners
			if (module.on && instance.on) {
				Object.keys(module.on).forEach(function (moduleEventName) {
					instance.on(moduleEventName, module.on[moduleEventName]);
				});
			}

			// Module create callback
			if (module.create) {
				module.create.bind(instance)(moduleParams);
			}
		});
	};

	staticAccessors.components.set = function (components) {
		var Class = this;
		if (!Class.use) { return; }
		Class.use(components);
	};

	SwiperClass.installModule = function installModule (module) {
			var params = [], len = arguments.length - 1;
			while ( len-- > 0 ) params[ len ] = arguments[ len + 1 ];

		var Class = this;
		if (!Class.prototype.modules) { Class.prototype.modules = {}; }
		var name = module.name || (((Object.keys(Class.prototype.modules).length) + "_" + (Utils.now())));
		Class.prototype.modules[name] = module;
		// Prototype
		if (module.proto) {
			Object.keys(module.proto).forEach(function (key) {
				Class.prototype[key] = module.proto[key];
			});
		}
		// Class
		if (module.static) {
			Object.keys(module.static).forEach(function (key) {
				Class[key] = module.static[key];
			});
		}
		// Callback
		if (module.install) {
			module.install.apply(Class, params);
		}
		return Class;
	};

	SwiperClass.use = function use (module) {
			var params = [], len = arguments.length - 1;
			while ( len-- > 0 ) params[ len ] = arguments[ len + 1 ];

		var Class = this;
		if (Array.isArray(module)) {
			module.forEach(function (m) { return Class.installModule(m); });
			return Class;
		}
		return Class.installModule.apply(Class, [ module ].concat( params ));
	};

	Object.defineProperties( SwiperClass, staticAccessors );

	function updateSize () {
		var swiper = this;
		var width;
		var height;
		var $el = swiper.$el;
		if (typeof swiper.params.width !== 'undefined') {
			width = swiper.params.width;
		} else {
			width = $el[0].clientWidth;
		}
		if (typeof swiper.params.height !== 'undefined') {
			height = swiper.params.height;
		} else {
			height = $el[0].clientHeight;
		}
		if ((width === 0 && swiper.isHorizontal()) || (height === 0 && swiper.isVertical())) {
			return;
		}

		// Subtract paddings
		width = width - parseInt($el.css('padding-left'), 10) - parseInt($el.css('padding-right'), 10);
		height = height - parseInt($el.css('padding-top'), 10) - parseInt($el.css('padding-bottom'), 10);

		Utils.extend(swiper, {
			width: width,
			height: height,
			size: swiper.isHorizontal() ? width : height,
		});
	}

	function updateSlides () {
		var swiper = this;
		var params = swiper.params;

		var $wrapperEl = swiper.$wrapperEl;
		var swiperSize = swiper.size;
		var rtl = swiper.rtlTranslate;
		var wrongRTL = swiper.wrongRTL;
		var isVirtual = swiper.virtual && params.virtual.enabled;
		var previousSlidesLength = isVirtual ? swiper.virtual.slides.length : swiper.slides.length;
		var slides = $wrapperEl.children(("." + (swiper.params.slideClass)));
		var slidesLength = isVirtual ? swiper.virtual.slides.length : slides.length;
		var snapGrid = [];
		var slidesGrid = [];
		var slidesSizesGrid = [];

		function slidesForMargin(slideIndex) {
			if (!params.cssMode) { return true; }
			if (slideIndex === slides.length - 1) {
				return false;
			}
			return true;
		}

		var offsetBefore = params.slidesOffsetBefore;
		if (typeof offsetBefore === 'function') {
			offsetBefore = params.slidesOffsetBefore.call(swiper);
		}

		var offsetAfter = params.slidesOffsetAfter;
		if (typeof offsetAfter === 'function') {
			offsetAfter = params.slidesOffsetAfter.call(swiper);
		}

		var previousSnapGridLength = swiper.snapGrid.length;
		var previousSlidesGridLength = swiper.snapGrid.length;

		var spaceBetween = params.spaceBetween;
		var slidePosition = -offsetBefore;
		var prevSlideSize = 0;
		var index = 0;
		if (typeof swiperSize === 'undefined') {
			return;
		}
		if (typeof spaceBetween === 'string' && spaceBetween.indexOf('%') >= 0) {
			spaceBetween = (parseFloat(spaceBetween.replace('%', '')) / 100) * swiperSize;
		}

		swiper.virtualSize = -spaceBetween;

		// reset margins
		if (rtl) { slides.css({ marginLeft: '', marginTop: '' }); }
		else { slides.css({ marginRight: '', marginBottom: '' }); }

		var slidesNumberEvenToRows;
		if (params.slidesPerColumn > 1) {
			if (Math.floor(slidesLength / params.slidesPerColumn) === slidesLength / swiper.params.slidesPerColumn) {
				slidesNumberEvenToRows = slidesLength;
			} else {
				slidesNumberEvenToRows = Math.ceil(slidesLength / params.slidesPerColumn) * params.slidesPerColumn;
			}
			if (params.slidesPerView !== 'auto' && params.slidesPerColumnFill === 'row') {
				slidesNumberEvenToRows = Math.max(slidesNumberEvenToRows, params.slidesPerView * params.slidesPerColumn);
			}
		}

		// Calc slides
		var slideSize;
		var slidesPerColumn = params.slidesPerColumn;
		var slidesPerRow = slidesNumberEvenToRows / slidesPerColumn;
		var numFullColumns = Math.floor(slidesLength / params.slidesPerColumn);
		for (var i = 0; i < slidesLength; i += 1) {
			slideSize = 0;
			var slide = slides.eq(i);
			if (params.slidesPerColumn > 1) {
				// Set slides order
				var newSlideOrderIndex = (void 0);
				var column = (void 0);
				var row = (void 0);
				if (params.slidesPerColumnFill === 'row' && params.slidesPerGroup > 1) {
					var groupIndex = Math.floor(i / (params.slidesPerGroup * params.slidesPerColumn));
					var slideIndexInGroup = i - params.slidesPerColumn * params.slidesPerGroup * groupIndex;
					var columnsInGroup = groupIndex === 0
						? params.slidesPerGroup
						: Math.min(Math.ceil((slidesLength - groupIndex * slidesPerColumn * params.slidesPerGroup) / slidesPerColumn), params.slidesPerGroup);
					row = Math.floor(slideIndexInGroup / columnsInGroup);
					column = (slideIndexInGroup - row * columnsInGroup) + groupIndex * params.slidesPerGroup;

					newSlideOrderIndex = column + ((row * slidesNumberEvenToRows) / slidesPerColumn);
					slide
						.css({
							'-webkit-box-ordinal-group': newSlideOrderIndex,
							'-moz-box-ordinal-group': newSlideOrderIndex,
							'-ms-flex-order': newSlideOrderIndex,
							'-webkit-order': newSlideOrderIndex,
							order: newSlideOrderIndex,
						});
				} else if (params.slidesPerColumnFill === 'column') {
					column = Math.floor(i / slidesPerColumn);
					row = i - (column * slidesPerColumn);
					if (column > numFullColumns || (column === numFullColumns && row === slidesPerColumn - 1)) {
						row += 1;
						if (row >= slidesPerColumn) {
							row = 0;
							column += 1;
						}
					}
				} else {
					row = Math.floor(i / slidesPerRow);
					column = i - (row * slidesPerRow);
				}
				slide.css(
					("margin-" + (swiper.isHorizontal() ? 'top' : 'left')),
					(row !== 0 && params.spaceBetween) && (((params.spaceBetween) + "px"))
				);
			}
			if (slide.css('display') === 'none') { continue; } // eslint-disable-line

			if (params.slidesPerView === 'auto') {
				var slideStyles = win.getComputedStyle(slide[0], null);
				var currentTransform = slide[0].style.transform;
				var currentWebKitTransform = slide[0].style.webkitTransform;
				if (currentTransform) {
					slide[0].style.transform = 'none';
				}
				if (currentWebKitTransform) {
					slide[0].style.webkitTransform = 'none';
				}
				if (params.roundLengths) {
					slideSize = swiper.isHorizontal()
						? slide.outerWidth(true)
						: slide.outerHeight(true);
				} else {
					// eslint-disable-next-line
					if (swiper.isHorizontal()) {
						var width = parseFloat(slideStyles.getPropertyValue('width'));
						var paddingLeft = parseFloat(slideStyles.getPropertyValue('padding-left'));
						var paddingRight = parseFloat(slideStyles.getPropertyValue('padding-right'));
						var marginLeft = parseFloat(slideStyles.getPropertyValue('margin-left'));
						var marginRight = parseFloat(slideStyles.getPropertyValue('margin-right'));
						var boxSizing = slideStyles.getPropertyValue('box-sizing');
						if (boxSizing && boxSizing === 'border-box') {
							slideSize = width + marginLeft + marginRight;
						} else {
							slideSize = width + paddingLeft + paddingRight + marginLeft + marginRight;
						}
					} else {
						var height = parseFloat(slideStyles.getPropertyValue('height'));
						var paddingTop = parseFloat(slideStyles.getPropertyValue('padding-top'));
						var paddingBottom = parseFloat(slideStyles.getPropertyValue('padding-bottom'));
						var marginTop = parseFloat(slideStyles.getPropertyValue('margin-top'));
						var marginBottom = parseFloat(slideStyles.getPropertyValue('margin-bottom'));
						var boxSizing$1 = slideStyles.getPropertyValue('box-sizing');
						if (boxSizing$1 && boxSizing$1 === 'border-box') {
							slideSize = height + marginTop + marginBottom;
						} else {
							slideSize = height + paddingTop + paddingBottom + marginTop + marginBottom;
						}
					}
				}
				if (currentTransform) {
					slide[0].style.transform = currentTransform;
				}
				if (currentWebKitTransform) {
					slide[0].style.webkitTransform = currentWebKitTransform;
				}
				if (params.roundLengths) { slideSize = Math.floor(slideSize); }
			} else {
				slideSize = (swiperSize - ((params.slidesPerView - 1) * spaceBetween)) / params.slidesPerView;
				if (params.roundLengths) { slideSize = Math.floor(slideSize); }

				if (slides[i]) {
					if (swiper.isHorizontal()) {
						slides[i].style.width = slideSize + "px";
					} else {
						slides[i].style.height = slideSize + "px";
					}
				}
			}
			if (slides[i]) {
				slides[i].swiperSlideSize = slideSize;
			}
			slidesSizesGrid.push(slideSize);


			if (params.centeredSlides) {
				slidePosition = slidePosition + (slideSize / 2) + (prevSlideSize / 2) + spaceBetween;
				if (prevSlideSize === 0 && i !== 0) { slidePosition = slidePosition - (swiperSize / 2) - spaceBetween; }
				if (i === 0) { slidePosition = slidePosition - (swiperSize / 2) - spaceBetween; }
				if (Math.abs(slidePosition) < 1 / 1000) { slidePosition = 0; }
				if (params.roundLengths) { slidePosition = Math.floor(slidePosition); }
				if ((index) % params.slidesPerGroup === 0) { snapGrid.push(slidePosition); }
				slidesGrid.push(slidePosition);
			} else {
				if (params.roundLengths) { slidePosition = Math.floor(slidePosition); }
				if ((index - Math.min(swiper.params.slidesPerGroupSkip, index)) % swiper.params.slidesPerGroup === 0) { snapGrid.push(slidePosition); }
				slidesGrid.push(slidePosition);
				slidePosition = slidePosition + slideSize + spaceBetween;
			}

			swiper.virtualSize += slideSize + spaceBetween;

			prevSlideSize = slideSize;

			index += 1;
		}
		swiper.virtualSize = Math.max(swiper.virtualSize, swiperSize) + offsetAfter;
		var newSlidesGrid;

		if (
			rtl && wrongRTL && (params.effect === 'slide' || params.effect === 'coverflow')) {
			$wrapperEl.css({ width: ((swiper.virtualSize + params.spaceBetween) + "px") });
		}
		if (params.setWrapperSize) {
			if (swiper.isHorizontal()) { $wrapperEl.css({ width: ((swiper.virtualSize + params.spaceBetween) + "px") }); }
			else { $wrapperEl.css({ height: ((swiper.virtualSize + params.spaceBetween) + "px") }); }
		}

		if (params.slidesPerColumn > 1) {
			swiper.virtualSize = (slideSize + params.spaceBetween) * slidesNumberEvenToRows;
			swiper.virtualSize = Math.ceil(swiper.virtualSize / params.slidesPerColumn) - params.spaceBetween;
			if (swiper.isHorizontal()) { $wrapperEl.css({ width: ((swiper.virtualSize + params.spaceBetween) + "px") }); }
			else { $wrapperEl.css({ height: ((swiper.virtualSize + params.spaceBetween) + "px") }); }
			if (params.centeredSlides) {
				newSlidesGrid = [];
				for (var i$1 = 0; i$1 < snapGrid.length; i$1 += 1) {
					var slidesGridItem = snapGrid[i$1];
					if (params.roundLengths) { slidesGridItem = Math.floor(slidesGridItem); }
					if (snapGrid[i$1] < swiper.virtualSize + snapGrid[0]) { newSlidesGrid.push(slidesGridItem); }
				}
				snapGrid = newSlidesGrid;
			}
		}

		// Remove last grid elements depending on width
		if (!params.centeredSlides) {
			newSlidesGrid = [];
			for (var i$2 = 0; i$2 < snapGrid.length; i$2 += 1) {
				var slidesGridItem$1 = snapGrid[i$2];
				if (params.roundLengths) { slidesGridItem$1 = Math.floor(slidesGridItem$1); }
				if (snapGrid[i$2] <= swiper.virtualSize - swiperSize) {
					newSlidesGrid.push(slidesGridItem$1);
				}
			}
			snapGrid = newSlidesGrid;
			if (Math.floor(swiper.virtualSize - swiperSize) - Math.floor(snapGrid[snapGrid.length - 1]) > 1) {
				snapGrid.push(swiper.virtualSize - swiperSize);
			}
		}
		if (snapGrid.length === 0) { snapGrid = [0]; }

		if (params.spaceBetween !== 0) {
			if (swiper.isHorizontal()) {
				if (rtl) { slides.filter(slidesForMargin).css({ marginLeft: (spaceBetween + "px") }); }
				else { slides.filter(slidesForMargin).css({ marginRight: (spaceBetween + "px") }); }
			} else { slides.filter(slidesForMargin).css({ marginBottom: (spaceBetween + "px") }); }
		}

		if (params.centeredSlides && params.centeredSlidesBounds) {
			var allSlidesSize = 0;
			slidesSizesGrid.forEach(function (slideSizeValue) {
				allSlidesSize += slideSizeValue + (params.spaceBetween ? params.spaceBetween : 0);
			});
			allSlidesSize -= params.spaceBetween;
			var maxSnap = allSlidesSize - swiperSize;
			snapGrid = snapGrid.map(function (snap) {
				if (snap < 0) { return -offsetBefore; }
				if (snap > maxSnap) { return maxSnap + offsetAfter; }
				return snap;
			});
		}

		if (params.centerInsufficientSlides) {
			var allSlidesSize$1 = 0;
			slidesSizesGrid.forEach(function (slideSizeValue) {
				allSlidesSize$1 += slideSizeValue + (params.spaceBetween ? params.spaceBetween : 0);
			});
			allSlidesSize$1 -= params.spaceBetween;
			if (allSlidesSize$1 < swiperSize) {
				var allSlidesOffset = (swiperSize - allSlidesSize$1) / 2;
				snapGrid.forEach(function (snap, snapIndex) {
					snapGrid[snapIndex] = snap - allSlidesOffset;
				});
				slidesGrid.forEach(function (snap, snapIndex) {
					slidesGrid[snapIndex] = snap + allSlidesOffset;
				});
			}
		}

		Utils.extend(swiper, {
			slides: slides,
			snapGrid: snapGrid,
			slidesGrid: slidesGrid,
			slidesSizesGrid: slidesSizesGrid,
		});

		if (slidesLength !== previousSlidesLength) {
			swiper.emit('slidesLengthChange');
		}
		if (snapGrid.length !== previousSnapGridLength) {
			if (swiper.params.watchOverflow) { swiper.checkOverflow(); }
			swiper.emit('snapGridLengthChange');
		}
		if (slidesGrid.length !== previousSlidesGridLength) {
			swiper.emit('slidesGridLengthChange');
		}

		if (params.watchSlidesProgress || params.watchSlidesVisibility) {
			swiper.updateSlidesOffset();
		}
	}

	function updateAutoHeight (speed) {
		var swiper = this;
		var activeSlides = [];
		var newHeight = 0;
		var i;
		if (typeof speed === 'number') {
			swiper.setTransition(speed);
		} else if (speed === true) {
			swiper.setTransition(swiper.params.speed);
		}
		// Find slides currently in view
		if (swiper.params.slidesPerView !== 'auto' && swiper.params.slidesPerView > 1) {
			if (swiper.params.centeredSlides) { activeSlides.push.apply(activeSlides, swiper.visibleSlides); }
			else {
				for (i = 0; i < Math.ceil(swiper.params.slidesPerView); i += 1) {
					var index = swiper.activeIndex + i;
					if (index > swiper.slides.length) { break; }
					activeSlides.push(swiper.slides.eq(index)[0]);
				}
			}
		} else {
			activeSlides.push(swiper.slides.eq(swiper.activeIndex)[0]);
		}

		// Find new height from highest slide in view
		for (i = 0; i < activeSlides.length; i += 1) {
			if (typeof activeSlides[i] !== 'undefined') {
				var height = activeSlides[i].offsetHeight;
				newHeight = height > newHeight ? height : newHeight;
			}
		}

		// Update Height
		if (newHeight) { swiper.$wrapperEl.css('height', (newHeight + "px")); }
	}

	function updateSlidesOffset () {
		var swiper = this;
		var slides = swiper.slides;
		for (var i = 0; i < slides.length; i += 1) {
			slides[i].swiperSlideOffset = swiper.isHorizontal() ? slides[i].offsetLeft : slides[i].offsetTop;
		}
	}

	function updateSlidesProgress (translate) {
		if ( translate === void 0 ) translate = (this && this.translate) || 0;

		var swiper = this;
		var params = swiper.params;

		var slides = swiper.slides;
		var rtl = swiper.rtlTranslate;

		if (slides.length === 0) { return; }
		if (typeof slides[0].swiperSlideOffset === 'undefined') { swiper.updateSlidesOffset(); }

		var offsetCenter = -translate;
		if (rtl) { offsetCenter = translate; }

		// Visible Slides
		slides.removeClass(params.slideVisibleClass);

		swiper.visibleSlidesIndexes = [];
		swiper.visibleSlides = [];

		for (var i = 0; i < slides.length; i += 1) {
			var slide = slides[i];
			var slideProgress = (
				(offsetCenter + (params.centeredSlides ? swiper.minTranslate() : 0)) - slide.swiperSlideOffset
			) / (slide.swiperSlideSize + params.spaceBetween);
			if (params.watchSlidesVisibility || (params.centeredSlides && params.autoHeight)) {
				var slideBefore = -(offsetCenter - slide.swiperSlideOffset);
				var slideAfter = slideBefore + swiper.slidesSizesGrid[i];
				var isVisible = (slideBefore >= 0 && slideBefore < swiper.size - 1)
									|| (slideAfter > 1 && slideAfter <= swiper.size)
									|| (slideBefore <= 0 && slideAfter >= swiper.size);
				if (isVisible) {
					swiper.visibleSlides.push(slide);
					swiper.visibleSlidesIndexes.push(i);
					slides.eq(i).addClass(params.slideVisibleClass);
				}
			}
			slide.progress = rtl ? -slideProgress : slideProgress;
		}
		swiper.visibleSlides = $(swiper.visibleSlides);
	}

	function updateProgress (translate) {
		var swiper = this;
		if (typeof translate === 'undefined') {
			var multiplier = swiper.rtlTranslate ? -1 : 1;
			// eslint-disable-next-line
			translate = (swiper && swiper.translate && (swiper.translate * multiplier)) || 0;
		}
		var params = swiper.params;
		var translatesDiff = swiper.maxTranslate() - swiper.minTranslate();
		var progress = swiper.progress;
		var isBeginning = swiper.isBeginning;
		var isEnd = swiper.isEnd;
		var wasBeginning = isBeginning;
		var wasEnd = isEnd;
		if (translatesDiff === 0) {
			progress = 0;
			isBeginning = true;
			isEnd = true;
		} else {
			progress = (translate - swiper.minTranslate()) / (translatesDiff);
			isBeginning = progress <= 0;
			isEnd = progress >= 1;
		}
		Utils.extend(swiper, {
			progress: progress,
			isBeginning: isBeginning,
			isEnd: isEnd,
		});

		if (params.watchSlidesProgress || params.watchSlidesVisibility || (params.centeredSlides && params.autoHeight)) { swiper.updateSlidesProgress(translate); }

		if (isBeginning && !wasBeginning) {
			swiper.emit('reachBeginning toEdge');
		}
		if (isEnd && !wasEnd) {
			swiper.emit('reachEnd toEdge');
		}
		if ((wasBeginning && !isBeginning) || (wasEnd && !isEnd)) {
			swiper.emit('fromEdge');
		}

		swiper.emit('progress', progress);
	}

	function updateSlidesClasses () {
		var swiper = this;

		var slides = swiper.slides;
		var params = swiper.params;
		var $wrapperEl = swiper.$wrapperEl;
		var activeIndex = swiper.activeIndex;
		var realIndex = swiper.realIndex;
		var isVirtual = swiper.virtual && params.virtual.enabled;

		slides.removeClass(((params.slideActiveClass) + " " + (params.slideNextClass) + " " + (params.slidePrevClass) + " " + (params.slideDuplicateActiveClass) + " " + (params.slideDuplicateNextClass) + " " + (params.slideDuplicatePrevClass)));

		var activeSlide;
		if (isVirtual) {
			activeSlide = swiper.$wrapperEl.find(("." + (params.slideClass) + "[data-swiper-slide-index=\"" + activeIndex + "\"]"));
		} else {
			activeSlide = slides.eq(activeIndex);
		}

		// Active classes
		activeSlide.addClass(params.slideActiveClass);

		if (params.loop) {
			// Duplicate to all looped slides
			if (activeSlide.hasClass(params.slideDuplicateClass)) {
				$wrapperEl
					.children(("." + (params.slideClass) + ":not(." + (params.slideDuplicateClass) + ")[data-swiper-slide-index=\"" + realIndex + "\"]"))
					.addClass(params.slideDuplicateActiveClass);
			} else {
				$wrapperEl
					.children(("." + (params.slideClass) + "." + (params.slideDuplicateClass) + "[data-swiper-slide-index=\"" + realIndex + "\"]"))
					.addClass(params.slideDuplicateActiveClass);
			}
		}
		// Next Slide
		var nextSlide = activeSlide.nextAll(("." + (params.slideClass))).eq(0).addClass(params.slideNextClass);
		if (params.loop && nextSlide.length === 0) {
			nextSlide = slides.eq(0);
			nextSlide.addClass(params.slideNextClass);
		}
		// Prev Slide
		var prevSlide = activeSlide.prevAll(("." + (params.slideClass))).eq(0).addClass(params.slidePrevClass);
		if (params.loop && prevSlide.length === 0) {
			prevSlide = slides.eq(-1);
			prevSlide.addClass(params.slidePrevClass);
		}
		if (params.loop) {
			// Duplicate to all looped slides
			if (nextSlide.hasClass(params.slideDuplicateClass)) {
				$wrapperEl
					.children(("." + (params.slideClass) + ":not(." + (params.slideDuplicateClass) + ")[data-swiper-slide-index=\"" + (nextSlide.attr('data-swiper-slide-index')) + "\"]"))
					.addClass(params.slideDuplicateNextClass);
			} else {
				$wrapperEl
					.children(("." + (params.slideClass) + "." + (params.slideDuplicateClass) + "[data-swiper-slide-index=\"" + (nextSlide.attr('data-swiper-slide-index')) + "\"]"))
					.addClass(params.slideDuplicateNextClass);
			}
			if (prevSlide.hasClass(params.slideDuplicateClass)) {
				$wrapperEl
					.children(("." + (params.slideClass) + ":not(." + (params.slideDuplicateClass) + ")[data-swiper-slide-index=\"" + (prevSlide.attr('data-swiper-slide-index')) + "\"]"))
					.addClass(params.slideDuplicatePrevClass);
			} else {
				$wrapperEl
					.children(("." + (params.slideClass) + "." + (params.slideDuplicateClass) + "[data-swiper-slide-index=\"" + (prevSlide.attr('data-swiper-slide-index')) + "\"]"))
					.addClass(params.slideDuplicatePrevClass);
			}
		}
	}

	function updateActiveIndex (newActiveIndex) {
		var swiper = this;
		var translate = swiper.rtlTranslate ? swiper.translate : -swiper.translate;
		var slidesGrid = swiper.slidesGrid;
		var snapGrid = swiper.snapGrid;
		var params = swiper.params;
		var previousIndex = swiper.activeIndex;
		var previousRealIndex = swiper.realIndex;
		var previousSnapIndex = swiper.snapIndex;
		var activeIndex = newActiveIndex;
		var snapIndex;
		if (typeof activeIndex === 'undefined') {
			for (var i = 0; i < slidesGrid.length; i += 1) {
				if (typeof slidesGrid[i + 1] !== 'undefined') {
					if (translate >= slidesGrid[i] && translate < slidesGrid[i + 1] - ((slidesGrid[i + 1] - slidesGrid[i]) / 2)) {
						activeIndex = i;
					} else if (translate >= slidesGrid[i] && translate < slidesGrid[i + 1]) {
						activeIndex = i + 1;
					}
				} else if (translate >= slidesGrid[i]) {
					activeIndex = i;
				}
			}
			// Normalize slideIndex
			if (params.normalizeSlideIndex) {
				if (activeIndex < 0 || typeof activeIndex === 'undefined') { activeIndex = 0; }
			}
		}
		if (snapGrid.indexOf(translate) >= 0) {
			snapIndex = snapGrid.indexOf(translate);
		} else {
			var skip = Math.min(params.slidesPerGroupSkip, activeIndex);
			snapIndex = skip + Math.floor((activeIndex - skip) / params.slidesPerGroup);
		}
		if (snapIndex >= snapGrid.length) { snapIndex = snapGrid.length - 1; }
		if (activeIndex === previousIndex) {
			if (snapIndex !== previousSnapIndex) {
				swiper.snapIndex = snapIndex;
				swiper.emit('snapIndexChange');
			}
			return;
		}

		// Get real index
		var realIndex = parseInt(swiper.slides.eq(activeIndex).attr('data-swiper-slide-index') || activeIndex, 10);

		Utils.extend(swiper, {
			snapIndex: snapIndex,
			realIndex: realIndex,
			previousIndex: previousIndex,
			activeIndex: activeIndex,
		});
		swiper.emit('activeIndexChange');
		swiper.emit('snapIndexChange');
		if (previousRealIndex !== realIndex) {
			swiper.emit('realIndexChange');
		}
		if (swiper.initialized || swiper.runCallbacksOnInit) {
			swiper.emit('slideChange');
		}
	}

	function updateClickedSlide (e) {
		var swiper = this;
		var params = swiper.params;
		var slide = $(e.target).closest(("." + (params.slideClass)))[0];
		var slideFound = false;
		if (slide) {
			for (var i = 0; i < swiper.slides.length; i += 1) {
				if (swiper.slides[i] === slide) { slideFound = true; }
			}
		}

		if (slide && slideFound) {
			swiper.clickedSlide = slide;
			if (swiper.virtual && swiper.params.virtual.enabled) {
				swiper.clickedIndex = parseInt($(slide).attr('data-swiper-slide-index'), 10);
			} else {
				swiper.clickedIndex = $(slide).index();
			}
		} else {
			swiper.clickedSlide = undefined;
			swiper.clickedIndex = undefined;
			return;
		}
		if (params.slideToClickedSlide && swiper.clickedIndex !== undefined && swiper.clickedIndex !== swiper.activeIndex) {
			swiper.slideToClickedSlide();
		}
	}

	var update = {
		updateSize: updateSize,
		updateSlides: updateSlides,
		updateAutoHeight: updateAutoHeight,
		updateSlidesOffset: updateSlidesOffset,
		updateSlidesProgress: updateSlidesProgress,
		updateProgress: updateProgress,
		updateSlidesClasses: updateSlidesClasses,
		updateActiveIndex: updateActiveIndex,
		updateClickedSlide: updateClickedSlide,
	};

	function getTranslate (axis) {
		if ( axis === void 0 ) axis = this.isHorizontal() ? 'x' : 'y';

		var swiper = this;

		var params = swiper.params;
		var rtl = swiper.rtlTranslate;
		var translate = swiper.translate;
		var $wrapperEl = swiper.$wrapperEl;

		if (params.virtualTranslate) {
			return rtl ? -translate : translate;
		}
		if (params.cssMode) {
			return translate;
		}

		var currentTranslate = Utils.getTranslate($wrapperEl[0], axis);
		if (rtl) { currentTranslate = -currentTranslate; }

		return currentTranslate || 0;
	}

	function setTranslate (translate, byController) {
		var swiper = this;
		var rtl = swiper.rtlTranslate;
		var params = swiper.params;
		var $wrapperEl = swiper.$wrapperEl;
		var wrapperEl = swiper.wrapperEl;
		var progress = swiper.progress;
		var x = 0;
		var y = 0;
		var z = 0;

		if (swiper.isHorizontal()) {
			x = rtl ? -translate : translate;
		} else {
			y = translate;
		}

		if (params.roundLengths) {
			x = Math.floor(x);
			y = Math.floor(y);
		}

		if (params.cssMode) {
			wrapperEl[swiper.isHorizontal() ? 'scrollLeft' : 'scrollTop'] = swiper.isHorizontal() ? -x : -y;
		} else if (!params.virtualTranslate) {
			$wrapperEl.transform(("translate3d(" + x + "px, " + y + "px, " + z + "px)"));
		}
		swiper.previousTranslate = swiper.translate;
		swiper.translate = swiper.isHorizontal() ? x : y;

		// Check if we need to update progress
		var newProgress;
		var translatesDiff = swiper.maxTranslate() - swiper.minTranslate();
		if (translatesDiff === 0) {
			newProgress = 0;
		} else {
			newProgress = (translate - swiper.minTranslate()) / (translatesDiff);
		}
		if (newProgress !== progress) {
			swiper.updateProgress(translate);
		}

		swiper.emit('setTranslate', swiper.translate, byController);
	}

	function minTranslate () {
		return (-this.snapGrid[0]);
	}

	function maxTranslate () {
		return (-this.snapGrid[this.snapGrid.length - 1]);
	}

	function translateTo (translate, speed, runCallbacks, translateBounds, internal) {
		var obj;

		if ( translate === void 0 ) translate = 0;
		if ( speed === void 0 ) speed = this.params.speed;
		if ( runCallbacks === void 0 ) runCallbacks = true;
		if ( translateBounds === void 0 ) translateBounds = true;
		var swiper = this;

		var params = swiper.params;
		var wrapperEl = swiper.wrapperEl;

		if (swiper.animating && params.preventInteractionOnTransition) {
			return false;
		}

		var minTranslate = swiper.minTranslate();
		var maxTranslate = swiper.maxTranslate();
		var newTranslate;
		if (translateBounds && translate > minTranslate) { newTranslate = minTranslate; }
		else if (translateBounds && translate < maxTranslate) { newTranslate = maxTranslate; }
		else { newTranslate = translate; }

		// Update progress
		swiper.updateProgress(newTranslate);

		if (params.cssMode) {
			var isH = swiper.isHorizontal();
			if (speed === 0) {
				wrapperEl[isH ? 'scrollLeft' : 'scrollTop'] = -newTranslate;
			} else {
				// eslint-disable-next-line
				if (wrapperEl.scrollTo) {
					wrapperEl.scrollTo(( obj = {}, obj[isH ? 'left' : 'top'] = -newTranslate, obj.behavior = 'smooth', obj ));
				} else {
					wrapperEl[isH ? 'scrollLeft' : 'scrollTop'] = -newTranslate;
				}
			}
			return true;
		}

		if (speed === 0) {
			swiper.setTransition(0);
			swiper.setTranslate(newTranslate);
			if (runCallbacks) {
				swiper.emit('beforeTransitionStart', speed, internal);
				swiper.emit('transitionEnd');
			}
		} else {
			swiper.setTransition(speed);
			swiper.setTranslate(newTranslate);
			if (runCallbacks) {
				swiper.emit('beforeTransitionStart', speed, internal);
				swiper.emit('transitionStart');
			}
			if (!swiper.animating) {
				swiper.animating = true;
				if (!swiper.onTranslateToWrapperTransitionEnd) {
					swiper.onTranslateToWrapperTransitionEnd = function transitionEnd(e) {
						if (!swiper || swiper.destroyed) { return; }
						if (e.target !== this) { return; }
						swiper.$wrapperEl[0].removeEventListener('transitionend', swiper.onTranslateToWrapperTransitionEnd);
						swiper.$wrapperEl[0].removeEventListener('webkitTransitionEnd', swiper.onTranslateToWrapperTransitionEnd);
						swiper.onTranslateToWrapperTransitionEnd = null;
						delete swiper.onTranslateToWrapperTransitionEnd;
						if (runCallbacks) {
							swiper.emit('transitionEnd');
						}
					};
				}
				swiper.$wrapperEl[0].addEventListener('transitionend', swiper.onTranslateToWrapperTransitionEnd);
				swiper.$wrapperEl[0].addEventListener('webkitTransitionEnd', swiper.onTranslateToWrapperTransitionEnd);
			}
		}

		return true;
	}

	var translate = {
		getTranslate: getTranslate,
		setTranslate: setTranslate,
		minTranslate: minTranslate,
		maxTranslate: maxTranslate,
		translateTo: translateTo,
	};

	function setTransition (duration, byController) {
		var swiper = this;

		if (!swiper.params.cssMode) {
			swiper.$wrapperEl.transition(duration);
		}

		swiper.emit('setTransition', duration, byController);
	}

	function transitionStart (runCallbacks, direction) {
		if ( runCallbacks === void 0 ) runCallbacks = true;

		var swiper = this;
		var activeIndex = swiper.activeIndex;
		var params = swiper.params;
		var previousIndex = swiper.previousIndex;
		if (params.cssMode) { return; }
		if (params.autoHeight) {
			swiper.updateAutoHeight();
		}

		var dir = direction;
		if (!dir) {
			if (activeIndex > previousIndex) { dir = 'next'; }
			else if (activeIndex < previousIndex) { dir = 'prev'; }
			else { dir = 'reset'; }
		}

		swiper.emit('transitionStart');

		if (runCallbacks && activeIndex !== previousIndex) {
			if (dir === 'reset') {
				swiper.emit('slideResetTransitionStart');
				return;
			}
			swiper.emit('slideChangeTransitionStart');
			if (dir === 'next') {
				swiper.emit('slideNextTransitionStart');
			} else {
				swiper.emit('slidePrevTransitionStart');
			}
		}
	}

	function transitionEnd$1 (runCallbacks, direction) {
		if ( runCallbacks === void 0 ) runCallbacks = true;

		var swiper = this;
		var activeIndex = swiper.activeIndex;
		var previousIndex = swiper.previousIndex;
		var params = swiper.params;
		swiper.animating = false;
		if (params.cssMode) { return; }
		swiper.setTransition(0);

		var dir = direction;
		if (!dir) {
			if (activeIndex > previousIndex) { dir = 'next'; }
			else if (activeIndex < previousIndex) { dir = 'prev'; }
			else { dir = 'reset'; }
		}

		swiper.emit('transitionEnd');

		if (runCallbacks && activeIndex !== previousIndex) {
			if (dir === 'reset') {
				swiper.emit('slideResetTransitionEnd');
				return;
			}
			swiper.emit('slideChangeTransitionEnd');
			if (dir === 'next') {
				swiper.emit('slideNextTransitionEnd');
			} else {
				swiper.emit('slidePrevTransitionEnd');
			}
		}
	}

	var transition$1 = {
		setTransition: setTransition,
		transitionStart: transitionStart,
		transitionEnd: transitionEnd$1,
	};

	function slideTo (index, speed, runCallbacks, internal) {
		var obj;

		if ( index === void 0 ) index = 0;
		if ( speed === void 0 ) speed = this.params.speed;
		if ( runCallbacks === void 0 ) runCallbacks = true;
		var swiper = this;
		var slideIndex = index;
		if (slideIndex < 0) { slideIndex = 0; }

		var params = swiper.params;
		var snapGrid = swiper.snapGrid;
		var slidesGrid = swiper.slidesGrid;
		var previousIndex = swiper.previousIndex;
		var activeIndex = swiper.activeIndex;
		var rtl = swiper.rtlTranslate;
		var wrapperEl = swiper.wrapperEl;
		if (swiper.animating && params.preventInteractionOnTransition) {
			return false;
		}

		var skip = Math.min(swiper.params.slidesPerGroupSkip, slideIndex);
		var snapIndex = skip + Math.floor((slideIndex - skip) / swiper.params.slidesPerGroup);
		if (snapIndex >= snapGrid.length) { snapIndex = snapGrid.length - 1; }

		if ((activeIndex || params.initialSlide || 0) === (previousIndex || 0) && runCallbacks) {
			swiper.emit('beforeSlideChangeStart');
		}

		var translate = -snapGrid[snapIndex];

		// Update progress
		swiper.updateProgress(translate);

		// Normalize slideIndex
		if (params.normalizeSlideIndex) {
			for (var i = 0; i < slidesGrid.length; i += 1) {
				if (-Math.floor(translate * 100) >= Math.floor(slidesGrid[i] * 100)) {
					slideIndex = i;
				}
			}
		}
		// Directions locks
		if (swiper.initialized && slideIndex !== activeIndex) {
			if (!swiper.allowSlideNext && translate < swiper.translate && translate < swiper.minTranslate()) {
				return false;
			}
			if (!swiper.allowSlidePrev && translate > swiper.translate && translate > swiper.maxTranslate()) {
				if ((activeIndex || 0) !== slideIndex) { return false; }
			}
		}

		var direction;
		if (slideIndex > activeIndex) { direction = 'next'; }
		else if (slideIndex < activeIndex) { direction = 'prev'; }
		else { direction = 'reset'; }


		// Update Index
		if ((rtl && -translate === swiper.translate) || (!rtl && translate === swiper.translate)) {
			swiper.updateActiveIndex(slideIndex);
			// Update Height
			if (params.autoHeight) {
				swiper.updateAutoHeight();
			}
			swiper.updateSlidesClasses();
			if (params.effect !== 'slide') {
				swiper.setTranslate(translate);
			}
			if (direction !== 'reset') {
				swiper.transitionStart(runCallbacks, direction);
				swiper.transitionEnd(runCallbacks, direction);
			}
			return false;
		}
		if (params.cssMode) {
			var isH = swiper.isHorizontal();
			if (speed === 0) {
				wrapperEl[isH ? 'scrollLeft' : 'scrollTop'] = -translate;
			} else {
				// eslint-disable-next-line
				if (wrapperEl.scrollTo) {
					wrapperEl.scrollTo(( obj = {}, obj[isH ? 'left' : 'top'] = -translate, obj.behavior = 'smooth', obj ));
				} else {
					wrapperEl[isH ? 'scrollLeft' : 'scrollTop'] = -translate;
				}
			}
			return true;
		}

		if (speed === 0) {
			swiper.setTransition(0);
			swiper.setTranslate(translate);
			swiper.updateActiveIndex(slideIndex);
			swiper.updateSlidesClasses();
			swiper.emit('beforeTransitionStart', speed, internal);
			swiper.transitionStart(runCallbacks, direction);
			swiper.transitionEnd(runCallbacks, direction);
		} else {
			swiper.setTransition(speed);
			swiper.setTranslate(translate);
			swiper.updateActiveIndex(slideIndex);
			swiper.updateSlidesClasses();
			swiper.emit('beforeTransitionStart', speed, internal);
			swiper.transitionStart(runCallbacks, direction);
			if (!swiper.animating) {
				swiper.animating = true;
				if (!swiper.onSlideToWrapperTransitionEnd) {
					swiper.onSlideToWrapperTransitionEnd = function transitionEnd(e) {
						if (!swiper || swiper.destroyed) { return; }
						if (e.target !== this) { return; }
						swiper.$wrapperEl[0].removeEventListener('transitionend', swiper.onSlideToWrapperTransitionEnd);
						swiper.$wrapperEl[0].removeEventListener('webkitTransitionEnd', swiper.onSlideToWrapperTransitionEnd);
						swiper.onSlideToWrapperTransitionEnd = null;
						delete swiper.onSlideToWrapperTransitionEnd;
						swiper.transitionEnd(runCallbacks, direction);
					};
				}
				swiper.$wrapperEl[0].addEventListener('transitionend', swiper.onSlideToWrapperTransitionEnd);
				swiper.$wrapperEl[0].addEventListener('webkitTransitionEnd', swiper.onSlideToWrapperTransitionEnd);
			}
		}

		return true;
	}

	function slideToLoop (index, speed, runCallbacks, internal) {
		if ( index === void 0 ) index = 0;
		if ( speed === void 0 ) speed = this.params.speed;
		if ( runCallbacks === void 0 ) runCallbacks = true;

		var swiper = this;
		var newIndex = index;
		if (swiper.params.loop) {
			newIndex += swiper.loopedSlides;
		}

		return swiper.slideTo(newIndex, speed, runCallbacks, internal);
	}

	/* eslint no-unused-vars: "off" */
	function slideNext (speed, runCallbacks, internal) {
		if ( speed === void 0 ) speed = this.params.speed;
		if ( runCallbacks === void 0 ) runCallbacks = true;

		var swiper = this;
		var params = swiper.params;
		var animating = swiper.animating;
		var increment = swiper.activeIndex < params.slidesPerGroupSkip ? 1 : params.slidesPerGroup;
		if (params.loop) {
			if (animating) { return false; }
			swiper.loopFix();
			// eslint-disable-next-line
			swiper._clientLeft = swiper.$wrapperEl[0].clientLeft;
		}
		return swiper.slideTo(swiper.activeIndex + increment, speed, runCallbacks, internal);
	}

	/* eslint no-unused-vars: "off" */
	function slidePrev (speed, runCallbacks, internal) {
		if ( speed === void 0 ) speed = this.params.speed;
		if ( runCallbacks === void 0 ) runCallbacks = true;

		var swiper = this;
		var params = swiper.params;
		var animating = swiper.animating;
		var snapGrid = swiper.snapGrid;
		var slidesGrid = swiper.slidesGrid;
		var rtlTranslate = swiper.rtlTranslate;

		if (params.loop) {
			if (animating) { return false; }
			swiper.loopFix();
			// eslint-disable-next-line
			swiper._clientLeft = swiper.$wrapperEl[0].clientLeft;
		}
		var translate = rtlTranslate ? swiper.translate : -swiper.translate;
		function normalize(val) {
			if (val < 0) { return -Math.floor(Math.abs(val)); }
			return Math.floor(val);
		}
		var normalizedTranslate = normalize(translate);
		var normalizedSnapGrid = snapGrid.map(function (val) { return normalize(val); });
		var normalizedSlidesGrid = slidesGrid.map(function (val) { return normalize(val); });

		var currentSnap = snapGrid[normalizedSnapGrid.indexOf(normalizedTranslate)];
		var prevSnap = snapGrid[normalizedSnapGrid.indexOf(normalizedTranslate) - 1];
		if (typeof prevSnap === 'undefined' && params.cssMode) {
			snapGrid.forEach(function (snap) {
				if (!prevSnap && normalizedTranslate >= snap) { prevSnap = snap; }
			});
		}
		var prevIndex;
		if (typeof prevSnap !== 'undefined') {
			prevIndex = slidesGrid.indexOf(prevSnap);
			if (prevIndex < 0) { prevIndex = swiper.activeIndex - 1; }
		}
		return swiper.slideTo(prevIndex, speed, runCallbacks, internal);
	}

	/* eslint no-unused-vars: "off" */
	function slideReset (speed, runCallbacks, internal) {
		if ( speed === void 0 ) speed = this.params.speed;
		if ( runCallbacks === void 0 ) runCallbacks = true;

		var swiper = this;
		return swiper.slideTo(swiper.activeIndex, speed, runCallbacks, internal);
	}

	/* eslint no-unused-vars: "off" */
	function slideToClosest (speed, runCallbacks, internal, threshold) {
		if ( speed === void 0 ) speed = this.params.speed;
		if ( runCallbacks === void 0 ) runCallbacks = true;
		if ( threshold === void 0 ) threshold = 0.5;

		var swiper = this;
		var index = swiper.activeIndex;
		var skip = Math.min(swiper.params.slidesPerGroupSkip, index);
		var snapIndex = skip + Math.floor((index - skip) / swiper.params.slidesPerGroup);

		var translate = swiper.rtlTranslate ? swiper.translate : -swiper.translate;

		if (translate >= swiper.snapGrid[snapIndex]) {
			// The current translate is on or after the current snap index, so the choice
			// is between the current index and the one after it.
			var currentSnap = swiper.snapGrid[snapIndex];
			var nextSnap = swiper.snapGrid[snapIndex + 1];
			if ((translate - currentSnap) > (nextSnap - currentSnap) * threshold) {
				index += swiper.params.slidesPerGroup;
			}
		} else {
			// The current translate is before the current snap index, so the choice
			// is between the current index and the one before it.
			var prevSnap = swiper.snapGrid[snapIndex - 1];
			var currentSnap$1 = swiper.snapGrid[snapIndex];
			if ((translate - prevSnap) <= (currentSnap$1 - prevSnap) * threshold) {
				index -= swiper.params.slidesPerGroup;
			}
		}
		index = Math.max(index, 0);
		index = Math.min(index, swiper.slidesGrid.length - 1);

		return swiper.slideTo(index, speed, runCallbacks, internal);
	}

	function slideToClickedSlide () {
		var swiper = this;
		var params = swiper.params;
		var $wrapperEl = swiper.$wrapperEl;

		var slidesPerView = params.slidesPerView === 'auto' ? swiper.slidesPerViewDynamic() : params.slidesPerView;
		var slideToIndex = swiper.clickedIndex;
		var realIndex;
		if (params.loop) {
			if (swiper.animating) { return; }
			realIndex = parseInt($(swiper.clickedSlide).attr('data-swiper-slide-index'), 10);
			if (params.centeredSlides) {
				if (
					(slideToIndex < swiper.loopedSlides - (slidesPerView / 2))
					|| (slideToIndex > (swiper.slides.length - swiper.loopedSlides) + (slidesPerView / 2))
				) {
					swiper.loopFix();
					slideToIndex = $wrapperEl
						.children(("." + (params.slideClass) + "[data-swiper-slide-index=\"" + realIndex + "\"]:not(." + (params.slideDuplicateClass) + ")"))
						.eq(0)
						.index();

					Utils.nextTick(function () {
						swiper.slideTo(slideToIndex);
					});
				} else {
					swiper.slideTo(slideToIndex);
				}
			} else if (slideToIndex > swiper.slides.length - slidesPerView) {
				swiper.loopFix();
				slideToIndex = $wrapperEl
					.children(("." + (params.slideClass) + "[data-swiper-slide-index=\"" + realIndex + "\"]:not(." + (params.slideDuplicateClass) + ")"))
					.eq(0)
					.index();

				Utils.nextTick(function () {
					swiper.slideTo(slideToIndex);
				});
			} else {
				swiper.slideTo(slideToIndex);
			}
		} else {
			swiper.slideTo(slideToIndex);
		}
	}

	var slide = {
		slideTo: slideTo,
		slideToLoop: slideToLoop,
		slideNext: slideNext,
		slidePrev: slidePrev,
		slideReset: slideReset,
		slideToClosest: slideToClosest,
		slideToClickedSlide: slideToClickedSlide,
	};

	function loopCreate () {
		var swiper = this;
		var params = swiper.params;
		var $wrapperEl = swiper.$wrapperEl;
		// Remove duplicated slides
		$wrapperEl.children(("." + (params.slideClass) + "." + (params.slideDuplicateClass))).remove();

		var slides = $wrapperEl.children(("." + (params.slideClass)));

		if (params.loopFillGroupWithBlank) {
			var blankSlidesNum = params.slidesPerGroup - (slides.length % params.slidesPerGroup);
			if (blankSlidesNum !== params.slidesPerGroup) {
				for (var i = 0; i < blankSlidesNum; i += 1) {
					var blankNode = $(doc.createElement('div')).addClass(((params.slideClass) + " " + (params.slideBlankClass)));
					$wrapperEl.append(blankNode);
				}
				slides = $wrapperEl.children(("." + (params.slideClass)));
			}
		}

		if (params.slidesPerView === 'auto' && !params.loopedSlides) { params.loopedSlides = slides.length; }

		swiper.loopedSlides = Math.ceil(parseFloat(params.loopedSlides || params.slidesPerView, 10));
		swiper.loopedSlides += params.loopAdditionalSlides;
		if (swiper.loopedSlides > slides.length) {
			swiper.loopedSlides = slides.length;
		}

		var prependSlides = [];
		var appendSlides = [];
		slides.each(function (index, el) {
			var slide = $(el);
			if (index < swiper.loopedSlides) { appendSlides.push(el); }
			if (index < slides.length && index >= slides.length - swiper.loopedSlides) { prependSlides.push(el); }
			slide.attr('data-swiper-slide-index', index);
		});
		for (var i$1 = 0; i$1 < appendSlides.length; i$1 += 1) {
			$wrapperEl.append($(appendSlides[i$1].cloneNode(true)).addClass(params.slideDuplicateClass));
		}
		for (var i$2 = prependSlides.length - 1; i$2 >= 0; i$2 -= 1) {
			$wrapperEl.prepend($(prependSlides[i$2].cloneNode(true)).addClass(params.slideDuplicateClass));
		}
	}

	function loopFix () {
		var swiper = this;

		swiper.emit('beforeLoopFix');

		var activeIndex = swiper.activeIndex;
		var slides = swiper.slides;
		var loopedSlides = swiper.loopedSlides;
		var allowSlidePrev = swiper.allowSlidePrev;
		var allowSlideNext = swiper.allowSlideNext;
		var snapGrid = swiper.snapGrid;
		var rtl = swiper.rtlTranslate;
		var newIndex;
		swiper.allowSlidePrev = true;
		swiper.allowSlideNext = true;

		var snapTranslate = -snapGrid[activeIndex];
		var diff = snapTranslate - swiper.getTranslate();

		// Fix For Negative Oversliding
		if (activeIndex < loopedSlides) {
			newIndex = (slides.length - (loopedSlides * 3)) + activeIndex;
			newIndex += loopedSlides;
			var slideChanged = swiper.slideTo(newIndex, 0, false, true);
			if (slideChanged && diff !== 0) {
				swiper.setTranslate((rtl ? -swiper.translate : swiper.translate) - diff);
			}
		} else if (activeIndex >= slides.length - loopedSlides) {
			// Fix For Positive Oversliding
			newIndex = -slides.length + activeIndex + loopedSlides;
			newIndex += loopedSlides;
			var slideChanged$1 = swiper.slideTo(newIndex, 0, false, true);
			if (slideChanged$1 && diff !== 0) {
				swiper.setTranslate((rtl ? -swiper.translate : swiper.translate) - diff);
			}
		}
		swiper.allowSlidePrev = allowSlidePrev;
		swiper.allowSlideNext = allowSlideNext;

		swiper.emit('loopFix');
	}

	function loopDestroy () {
		var swiper = this;
		var $wrapperEl = swiper.$wrapperEl;
		var params = swiper.params;
		var slides = swiper.slides;
		$wrapperEl.children(("." + (params.slideClass) + "." + (params.slideDuplicateClass) + ",." + (params.slideClass) + "." + (params.slideBlankClass))).remove();
		slides.removeAttr('data-swiper-slide-index');
	}

	var loop = {
		loopCreate: loopCreate,
		loopFix: loopFix,
		loopDestroy: loopDestroy,
	};

	function setGrabCursor (moving) {
		var swiper = this;
		if (Support.touch || !swiper.params.simulateTouch || (swiper.params.watchOverflow && swiper.isLocked) || swiper.params.cssMode) { return; }
		var el = swiper.el;
		el.style.cursor = 'move';
		el.style.cursor = moving ? '-webkit-grabbing' : '-webkit-grab';
		el.style.cursor = moving ? '-moz-grabbin' : '-moz-grab';
		el.style.cursor = moving ? 'grabbing' : 'grab';
	}

	function unsetGrabCursor () {
		var swiper = this;
		if (Support.touch || (swiper.params.watchOverflow && swiper.isLocked) || swiper.params.cssMode) { return; }
		swiper.el.style.cursor = '';
	}

	var grabCursor = {
		setGrabCursor: setGrabCursor,
		unsetGrabCursor: unsetGrabCursor,
	};

	function appendSlide (slides) {
		var swiper = this;
		var $wrapperEl = swiper.$wrapperEl;
		var params = swiper.params;
		if (params.loop) {
			swiper.loopDestroy();
		}
		if (typeof slides === 'object' && 'length' in slides) {
			for (var i = 0; i < slides.length; i += 1) {
				if (slides[i]) { $wrapperEl.append(slides[i]); }
			}
		} else {
			$wrapperEl.append(slides);
		}
		if (params.loop) {
			swiper.loopCreate();
		}
		if (!(params.observer && Support.observer)) {
			swiper.update();
		}
	}

	function prependSlide (slides) {
		var swiper = this;
		var params = swiper.params;
		var $wrapperEl = swiper.$wrapperEl;
		var activeIndex = swiper.activeIndex;

		if (params.loop) {
			swiper.loopDestroy();
		}
		var newActiveIndex = activeIndex + 1;
		if (typeof slides === 'object' && 'length' in slides) {
			for (var i = 0; i < slides.length; i += 1) {
				if (slides[i]) { $wrapperEl.prepend(slides[i]); }
			}
			newActiveIndex = activeIndex + slides.length;
		} else {
			$wrapperEl.prepend(slides);
		}
		if (params.loop) {
			swiper.loopCreate();
		}
		if (!(params.observer && Support.observer)) {
			swiper.update();
		}
		swiper.slideTo(newActiveIndex, 0, false);
	}

	function addSlide (index, slides) {
		var swiper = this;
		var $wrapperEl = swiper.$wrapperEl;
		var params = swiper.params;
		var activeIndex = swiper.activeIndex;
		var activeIndexBuffer = activeIndex;
		if (params.loop) {
			activeIndexBuffer -= swiper.loopedSlides;
			swiper.loopDestroy();
			swiper.slides = $wrapperEl.children(("." + (params.slideClass)));
		}
		var baseLength = swiper.slides.length;
		if (index <= 0) {
			swiper.prependSlide(slides);
			return;
		}
		if (index >= baseLength) {
			swiper.appendSlide(slides);
			return;
		}
		var newActiveIndex = activeIndexBuffer > index ? activeIndexBuffer + 1 : activeIndexBuffer;

		var slidesBuffer = [];
		for (var i = baseLength - 1; i >= index; i -= 1) {
			var currentSlide = swiper.slides.eq(i);
			currentSlide.remove();
			slidesBuffer.unshift(currentSlide);
		}

		if (typeof slides === 'object' && 'length' in slides) {
			for (var i$1 = 0; i$1 < slides.length; i$1 += 1) {
				if (slides[i$1]) { $wrapperEl.append(slides[i$1]); }
			}
			newActiveIndex = activeIndexBuffer > index ? activeIndexBuffer + slides.length : activeIndexBuffer;
		} else {
			$wrapperEl.append(slides);
		}

		for (var i$2 = 0; i$2 < slidesBuffer.length; i$2 += 1) {
			$wrapperEl.append(slidesBuffer[i$2]);
		}

		if (params.loop) {
			swiper.loopCreate();
		}
		if (!(params.observer && Support.observer)) {
			swiper.update();
		}
		if (params.loop) {
			swiper.slideTo(newActiveIndex + swiper.loopedSlides, 0, false);
		} else {
			swiper.slideTo(newActiveIndex, 0, false);
		}
	}

	function removeSlide (slidesIndexes) {
		var swiper = this;
		var params = swiper.params;
		var $wrapperEl = swiper.$wrapperEl;
		var activeIndex = swiper.activeIndex;

		var activeIndexBuffer = activeIndex;
		if (params.loop) {
			activeIndexBuffer -= swiper.loopedSlides;
			swiper.loopDestroy();
			swiper.slides = $wrapperEl.children(("." + (params.slideClass)));
		}
		var newActiveIndex = activeIndexBuffer;
		var indexToRemove;

		if (typeof slidesIndexes === 'object' && 'length' in slidesIndexes) {
			for (var i = 0; i < slidesIndexes.length; i += 1) {
				indexToRemove = slidesIndexes[i];
				if (swiper.slides[indexToRemove]) { swiper.slides.eq(indexToRemove).remove(); }
				if (indexToRemove < newActiveIndex) { newActiveIndex -= 1; }
			}
			newActiveIndex = Math.max(newActiveIndex, 0);
		} else {
			indexToRemove = slidesIndexes;
			if (swiper.slides[indexToRemove]) { swiper.slides.eq(indexToRemove).remove(); }
			if (indexToRemove < newActiveIndex) { newActiveIndex -= 1; }
			newActiveIndex = Math.max(newActiveIndex, 0);
		}

		if (params.loop) {
			swiper.loopCreate();
		}

		if (!(params.observer && Support.observer)) {
			swiper.update();
		}
		if (params.loop) {
			swiper.slideTo(newActiveIndex + swiper.loopedSlides, 0, false);
		} else {
			swiper.slideTo(newActiveIndex, 0, false);
		}
	}

	function removeAllSlides () {
		var swiper = this;

		var slidesIndexes = [];
		for (var i = 0; i < swiper.slides.length; i += 1) {
			slidesIndexes.push(i);
		}
		swiper.removeSlide(slidesIndexes);
	}

	var manipulation = {
		appendSlide: appendSlide,
		prependSlide: prependSlide,
		addSlide: addSlide,
		removeSlide: removeSlide,
		removeAllSlides: removeAllSlides,
	};

	var Device = (function Device() {
		var platform = win.navigator.platform;
		var ua = win.navigator.userAgent;

		var device = {
			ios: false,
			android: false,
			androidChrome: false,
			desktop: false,
			iphone: false,
			ipod: false,
			ipad: false,
			edge: false,
			ie: false,
			firefox: false,
			macos: false,
			windows: false,
			cordova: !!(win.cordova || win.phonegap),
			phonegap: !!(win.cordova || win.phonegap),
			electron: false,
		};

		var screenWidth = win.screen.width;
		var screenHeight = win.screen.height;

		var android = ua.match(/(Android);?[\s\/]+([\d.]+)?/); // eslint-disable-line
		var ipad = ua.match(/(iPad).*OS\s([\d_]+)/);
		var ipod = ua.match(/(iPod)(.*OS\s([\d_]+))?/);
		var iphone = !ipad && ua.match(/(iPhone\sOS|iOS)\s([\d_]+)/);
		var ie = ua.indexOf('MSIE ') >= 0 || ua.indexOf('Trident/') >= 0;
		var edge = ua.indexOf('Edge/') >= 0;
		var firefox = ua.indexOf('Gecko/') >= 0 && ua.indexOf('Firefox/') >= 0;
		var windows = platform === 'Win32';
		var electron = ua.toLowerCase().indexOf('electron') >= 0;
		var macos = platform === 'MacIntel';

		// iPadOs 13 fix
		if (!ipad
			&& macos
			&& Support.touch
			&& (
				(screenWidth === 1024 && screenHeight === 1366) // Pro 12.9
				|| (screenWidth === 834 && screenHeight === 1194) // Pro 11
				|| (screenWidth === 834 && screenHeight === 1112) // Pro 10.5
				|| (screenWidth === 768 && screenHeight === 1024) // other
			)
		) {
			ipad = ua.match(/(Version)\/([\d.]+)/);
			macos = false;
		}

		device.ie = ie;
		device.edge = edge;
		device.firefox = firefox;

		// Android
		if (android && !windows) {
			device.os = 'android';
			device.osVersion = android[2];
			device.android = true;
			device.androidChrome = ua.toLowerCase().indexOf('chrome') >= 0;
		}
		if (ipad || iphone || ipod) {
			device.os = 'ios';
			device.ios = true;
		}
		// iOS
		if (iphone && !ipod) {
			device.osVersion = iphone[2].replace(/_/g, '.');
			device.iphone = true;
		}
		if (ipad) {
			device.osVersion = ipad[2].replace(/_/g, '.');
			device.ipad = true;
		}
		if (ipod) {
			device.osVersion = ipod[3] ? ipod[3].replace(/_/g, '.') : null;
			device.ipod = true;
		}
		// iOS 8+ changed UA
		if (device.ios && device.osVersion && ua.indexOf('Version/') >= 0) {
			if (device.osVersion.split('.')[0] === '10') {
				device.osVersion = ua.toLowerCase().split('version/')[1].split(' ')[0];
			}
		}

		// Webview
		device.webView = !!((iphone || ipad || ipod) && (ua.match(/.*AppleWebKit(?!.*Safari)/i) || win.navigator.standalone))
			|| (win.matchMedia && win.matchMedia('(display-mode: standalone)').matches);
		device.webview = device.webView;
		device.standalone = device.webView;

		// Desktop
		device.desktop = !(device.ios || device.android) || electron;
		if (device.desktop) {
			device.electron = electron;
			device.macos = macos;
			device.windows = windows;
			if (device.macos) {
				device.os = 'macos';
			}
			if (device.windows) {
				device.os = 'windows';
			}
		}

		// Pixel Ratio
		device.pixelRatio = win.devicePixelRatio || 1;

		// Export object
		return device;
	}());

	function onTouchStart (event) {
		var swiper = this;
		var data = swiper.touchEventsData;
		var params = swiper.params;
		var touches = swiper.touches;

		if (swiper.animating && params.preventInteractionOnTransition) {
			return;
		}
		var e = event;
		if (e.originalEvent) { e = e.originalEvent; }
		var $targetEl = $(e.target);

		if (params.touchEventsTarget === 'wrapper') {
			if (!$targetEl.closest(swiper.wrapperEl).length) { return; }
		}
		data.isTouchEvent = e.type === 'touchstart';
		if (!data.isTouchEvent && 'which' in e && e.which === 3) { return; }
		if (!data.isTouchEvent && 'button' in e && e.button > 0) { return; }
		if (data.isTouched && data.isMoved) { return; }
		if (params.noSwiping && $targetEl.closest(params.noSwipingSelector ? params.noSwipingSelector : ("." + (params.noSwipingClass)))[0]) {
			swiper.allowClick = true;
			return;
		}
		if (params.swipeHandler) {
			if (!$targetEl.closest(params.swipeHandler)[0]) { return; }
		}

		touches.currentX = e.type === 'touchstart' ? e.targetTouches[0].pageX : e.pageX;
		touches.currentY = e.type === 'touchstart' ? e.targetTouches[0].pageY : e.pageY;
		var startX = touches.currentX;
		var startY = touches.currentY;

		// Do NOT start if iOS edge swipe is detected. Otherwise iOS app (UIWebView) cannot swipe-to-go-back anymore

		var edgeSwipeDetection = params.edgeSwipeDetection || params.iOSEdgeSwipeDetection;
		var edgeSwipeThreshold = params.edgeSwipeThreshold || params.iOSEdgeSwipeThreshold;
		if (
			edgeSwipeDetection
			&& ((startX <= edgeSwipeThreshold)
			|| (startX >= win.screen.width - edgeSwipeThreshold))
		) {
			return;
		}

		Utils.extend(data, {
			isTouched: true,
			isMoved: false,
			allowTouchCallbacks: true,
			isScrolling: undefined,
			startMoving: undefined,
		});

		touches.startX = startX;
		touches.startY = startY;
		data.touchStartTime = Utils.now();
		swiper.allowClick = true;
		swiper.updateSize();
		swiper.swipeDirection = undefined;
		if (params.threshold > 0) { data.allowThresholdMove = false; }
		if (e.type !== 'touchstart') {
			var preventDefault = true;
			if ($targetEl.is(data.formElements)) { preventDefault = false; }
			if (
				doc.activeElement
				&& $(doc.activeElement).is(data.formElements)
				&& doc.activeElement !== $targetEl[0]
			) {
				doc.activeElement.blur();
			}

			var shouldPreventDefault = preventDefault && swiper.allowTouchMove && params.touchStartPreventDefault;
			if (params.touchStartForcePreventDefault || shouldPreventDefault) {
				e.preventDefault();
			}
		}
		swiper.emit('touchStart', e);
	}

	function onTouchMove (event) {
		var swiper = this;
		var data = swiper.touchEventsData;
		var params = swiper.params;
		var touches = swiper.touches;
		var rtl = swiper.rtlTranslate;
		var e = event;
		if (e.originalEvent) { e = e.originalEvent; }
		if (!data.isTouched) {
			if (data.startMoving && data.isScrolling) {
				swiper.emit('touchMoveOpposite', e);
			}
			return;
		}
		if (data.isTouchEvent && e.type === 'mousemove') { return; }
		var targetTouch = e.type === 'touchmove' && e.targetTouches && (e.targetTouches[0] || e.changedTouches[0]);
		var pageX = e.type === 'touchmove' ? targetTouch.pageX : e.pageX;
		var pageY = e.type === 'touchmove' ? targetTouch.pageY : e.pageY;
		if (e.preventedByNestedSwiper) {
			touches.startX = pageX;
			touches.startY = pageY;
			return;
		}
		if (!swiper.allowTouchMove) {
			// isMoved = true;
			swiper.allowClick = false;
			if (data.isTouched) {
				Utils.extend(touches, {
					startX: pageX,
					startY: pageY,
					currentX: pageX,
					currentY: pageY,
				});
				data.touchStartTime = Utils.now();
			}
			return;
		}
		if (data.isTouchEvent && params.touchReleaseOnEdges && !params.loop) {
			if (swiper.isVertical()) {
				// Vertical
				if (
					(pageY < touches.startY && swiper.translate <= swiper.maxTranslate())
					|| (pageY > touches.startY && swiper.translate >= swiper.minTranslate())
				) {
					data.isTouched = false;
					data.isMoved = false;
					return;
				}
			} else if (
				(pageX < touches.startX && swiper.translate <= swiper.maxTranslate())
				|| (pageX > touches.startX && swiper.translate >= swiper.minTranslate())
			) {
				return;
			}
		}
		if (data.isTouchEvent && doc.activeElement) {
			if (e.target === doc.activeElement && $(e.target).is(data.formElements)) {
				data.isMoved = true;
				swiper.allowClick = false;
				return;
			}
		}
		if (data.allowTouchCallbacks) {
			swiper.emit('touchMove', e);
		}
		if (e.targetTouches && e.targetTouches.length > 1) { return; }

		touches.currentX = pageX;
		touches.currentY = pageY;

		var diffX = touches.currentX - touches.startX;
		var diffY = touches.currentY - touches.startY;
		if (swiper.params.threshold && Math.sqrt((Math.pow( diffX, 2 )) + (Math.pow( diffY, 2 ))) < swiper.params.threshold) { return; }

		if (typeof data.isScrolling === 'undefined') {
			var touchAngle;
			if ((swiper.isHorizontal() && touches.currentY === touches.startY) || (swiper.isVertical() && touches.currentX === touches.startX)) {
				data.isScrolling = false;
			} else {
				// eslint-disable-next-line
				if ((diffX * diffX) + (diffY * diffY) >= 25) {
					touchAngle = (Math.atan2(Math.abs(diffY), Math.abs(diffX)) * 180) / Math.PI;
					data.isScrolling = swiper.isHorizontal() ? touchAngle > params.touchAngle : (90 - touchAngle > params.touchAngle);
				}
			}
		}
		if (data.isScrolling) {
			swiper.emit('touchMoveOpposite', e);
		}
		if (typeof data.startMoving === 'undefined') {
			if (touches.currentX !== touches.startX || touches.currentY !== touches.startY) {
				data.startMoving = true;
			}
		}
		if (data.isScrolling) {
			data.isTouched = false;
			return;
		}
		if (!data.startMoving) {
			return;
		}
		swiper.allowClick = false;
		if (!params.cssMode) {
			e.preventDefault();
		}
		if (params.touchMoveStopPropagation && !params.nested) {
			e.stopPropagation();
		}

		if (!data.isMoved) {
			if (params.loop) {
				swiper.loopFix();
			}
			data.startTranslate = swiper.getTranslate();
			swiper.setTransition(0);
			if (swiper.animating) {
				swiper.$wrapperEl.trigger('webkitTransitionEnd transitionend');
			}
			data.allowMomentumBounce = false;
			// Grab Cursor
			if (params.grabCursor && (swiper.allowSlideNext === true || swiper.allowSlidePrev === true)) {
				swiper.setGrabCursor(true);
			}
			swiper.emit('sliderFirstMove', e);
		}
		swiper.emit('sliderMove', e);
		data.isMoved = true;

		var diff = swiper.isHorizontal() ? diffX : diffY;
		touches.diff = diff;

		diff *= params.touchRatio;
		if (rtl) { diff = -diff; }

		swiper.swipeDirection = diff > 0 ? 'prev' : 'next';
		data.currentTranslate = diff + data.startTranslate;

		var disableParentSwiper = true;
		var resistanceRatio = params.resistanceRatio;
		if (params.touchReleaseOnEdges) {
			resistanceRatio = 0;
		}
		if ((diff > 0 && data.currentTranslate > swiper.minTranslate())) {
			disableParentSwiper = false;
			if (params.resistance) { data.currentTranslate = (swiper.minTranslate() - 1) + (Math.pow( (-swiper.minTranslate() + data.startTranslate + diff), resistanceRatio )); }
		} else if (diff < 0 && data.currentTranslate < swiper.maxTranslate()) {
			disableParentSwiper = false;
			if (params.resistance) { data.currentTranslate = (swiper.maxTranslate() + 1) - (Math.pow( (swiper.maxTranslate() - data.startTranslate - diff), resistanceRatio )); }
		}

		if (disableParentSwiper) {
			e.preventedByNestedSwiper = true;
		}

		// Directions locks
		if (!swiper.allowSlideNext && swiper.swipeDirection === 'next' && data.currentTranslate < data.startTranslate) {
			data.currentTranslate = data.startTranslate;
		}
		if (!swiper.allowSlidePrev && swiper.swipeDirection === 'prev' && data.currentTranslate > data.startTranslate) {
			data.currentTranslate = data.startTranslate;
		}


		// Threshold
		if (params.threshold > 0) {
			if (Math.abs(diff) > params.threshold || data.allowThresholdMove) {
				if (!data.allowThresholdMove) {
					data.allowThresholdMove = true;
					touches.startX = touches.currentX;
					touches.startY = touches.currentY;
					data.currentTranslate = data.startTranslate;
					touches.diff = swiper.isHorizontal() ? touches.currentX - touches.startX : touches.currentY - touches.startY;
					return;
				}
			} else {
				data.currentTranslate = data.startTranslate;
				return;
			}
		}

		if (!params.followFinger || params.cssMode) { return; }

		// Update active index in free mode
		if (params.freeMode || params.watchSlidesProgress || params.watchSlidesVisibility) {
			swiper.updateActiveIndex();
			swiper.updateSlidesClasses();
		}
		if (params.freeMode) {
			// Velocity
			if (data.velocities.length === 0) {
				data.velocities.push({
					position: touches[swiper.isHorizontal() ? 'startX' : 'startY'],
					time: data.touchStartTime,
				});
			}
			data.velocities.push({
				position: touches[swiper.isHorizontal() ? 'currentX' : 'currentY'],
				time: Utils.now(),
			});
		}
		// Update progress
		swiper.updateProgress(data.currentTranslate);
		// Update translate
		swiper.setTranslate(data.currentTranslate);
	}

	function onTouchEnd (event) {
		var swiper = this;
		var data = swiper.touchEventsData;

		var params = swiper.params;
		var touches = swiper.touches;
		var rtl = swiper.rtlTranslate;
		var $wrapperEl = swiper.$wrapperEl;
		var slidesGrid = swiper.slidesGrid;
		var snapGrid = swiper.snapGrid;
		var e = event;
		if (e.originalEvent) { e = e.originalEvent; }
		if (data.allowTouchCallbacks) {
			swiper.emit('touchEnd', e);
		}
		data.allowTouchCallbacks = false;
		if (!data.isTouched) {
			if (data.isMoved && params.grabCursor) {
				swiper.setGrabCursor(false);
			}
			data.isMoved = false;
			data.startMoving = false;
			return;
		}
		// Return Grab Cursor
		if (params.grabCursor && data.isMoved && data.isTouched && (swiper.allowSlideNext === true || swiper.allowSlidePrev === true)) {
			swiper.setGrabCursor(false);
		}

		// Time diff
		var touchEndTime = Utils.now();
		var timeDiff = touchEndTime - data.touchStartTime;

		// Tap, doubleTap, Click
		if (swiper.allowClick) {
			swiper.updateClickedSlide(e);
			swiper.emit('tap click', e);
			if (timeDiff < 300 && (touchEndTime - data.lastClickTime) < 300) {
				swiper.emit('doubleTap doubleClick', e);
			}
		}

		data.lastClickTime = Utils.now();
		Utils.nextTick(function () {
			if (!swiper.destroyed) { swiper.allowClick = true; }
		});

		if (!data.isTouched || !data.isMoved || !swiper.swipeDirection || touches.diff === 0 || data.currentTranslate === data.startTranslate) {
			data.isTouched = false;
			data.isMoved = false;
			data.startMoving = false;
			return;
		}
		data.isTouched = false;
		data.isMoved = false;
		data.startMoving = false;

		var currentPos;
		if (params.followFinger) {
			currentPos = rtl ? swiper.translate : -swiper.translate;
		} else {
			currentPos = -data.currentTranslate;
		}

		if (params.cssMode) {
			return;
		}

		if (params.freeMode) {
			if (currentPos < -swiper.minTranslate()) {
				swiper.slideTo(swiper.activeIndex);
				return;
			}
			if (currentPos > -swiper.maxTranslate()) {
				if (swiper.slides.length < snapGrid.length) {
					swiper.slideTo(snapGrid.length - 1);
				} else {
					swiper.slideTo(swiper.slides.length - 1);
				}
				return;
			}

			if (params.freeModeMomentum) {
				if (data.velocities.length > 1) {
					var lastMoveEvent = data.velocities.pop();
					var velocityEvent = data.velocities.pop();

					var distance = lastMoveEvent.position - velocityEvent.position;
					var time = lastMoveEvent.time - velocityEvent.time;
					swiper.velocity = distance / time;
					swiper.velocity /= 2;
					if (Math.abs(swiper.velocity) < params.freeModeMinimumVelocity) {
						swiper.velocity = 0;
					}
					// this implies that the user stopped moving a finger then released.
					// There would be no events with distance zero, so the last event is stale.
					if (time > 150 || (Utils.now() - lastMoveEvent.time) > 300) {
						swiper.velocity = 0;
					}
				} else {
					swiper.velocity = 0;
				}
				swiper.velocity *= params.freeModeMomentumVelocityRatio;

				data.velocities.length = 0;
				var momentumDuration = 1000 * params.freeModeMomentumRatio;
				var momentumDistance = swiper.velocity * momentumDuration;

				var newPosition = swiper.translate + momentumDistance;
				if (rtl) { newPosition = -newPosition; }

				var doBounce = false;
				var afterBouncePosition;
				var bounceAmount = Math.abs(swiper.velocity) * 20 * params.freeModeMomentumBounceRatio;
				var needsLoopFix;
				if (newPosition < swiper.maxTranslate()) {
					if (params.freeModeMomentumBounce) {
						if (newPosition + swiper.maxTranslate() < -bounceAmount) {
							newPosition = swiper.maxTranslate() - bounceAmount;
						}
						afterBouncePosition = swiper.maxTranslate();
						doBounce = true;
						data.allowMomentumBounce = true;
					} else {
						newPosition = swiper.maxTranslate();
					}
					if (params.loop && params.centeredSlides) { needsLoopFix = true; }
				} else if (newPosition > swiper.minTranslate()) {
					if (params.freeModeMomentumBounce) {
						if (newPosition - swiper.minTranslate() > bounceAmount) {
							newPosition = swiper.minTranslate() + bounceAmount;
						}
						afterBouncePosition = swiper.minTranslate();
						doBounce = true;
						data.allowMomentumBounce = true;
					} else {
						newPosition = swiper.minTranslate();
					}
					if (params.loop && params.centeredSlides) { needsLoopFix = true; }
				} else if (params.freeModeSticky) {
					var nextSlide;
					for (var j = 0; j < snapGrid.length; j += 1) {
						if (snapGrid[j] > -newPosition) {
							nextSlide = j;
							break;
						}
					}

					if (Math.abs(snapGrid[nextSlide] - newPosition) < Math.abs(snapGrid[nextSlide - 1] - newPosition) || swiper.swipeDirection === 'next') {
						newPosition = snapGrid[nextSlide];
					} else {
						newPosition = snapGrid[nextSlide - 1];
					}
					newPosition = -newPosition;
				}
				if (needsLoopFix) {
					swiper.once('transitionEnd', function () {
						swiper.loopFix();
					});
				}
				// Fix duration
				if (swiper.velocity !== 0) {
					if (rtl) {
						momentumDuration = Math.abs((-newPosition - swiper.translate) / swiper.velocity);
					} else {
						momentumDuration = Math.abs((newPosition - swiper.translate) / swiper.velocity);
					}
					if (params.freeModeSticky) {
						// If freeModeSticky is active and the user ends a swipe with a slow-velocity
						// event, then durations can be 20+ seconds to slide one (or zero!) slides.
						// It's easy to see this when simulating touch with mouse events. To fix this,
						// limit single-slide swipes to the default slide duration. This also has the
						// nice side effect of matching slide speed if the user stopped moving before
						// lifting finger or mouse vs. moving slowly before lifting the finger/mouse.
						// For faster swipes, also apply limits (albeit higher ones).
						var moveDistance = Math.abs((rtl ? -newPosition : newPosition) - swiper.translate);
						var currentSlideSize = swiper.slidesSizesGrid[swiper.activeIndex];
						if (moveDistance < currentSlideSize) {
							momentumDuration = params.speed;
						} else if (moveDistance < 2 * currentSlideSize) {
							momentumDuration = params.speed * 1.5;
						} else {
							momentumDuration = params.speed * 2.5;
						}
					}
				} else if (params.freeModeSticky) {
					swiper.slideToClosest();
					return;
				}

				if (params.freeModeMomentumBounce && doBounce) {
					swiper.updateProgress(afterBouncePosition);
					swiper.setTransition(momentumDuration);
					swiper.setTranslate(newPosition);
					swiper.transitionStart(true, swiper.swipeDirection);
					swiper.animating = true;
					$wrapperEl.transitionEnd(function () {
						if (!swiper || swiper.destroyed || !data.allowMomentumBounce) { return; }
						swiper.emit('momentumBounce');

						swiper.setTransition(params.speed);
						swiper.setTranslate(afterBouncePosition);
						$wrapperEl.transitionEnd(function () {
							if (!swiper || swiper.destroyed) { return; }
							swiper.transitionEnd();
						});
					});
				} else if (swiper.velocity) {
					swiper.updateProgress(newPosition);
					swiper.setTransition(momentumDuration);
					swiper.setTranslate(newPosition);
					swiper.transitionStart(true, swiper.swipeDirection);
					if (!swiper.animating) {
						swiper.animating = true;
						$wrapperEl.transitionEnd(function () {
							if (!swiper || swiper.destroyed) { return; }
							swiper.transitionEnd();
						});
					}
				} else {
					swiper.updateProgress(newPosition);
				}

				swiper.updateActiveIndex();
				swiper.updateSlidesClasses();
			} else if (params.freeModeSticky) {
				swiper.slideToClosest();
				return;
			}

			if (!params.freeModeMomentum || timeDiff >= params.longSwipesMs) {
				swiper.updateProgress();
				swiper.updateActiveIndex();
				swiper.updateSlidesClasses();
			}
			return;
		}

		// Find current slide
		var stopIndex = 0;
		var groupSize = swiper.slidesSizesGrid[0];
		for (var i = 0; i < slidesGrid.length; i += (i < params.slidesPerGroupSkip ? 1 : params.slidesPerGroup)) {
			var increment$1 = (i < params.slidesPerGroupSkip - 1 ? 1 : params.slidesPerGroup);
			if (typeof slidesGrid[i + increment$1] !== 'undefined') {
				if (currentPos >= slidesGrid[i] && currentPos < slidesGrid[i + increment$1]) {
					stopIndex = i;
					groupSize = slidesGrid[i + increment$1] - slidesGrid[i];
				}
			} else if (currentPos >= slidesGrid[i]) {
				stopIndex = i;
				groupSize = slidesGrid[slidesGrid.length - 1] - slidesGrid[slidesGrid.length - 2];
			}
		}

		// Find current slide size
		var ratio = (currentPos - slidesGrid[stopIndex]) / groupSize;
		var increment = (stopIndex < params.slidesPerGroupSkip - 1 ? 1 : params.slidesPerGroup);

		if (timeDiff > params.longSwipesMs) {
			// Long touches
			if (!params.longSwipes) {
				swiper.slideTo(swiper.activeIndex);
				return;
			}
			if (swiper.swipeDirection === 'next') {
				if (ratio >= params.longSwipesRatio) { swiper.slideTo(stopIndex + increment); }
				else { swiper.slideTo(stopIndex); }
			}
			if (swiper.swipeDirection === 'prev') {
				if (ratio > (1 - params.longSwipesRatio)) { swiper.slideTo(stopIndex + increment); }
				else { swiper.slideTo(stopIndex); }
			}
		} else {
			// Short swipes
			if (!params.shortSwipes) {
				swiper.slideTo(swiper.activeIndex);
				return;
			}
			var isNavButtonTarget = swiper.navigation && (e.target === swiper.navigation.nextEl || e.target === swiper.navigation.prevEl);
			if (!isNavButtonTarget) {
				if (swiper.swipeDirection === 'next') {
					swiper.slideTo(stopIndex + increment);
				}
				if (swiper.swipeDirection === 'prev') {
					swiper.slideTo(stopIndex);
				}
			} else if (e.target === swiper.navigation.nextEl) {
				swiper.slideTo(stopIndex + increment);
			} else {
				swiper.slideTo(stopIndex);
			}
		}
	}

	function onResize () {
		var swiper = this;

		var params = swiper.params;
		var el = swiper.el;

		if (el && el.offsetWidth === 0) { return; }

		// Breakpoints
		if (params.breakpoints) {
			swiper.setBreakpoint();
		}

		// Save locks
		var allowSlideNext = swiper.allowSlideNext;
		var allowSlidePrev = swiper.allowSlidePrev;
		var snapGrid = swiper.snapGrid;

		// Disable locks on resize
		swiper.allowSlideNext = true;
		swiper.allowSlidePrev = true;

		swiper.updateSize();
		swiper.updateSlides();

		swiper.updateSlidesClasses();
		if ((params.slidesPerView === 'auto' || params.slidesPerView > 1) && swiper.isEnd && !swiper.params.centeredSlides) {
			swiper.slideTo(swiper.slides.length - 1, 0, false, true);
		} else {
			swiper.slideTo(swiper.activeIndex, 0, false, true);
		}

		if (swiper.autoplay && swiper.autoplay.running && swiper.autoplay.paused) {
			swiper.autoplay.run();
		}
		// Return locks after resize
		swiper.allowSlidePrev = allowSlidePrev;
		swiper.allowSlideNext = allowSlideNext;

		if (swiper.params.watchOverflow && snapGrid !== swiper.snapGrid) {
			swiper.checkOverflow();
		}
	}

	function onClick (e) {
		var swiper = this;
		if (!swiper.allowClick) {
			if (swiper.params.preventClicks) { e.preventDefault(); }
			if (swiper.params.preventClicksPropagation && swiper.animating) {
				e.stopPropagation();
				e.stopImmediatePropagation();
			}
		}
	}

	function onScroll () {
		var swiper = this;
		var wrapperEl = swiper.wrapperEl;
		swiper.previousTranslate = swiper.translate;
		swiper.translate = swiper.isHorizontal() ? -wrapperEl.scrollLeft : -wrapperEl.scrollTop;
		// eslint-disable-next-line
		if (swiper.translate === -0) { swiper.translate = 0; }

		swiper.updateActiveIndex();
		swiper.updateSlidesClasses();

		var newProgress;
		var translatesDiff = swiper.maxTranslate() - swiper.minTranslate();
		if (translatesDiff === 0) {
			newProgress = 0;
		} else {
			newProgress = (swiper.translate - swiper.minTranslate()) / (translatesDiff);
		}
		if (newProgress !== swiper.progress) {
			swiper.updateProgress(swiper.translate);
		}

		swiper.emit('setTranslate', swiper.translate, false);
	}

	var dummyEventAttached = false;
	function dummyEventListener() {}

	function attachEvents() {
		var swiper = this;
		var params = swiper.params;
		var touchEvents = swiper.touchEvents;
		var el = swiper.el;
		var wrapperEl = swiper.wrapperEl;

		swiper.onTouchStart = onTouchStart.bind(swiper);
		swiper.onTouchMove = onTouchMove.bind(swiper);
		swiper.onTouchEnd = onTouchEnd.bind(swiper);
		if (params.cssMode) {
			swiper.onScroll = onScroll.bind(swiper);
		}

		swiper.onClick = onClick.bind(swiper);

		var capture = !!params.nested;

		// Touch Events
		if (!Support.touch && Support.pointerEvents) {
			el.addEventListener(touchEvents.start, swiper.onTouchStart, false);
			doc.addEventListener(touchEvents.move, swiper.onTouchMove, capture);
			doc.addEventListener(touchEvents.end, swiper.onTouchEnd, false);
		} else {
			if (Support.touch) {
				var passiveListener = touchEvents.start === 'touchstart' && Support.passiveListener && params.passiveListeners ? { passive: true, capture: false } : false;
				el.addEventListener(touchEvents.start, swiper.onTouchStart, passiveListener);
				el.addEventListener(touchEvents.move, swiper.onTouchMove, Support.passiveListener ? { passive: false, capture: capture } : capture);
				el.addEventListener(touchEvents.end, swiper.onTouchEnd, passiveListener);
				if (touchEvents.cancel) {
					el.addEventListener(touchEvents.cancel, swiper.onTouchEnd, passiveListener);
				}
				if (!dummyEventAttached) {
					doc.addEventListener('touchstart', dummyEventListener);
					dummyEventAttached = true;
				}
			}
			if ((params.simulateTouch && !Device.ios && !Device.android) || (params.simulateTouch && !Support.touch && Device.ios)) {
				el.addEventListener('mousedown', swiper.onTouchStart, false);
				doc.addEventListener('mousemove', swiper.onTouchMove, capture);
				doc.addEventListener('mouseup', swiper.onTouchEnd, false);
			}
		}
		// Prevent Links Clicks
		if (params.preventClicks || params.preventClicksPropagation) {
			el.addEventListener('click', swiper.onClick, true);
		}
		if (params.cssMode) {
			wrapperEl.addEventListener('scroll', swiper.onScroll);
		}

		// Resize handler
		if (params.updateOnWindowResize) {
			swiper.on((Device.ios || Device.android ? 'resize orientationchange observerUpdate' : 'resize observerUpdate'), onResize, true);
		} else {
			swiper.on('observerUpdate', onResize, true);
		}
	}

	function detachEvents() {
		var swiper = this;

		var params = swiper.params;
		var touchEvents = swiper.touchEvents;
		var el = swiper.el;
		var wrapperEl = swiper.wrapperEl;

		var capture = !!params.nested;

		// Touch Events
		if (!Support.touch && Support.pointerEvents) {
			el.removeEventListener(touchEvents.start, swiper.onTouchStart, false);
			doc.removeEventListener(touchEvents.move, swiper.onTouchMove, capture);
			doc.removeEventListener(touchEvents.end, swiper.onTouchEnd, false);
		} else {
			if (Support.touch) {
				var passiveListener = touchEvents.start === 'onTouchStart' && Support.passiveListener && params.passiveListeners ? { passive: true, capture: false } : false;
				el.removeEventListener(touchEvents.start, swiper.onTouchStart, passiveListener);
				el.removeEventListener(touchEvents.move, swiper.onTouchMove, capture);
				el.removeEventListener(touchEvents.end, swiper.onTouchEnd, passiveListener);
				if (touchEvents.cancel) {
					el.removeEventListener(touchEvents.cancel, swiper.onTouchEnd, passiveListener);
				}
			}
			if ((params.simulateTouch && !Device.ios && !Device.android) || (params.simulateTouch && !Support.touch && Device.ios)) {
				el.removeEventListener('mousedown', swiper.onTouchStart, false);
				doc.removeEventListener('mousemove', swiper.onTouchMove, capture);
				doc.removeEventListener('mouseup', swiper.onTouchEnd, false);
			}
		}
		// Prevent Links Clicks
		if (params.preventClicks || params.preventClicksPropagation) {
			el.removeEventListener('click', swiper.onClick, true);
		}

		if (params.cssMode) {
			wrapperEl.removeEventListener('scroll', swiper.onScroll);
		}

		// Resize handler
		swiper.off((Device.ios || Device.android ? 'resize orientationchange observerUpdate' : 'resize observerUpdate'), onResize);
	}

	var events = {
		attachEvents: attachEvents,
		detachEvents: detachEvents,
	};

	function setBreakpoint () {
		var swiper = this;
		var activeIndex = swiper.activeIndex;
		var initialized = swiper.initialized;
		var loopedSlides = swiper.loopedSlides; if ( loopedSlides === void 0 ) loopedSlides = 0;
		var params = swiper.params;
		var $el = swiper.$el;
		var breakpoints = params.breakpoints;
		if (!breakpoints || (breakpoints && Object.keys(breakpoints).length === 0)) { return; }

		// Get breakpoint for window width and update parameters
		var breakpoint = swiper.getBreakpoint(breakpoints);

		if (breakpoint && swiper.currentBreakpoint !== breakpoint) {
			var breakpointOnlyParams = breakpoint in breakpoints ? breakpoints[breakpoint] : undefined;
			if (breakpointOnlyParams) {
				['slidesPerView', 'spaceBetween', 'slidesPerGroup', 'slidesPerGroupSkip', 'slidesPerColumn'].forEach(function (param) {
					var paramValue = breakpointOnlyParams[param];
					if (typeof paramValue === 'undefined') { return; }
					if (param === 'slidesPerView' && (paramValue === 'AUTO' || paramValue === 'auto')) {
						breakpointOnlyParams[param] = 'auto';
					} else if (param === 'slidesPerView') {
						breakpointOnlyParams[param] = parseFloat(paramValue);
					} else {
						breakpointOnlyParams[param] = parseInt(paramValue, 10);
					}
				});
			}

			var breakpointParams = breakpointOnlyParams || swiper.originalParams;
			var wasMultiRow = params.slidesPerColumn > 1;
			var isMultiRow = breakpointParams.slidesPerColumn > 1;
			if (wasMultiRow && !isMultiRow) {
				$el.removeClass(((params.containerModifierClass) + "multirow " + (params.containerModifierClass) + "multirow-column"));
			} else if (!wasMultiRow && isMultiRow) {
				$el.addClass(((params.containerModifierClass) + "multirow"));
				if (breakpointParams.slidesPerColumnFill === 'column') {
					$el.addClass(((params.containerModifierClass) + "multirow-column"));
				}
			}

			var directionChanged = breakpointParams.direction && breakpointParams.direction !== params.direction;
			var needsReLoop = params.loop && (breakpointParams.slidesPerView !== params.slidesPerView || directionChanged);

			if (directionChanged && initialized) {
				swiper.changeDirection();
			}

			Utils.extend(swiper.params, breakpointParams);

			Utils.extend(swiper, {
				allowTouchMove: swiper.params.allowTouchMove,
				allowSlideNext: swiper.params.allowSlideNext,
				allowSlidePrev: swiper.params.allowSlidePrev,
			});

			swiper.currentBreakpoint = breakpoint;

			if (needsReLoop && initialized) {
				swiper.loopDestroy();
				swiper.loopCreate();
				swiper.updateSlides();
				swiper.slideTo((activeIndex - loopedSlides) + swiper.loopedSlides, 0, false);
			}

			swiper.emit('breakpoint', breakpointParams);
		}
	}

	function getBreakpoint (breakpoints) {
		// Get breakpoint for window width
		if (!breakpoints) { return undefined; }
		var breakpoint = false;

		var points = Object.keys(breakpoints).map(function (point) {
			if (typeof point === 'string' && point.indexOf('@') === 0) {
				var minRatio = parseFloat(point.substr(1));
				var value = win.innerHeight * minRatio;
				return { value: value, point: point };
			}
			return { value: point, point: point };
		});

		points.sort(function (a, b) { return parseInt(a.value, 10) - parseInt(b.value, 10); });
		for (var i = 0; i < points.length; i += 1) {
			var ref = points[i];
			var point = ref.point;
			var value = ref.value;
			if (value <= win.innerWidth) {
				breakpoint = point;
			}
		}
		return breakpoint || 'max';
	}

	var breakpoints = { setBreakpoint: setBreakpoint, getBreakpoint: getBreakpoint };

	function addClasses () {
		var swiper = this;
		var classNames = swiper.classNames;
		var params = swiper.params;
		var rtl = swiper.rtl;
		var $el = swiper.$el;
		var suffixes = [];

		suffixes.push('initialized');
		suffixes.push(params.direction);

		if (params.freeMode) {
			suffixes.push('free-mode');
		}
		if (params.autoHeight) {
			suffixes.push('autoheight');
		}
		if (rtl) {
			suffixes.push('rtl');
		}
		if (params.slidesPerColumn > 1) {
			suffixes.push('multirow');
			if (params.slidesPerColumnFill === 'column') {
				suffixes.push('multirow-column');
			}
		}
		if (Device.android) {
			suffixes.push('android');
		}
		if (Device.ios) {
			suffixes.push('ios');
		}

		if (params.cssMode) {
			suffixes.push('css-mode');
		}

		suffixes.forEach(function (suffix) {
			classNames.push(params.containerModifierClass + suffix);
		});

		$el.addClass(classNames.join(' '));
	}

	function removeClasses () {
		var swiper = this;
		var $el = swiper.$el;
		var classNames = swiper.classNames;

		$el.removeClass(classNames.join(' '));
	}

	var classes = { addClasses: addClasses, removeClasses: removeClasses };

	function loadImage (imageEl, src, srcset, sizes, checkForComplete, callback) {
		var image;
		function onReady() {
			if (callback) { callback(); }
		}
		if (!imageEl.complete || !checkForComplete) {
			if (src) {
				image = new win.Image();
				image.onload = onReady;
				image.onerror = onReady;
				if (sizes) {
					image.sizes = sizes;
				}
				if (srcset) {
					image.srcset = srcset;
				}
				if (src) {
					image.src = src;
				}
			} else {
				onReady();
			}
		} else {
			// image already loaded...
			onReady();
		}
	}

	function preloadImages () {
		var swiper = this;
		swiper.imagesToLoad = swiper.$el.find('img');
		function onReady() {
			if (typeof swiper === 'undefined' || swiper === null || !swiper || swiper.destroyed) { return; }
			if (swiper.imagesLoaded !== undefined) { swiper.imagesLoaded += 1; }
			if (swiper.imagesLoaded === swiper.imagesToLoad.length) {
				if (swiper.params.updateOnImagesReady) { swiper.update(); }
				swiper.emit('imagesReady');
			}
		}
		for (var i = 0; i < swiper.imagesToLoad.length; i += 1) {
			var imageEl = swiper.imagesToLoad[i];
			swiper.loadImage(
				imageEl,
				imageEl.currentSrc || imageEl.getAttribute('src'),
				imageEl.srcset || imageEl.getAttribute('srcset'),
				imageEl.sizes || imageEl.getAttribute('sizes'),
				true,
				onReady
			);
		}
	}

	var images = {
		loadImage: loadImage,
		preloadImages: preloadImages,
	};

	function checkOverflow() {
		var swiper = this;
		var params = swiper.params;
		var wasLocked = swiper.isLocked;
		var lastSlidePosition = swiper.slides.length > 0 && (params.slidesOffsetBefore + (params.spaceBetween * (swiper.slides.length - 1)) + ((swiper.slides[0]).offsetWidth) * swiper.slides.length);

		if (params.slidesOffsetBefore && params.slidesOffsetAfter && lastSlidePosition) {
			swiper.isLocked = lastSlidePosition <= swiper.size;
		} else {
			swiper.isLocked = swiper.snapGrid.length === 1;
		}

		swiper.allowSlideNext = !swiper.isLocked;
		swiper.allowSlidePrev = !swiper.isLocked;

		// events
		if (wasLocked !== swiper.isLocked) { swiper.emit(swiper.isLocked ? 'lock' : 'unlock'); }

		if (wasLocked && wasLocked !== swiper.isLocked) {
			swiper.isEnd = false;
			swiper.navigation.update();
		}
	}

	var checkOverflow$1 = { checkOverflow: checkOverflow };

	var defaults = {
		init: true,
		direction: 'horizontal',
		touchEventsTarget: 'container',
		initialSlide: 0,
		speed: 300,
		cssMode: false,
		updateOnWindowResize: true,
		//
		preventInteractionOnTransition: false,

		// To support iOS's swipe-to-go-back gesture (when being used in-app, with UIWebView).
		edgeSwipeDetection: false,
		edgeSwipeThreshold: 20,

		// Free mode
		freeMode: false,
		freeModeMomentum: true,
		freeModeMomentumRatio: 1,
		freeModeMomentumBounce: true,
		freeModeMomentumBounceRatio: 1,
		freeModeMomentumVelocityRatio: 1,
		freeModeSticky: false,
		freeModeMinimumVelocity: 0.02,

		// Autoheight
		autoHeight: false,

		// Set wrapper width
		setWrapperSize: false,

		// Virtual Translate
		virtualTranslate: false,

		// Effects
		effect: 'slide', // 'slide' or 'fade' or 'cube' or 'coverflow' or 'flip'

		// Breakpoints
		breakpoints: undefined,

		// Slides grid
		spaceBetween: 0,
		slidesPerView: 1,
		slidesPerColumn: 1,
		slidesPerColumnFill: 'column',
		slidesPerGroup: 1,
		slidesPerGroupSkip: 0,
		centeredSlides: false,
		centeredSlidesBounds: false,
		slidesOffsetBefore: 0, // in px
		slidesOffsetAfter: 0, // in px
		normalizeSlideIndex: true,
		centerInsufficientSlides: false,

		// Disable swiper and hide navigation when container not overflow
		watchOverflow: false,

		// Round length
		roundLengths: false,

		// Touches
		touchRatio: 1,
		touchAngle: 45,
		simulateTouch: true,
		shortSwipes: true,
		longSwipes: true,
		longSwipesRatio: 0.5,
		longSwipesMs: 300,
		followFinger: true,
		allowTouchMove: true,
		threshold: 0,
		touchMoveStopPropagation: false,
		touchStartPreventDefault: true,
		touchStartForcePreventDefault: false,
		touchReleaseOnEdges: false,

		// Unique Navigation Elements
		uniqueNavElements: true,

		// Resistance
		resistance: true,
		resistanceRatio: 0.85,

		// Progress
		watchSlidesProgress: false,
		watchSlidesVisibility: false,

		// Cursor
		grabCursor: false,

		// Clicks
		preventClicks: true,
		preventClicksPropagation: true,
		slideToClickedSlide: false,

		// Images
		preloadImages: true,
		updateOnImagesReady: true,

		// loop
		loop: false,
		loopAdditionalSlides: 0,
		loopedSlides: null,
		loopFillGroupWithBlank: false,

		// Swiping/no swiping
		allowSlidePrev: true,
		allowSlideNext: true,
		swipeHandler: null, // '.swipe-handler',
		noSwiping: true,
		noSwipingClass: 'swiper-no-swiping',
		noSwipingSelector: null,

		// Passive Listeners
		passiveListeners: true,

		// NS
		containerModifierClass: 'swiper-container-', // NEW
		slideClass: 'swiper-slide',
		slideBlankClass: 'swiper-slide-invisible-blank',
		slideActiveClass: 'swiper-slide-active',
		slideDuplicateActiveClass: 'swiper-slide-duplicate-active',
		slideVisibleClass: 'swiper-slide-visible',
		slideDuplicateClass: 'swiper-slide-duplicate',
		slideNextClass: 'swiper-slide-next',
		slideDuplicateNextClass: 'swiper-slide-duplicate-next',
		slidePrevClass: 'swiper-slide-prev',
		slideDuplicatePrevClass: 'swiper-slide-duplicate-prev',
		wrapperClass: 'swiper-wrapper',

		// Callbacks
		runCallbacksOnInit: true,
	};

	/* eslint no-param-reassign: "off" */

	var prototypes = {
		update: update,
		translate: translate,
		transition: transition$1,
		slide: slide,
		loop: loop,
		grabCursor: grabCursor,
		manipulation: manipulation,
		events: events,
		breakpoints: breakpoints,
		checkOverflow: checkOverflow$1,
		classes: classes,
		images: images,
	};

	var extendedDefaults = {};

	var Swiper = /*@__PURE__*/(function (SwiperClass) {
		function Swiper() {
			var assign;

			var args = [], len = arguments.length;
			while ( len-- ) args[ len ] = arguments[ len ];
			var el;
			var params;
			if (args.length === 1 && args[0].constructor && args[0].constructor === Object) {
				params = args[0];
			} else {
				(assign = args, el = assign[0], params = assign[1]);
			}
			if (!params) { params = {}; }

			params = Utils.extend({}, params);
			if (el && !params.el) { params.el = el; }

			SwiperClass.call(this, params);

			Object.keys(prototypes).forEach(function (prototypeGroup) {
				Object.keys(prototypes[prototypeGroup]).forEach(function (protoMethod) {
					if (!Swiper.prototype[protoMethod]) {
						Swiper.prototype[protoMethod] = prototypes[prototypeGroup][protoMethod];
					}
				});
			});

			// Swiper Instance
			var swiper = this;
			if (typeof swiper.modules === 'undefined') {
				swiper.modules = {};
			}
			Object.keys(swiper.modules).forEach(function (moduleName) {
				var module = swiper.modules[moduleName];
				if (module.params) {
					var moduleParamName = Object.keys(module.params)[0];
					var moduleParams = module.params[moduleParamName];
					if (typeof moduleParams !== 'object' || moduleParams === null) { return; }
					if (!(moduleParamName in params && 'enabled' in moduleParams)) { return; }
					if (params[moduleParamName] === true) {
						params[moduleParamName] = { enabled: true };
					}
					if (
						typeof params[moduleParamName] === 'object'
						&& !('enabled' in params[moduleParamName])
					) {
						params[moduleParamName].enabled = true;
					}
					if (!params[moduleParamName]) { params[moduleParamName] = { enabled: false }; }
				}
			});

			// Extend defaults with modules params
			var swiperParams = Utils.extend({}, defaults);
			swiper.useModulesParams(swiperParams);

			// Extend defaults with passed params
			swiper.params = Utils.extend({}, swiperParams, extendedDefaults, params);
			swiper.originalParams = Utils.extend({}, swiper.params);
			swiper.passedParams = Utils.extend({}, params);

			// Save Dom lib
			swiper.$ = $;

			// Find el
			var $el = $(swiper.params.el);
			el = $el[0];

			if (!el) {
				return undefined;
			}

			if ($el.length > 1) {
				var swipers = [];
				$el.each(function (index, containerEl) {
					var newParams = Utils.extend({}, params, { el: containerEl });
					swipers.push(new Swiper(newParams));
				});
				return swipers;
			}

			el.swiper = swiper;
			$el.data('swiper', swiper);

			// Find Wrapper
			var $wrapperEl;
			if (el && el.shadowRoot && el.shadowRoot.querySelector) {
				$wrapperEl = $(el.shadowRoot.querySelector(("." + (swiper.params.wrapperClass))));
				// Children needs to return slot items
				$wrapperEl.children = function (options) { return $el.children(options); };
			} else {
				$wrapperEl = $el.children(("." + (swiper.params.wrapperClass)));
			}
			// Extend Swiper
			Utils.extend(swiper, {
				$el: $el,
				el: el,
				$wrapperEl: $wrapperEl,
				wrapperEl: $wrapperEl[0],

				// Classes
				classNames: [],

				// Slides
				slides: $(),
				slidesGrid: [],
				snapGrid: [],
				slidesSizesGrid: [],

				// isDirection
				isHorizontal: function isHorizontal() {
					return swiper.params.direction === 'horizontal';
				},
				isVertical: function isVertical() {
					return swiper.params.direction === 'vertical';
				},
				// RTL
				rtl: (el.dir.toLowerCase() === 'rtl' || $el.css('direction') === 'rtl'),
				rtlTranslate: swiper.params.direction === 'horizontal' && (el.dir.toLowerCase() === 'rtl' || $el.css('direction') === 'rtl'),
				wrongRTL: $wrapperEl.css('display') === '-webkit-box',

				// Indexes
				activeIndex: 0,
				realIndex: 0,

				//
				isBeginning: true,
				isEnd: false,

				// Props
				translate: 0,
				previousTranslate: 0,
				progress: 0,
				velocity: 0,
				animating: false,

				// Locks
				allowSlideNext: swiper.params.allowSlideNext,
				allowSlidePrev: swiper.params.allowSlidePrev,

				// Touch Events
				touchEvents: (function touchEvents() {
					var touch = ['touchstart', 'touchmove', 'touchend', 'touchcancel'];
					var desktop = ['mousedown', 'mousemove', 'mouseup'];
					if (Support.pointerEvents) {
						desktop = ['pointerdown', 'pointermove', 'pointerup'];
					}
					swiper.touchEventsTouch = {
						start: touch[0],
						move: touch[1],
						end: touch[2],
						cancel: touch[3],
					};
					swiper.touchEventsDesktop = {
						start: desktop[0],
						move: desktop[1],
						end: desktop[2],
					};
					return Support.touch || !swiper.params.simulateTouch ? swiper.touchEventsTouch : swiper.touchEventsDesktop;
				}()),
				touchEventsData: {
					isTouched: undefined,
					isMoved: undefined,
					allowTouchCallbacks: undefined,
					touchStartTime: undefined,
					isScrolling: undefined,
					currentTranslate: undefined,
					startTranslate: undefined,
					allowThresholdMove: undefined,
					// Form elements to match
					formElements: 'input, select, option, textarea, button, video, label',
					// Last click time
					lastClickTime: Utils.now(),
					clickTimeout: undefined,
					// Velocities
					velocities: [],
					allowMomentumBounce: undefined,
					isTouchEvent: undefined,
					startMoving: undefined,
				},

				// Clicks
				allowClick: true,

				// Touches
				allowTouchMove: swiper.params.allowTouchMove,

				touches: {
					startX: 0,
					startY: 0,
					currentX: 0,
					currentY: 0,
					diff: 0,
				},

				// Images
				imagesToLoad: [],
				imagesLoaded: 0,

			});

			// Install Modules
			swiper.useModules();

			// Init
			if (swiper.params.init) {
				swiper.init();
			}

			// Return app instance
			return swiper;
		}

		if ( SwiperClass ) Swiper.__proto__ = SwiperClass;
		Swiper.prototype = Object.create( SwiperClass && SwiperClass.prototype );
		Swiper.prototype.constructor = Swiper;

		var staticAccessors = { extendedDefaults: { configurable: true },defaults: { configurable: true },Class: { configurable: true },$: { configurable: true } };

		Swiper.prototype.slidesPerViewDynamic = function slidesPerViewDynamic () {
			var swiper = this;
			var params = swiper.params;
			var slides = swiper.slides;
			var slidesGrid = swiper.slidesGrid;
			var swiperSize = swiper.size;
			var activeIndex = swiper.activeIndex;
			var spv = 1;
			if (params.centeredSlides) {
				var slideSize = slides[activeIndex].swiperSlideSize;
				var breakLoop;
				for (var i = activeIndex + 1; i < slides.length; i += 1) {
					if (slides[i] && !breakLoop) {
						slideSize += slides[i].swiperSlideSize;
						spv += 1;
						if (slideSize > swiperSize) { breakLoop = true; }
					}
				}
				for (var i$1 = activeIndex - 1; i$1 >= 0; i$1 -= 1) {
					if (slides[i$1] && !breakLoop) {
						slideSize += slides[i$1].swiperSlideSize;
						spv += 1;
						if (slideSize > swiperSize) { breakLoop = true; }
					}
				}
			} else {
				for (var i$2 = activeIndex + 1; i$2 < slides.length; i$2 += 1) {
					if (slidesGrid[i$2] - slidesGrid[activeIndex] < swiperSize) {
						spv += 1;
					}
				}
			}
			return spv;
		};

		Swiper.prototype.update = function update () {
			var swiper = this;
			if (!swiper || swiper.destroyed) { return; }
			var snapGrid = swiper.snapGrid;
			var params = swiper.params;
			// Breakpoints
			if (params.breakpoints) {
				swiper.setBreakpoint();
			}
			swiper.updateSize();
			swiper.updateSlides();
			swiper.updateProgress();
			swiper.updateSlidesClasses();

			function setTranslate() {
				var translateValue = swiper.rtlTranslate ? swiper.translate * -1 : swiper.translate;
				var newTranslate = Math.min(Math.max(translateValue, swiper.maxTranslate()), swiper.minTranslate());
				swiper.setTranslate(newTranslate);
				swiper.updateActiveIndex();
				swiper.updateSlidesClasses();
			}
			var translated;
			if (swiper.params.freeMode) {
				setTranslate();
				if (swiper.params.autoHeight) {
					swiper.updateAutoHeight();
				}
			} else {
				if ((swiper.params.slidesPerView === 'auto' || swiper.params.slidesPerView > 1) && swiper.isEnd && !swiper.params.centeredSlides) {
					translated = swiper.slideTo(swiper.slides.length - 1, 0, false, true);
				} else {
					translated = swiper.slideTo(swiper.activeIndex, 0, false, true);
				}
				if (!translated) {
					setTranslate();
				}
			}
			if (params.watchOverflow && snapGrid !== swiper.snapGrid) {
				swiper.checkOverflow();
			}
			swiper.emit('update');
		};

		Swiper.prototype.changeDirection = function changeDirection (newDirection, needUpdate) {
			if ( needUpdate === void 0 ) needUpdate = true;

			var swiper = this;
			var currentDirection = swiper.params.direction;
			if (!newDirection) {
				// eslint-disable-next-line
				newDirection = currentDirection === 'horizontal' ? 'vertical' : 'horizontal';
			}
			if ((newDirection === currentDirection) || (newDirection !== 'horizontal' && newDirection !== 'vertical')) {
				return swiper;
			}

			swiper.$el
				.removeClass(("" + (swiper.params.containerModifierClass) + currentDirection))
				.addClass(("" + (swiper.params.containerModifierClass) + newDirection));

			swiper.params.direction = newDirection;

			swiper.slides.each(function (slideIndex, slideEl) {
				if (newDirection === 'vertical') {
					slideEl.style.width = '';
				} else {
					slideEl.style.height = '';
				}
			});

			swiper.emit('changeDirection');
			if (needUpdate) { swiper.update(); }

			return swiper;
		};

		Swiper.prototype.init = function init () {
			var swiper = this;
			if (swiper.initialized) { return; }

			swiper.emit('beforeInit');

			// Set breakpoint
			if (swiper.params.breakpoints) {
				swiper.setBreakpoint();
			}

			// Add Classes
			swiper.addClasses();

			// Create loop
			if (swiper.params.loop) {
				swiper.loopCreate();
			}

			// Update size
			swiper.updateSize();

			// Update slides
			swiper.updateSlides();

			if (swiper.params.watchOverflow) {
				swiper.checkOverflow();
			}

			// Set Grab Cursor
			if (swiper.params.grabCursor) {
				swiper.setGrabCursor();
			}

			if (swiper.params.preloadImages) {
				swiper.preloadImages();
			}

			// Slide To Initial Slide
			if (swiper.params.loop) {
				swiper.slideTo(swiper.params.initialSlide + swiper.loopedSlides, 0, swiper.params.runCallbacksOnInit);
			} else {
				swiper.slideTo(swiper.params.initialSlide, 0, swiper.params.runCallbacksOnInit);
			}

			// Attach events
			swiper.attachEvents();

			// Init Flag
			swiper.initialized = true;

			// Emit
			swiper.emit('init');
		};

		Swiper.prototype.destroy = function destroy (deleteInstance, cleanStyles) {
			if ( deleteInstance === void 0 ) deleteInstance = true;
			if ( cleanStyles === void 0 ) cleanStyles = true;

			var swiper = this;
			var params = swiper.params;
			var $el = swiper.$el;
			var $wrapperEl = swiper.$wrapperEl;
			var slides = swiper.slides;

			if (typeof swiper.params === 'undefined' || swiper.destroyed) {
				return null;
			}

			swiper.emit('beforeDestroy');

			// Init Flag
			swiper.initialized = false;

			// Detach events
			swiper.detachEvents();

			// Destroy loop
			if (params.loop) {
				swiper.loopDestroy();
			}

			// Cleanup styles
			if (cleanStyles) {
				swiper.removeClasses();
				$el.removeAttr('style');
				$wrapperEl.removeAttr('style');
				if (slides && slides.length) {
					slides
						.removeClass([
							params.slideVisibleClass,
							params.slideActiveClass,
							params.slideNextClass,
							params.slidePrevClass ].join(' '))
						.removeAttr('style')
						.removeAttr('data-swiper-slide-index');
				}
			}

			swiper.emit('destroy');

			// Detach emitter events
			Object.keys(swiper.eventsListeners).forEach(function (eventName) {
				swiper.off(eventName);
			});

			if (deleteInstance !== false) {
				swiper.$el[0].swiper = null;
				swiper.$el.data('swiper', null);
				Utils.deleteProps(swiper);
			}
			swiper.destroyed = true;

			return null;
		};

		Swiper.extendDefaults = function extendDefaults (newDefaults) {
			Utils.extend(extendedDefaults, newDefaults);
		};

		staticAccessors.extendedDefaults.get = function () {
			return extendedDefaults;
		};

		staticAccessors.defaults.get = function () {
			return defaults;
		};

		staticAccessors.Class.get = function () {
			return SwiperClass;
		};

		staticAccessors.$.get = function () {
			return $;
		};

		Object.defineProperties( Swiper, staticAccessors );

		return Swiper;
	}(SwiperClass));

	var Device$1 = {
		name: 'device',
		proto: {
			device: Device,
		},
		static: {
			device: Device,
		},
	};

	var Support$1 = {
		name: 'support',
		proto: {
			support: Support,
		},
		static: {
			support: Support,
		},
	};

	var Browser = (function Browser() {
		function isSafari() {
			var ua = win.navigator.userAgent.toLowerCase();
			return (ua.indexOf('safari') >= 0 && ua.indexOf('chrome') < 0 && ua.indexOf('android') < 0);
		}
		return {
			isEdge: !!win.navigator.userAgent.match(/Edge/g),
			isSafari: isSafari(),
			isUiWebView: /(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/i.test(win.navigator.userAgent),
		};
	}());

	var Browser$1 = {
		name: 'browser',
		proto: {
			browser: Browser,
		},
		static: {
			browser: Browser,
		},
	};

	var Resize = {
		name: 'resize',
		create: function create() {
			var swiper = this;
			Utils.extend(swiper, {
				resize: {
					resizeHandler: function resizeHandler() {
						if (!swiper || swiper.destroyed || !swiper.initialized) { return; }
						swiper.emit('beforeResize');
						swiper.emit('resize');
					},
					orientationChangeHandler: function orientationChangeHandler() {
						if (!swiper || swiper.destroyed || !swiper.initialized) { return; }
						swiper.emit('orientationchange');
					},
				},
			});
		},
		on: {
			init: function init() {
				var swiper = this;
				// Emit resize
				win.addEventListener('resize', swiper.resize.resizeHandler);

				// Emit orientationchange
				win.addEventListener('orientationchange', swiper.resize.orientationChangeHandler);
			},
			destroy: function destroy() {
				var swiper = this;
				win.removeEventListener('resize', swiper.resize.resizeHandler);
				win.removeEventListener('orientationchange', swiper.resize.orientationChangeHandler);
			},
		},
	};

	var Observer = {
		func: win.MutationObserver || win.WebkitMutationObserver,
		attach: function attach(target, options) {
			if ( options === void 0 ) options = {};

			var swiper = this;

			var ObserverFunc = Observer.func;
			var observer = new ObserverFunc(function (mutations) {
				// The observerUpdate event should only be triggered
				// once despite the number of mutations.  Additional
				// triggers are redundant and are very costly
				if (mutations.length === 1) {
					swiper.emit('observerUpdate', mutations[0]);
					return;
				}
				var observerUpdate = function observerUpdate() {
					swiper.emit('observerUpdate', mutations[0]);
				};

				if (win.requestAnimationFrame) {
					win.requestAnimationFrame(observerUpdate);
				} else {
					win.setTimeout(observerUpdate, 0);
				}
			});

			observer.observe(target, {
				attributes: typeof options.attributes === 'undefined' ? true : options.attributes,
				childList: typeof options.childList === 'undefined' ? true : options.childList,
				characterData: typeof options.characterData === 'undefined' ? true : options.characterData,
			});

			swiper.observer.observers.push(observer);
		},
		init: function init() {
			var swiper = this;
			if (!Support.observer || !swiper.params.observer) { return; }
			if (swiper.params.observeParents) {
				var containerParents = swiper.$el.parents();
				for (var i = 0; i < containerParents.length; i += 1) {
					swiper.observer.attach(containerParents[i]);
				}
			}
			// Observe container
			swiper.observer.attach(swiper.$el[0], { childList: swiper.params.observeSlideChildren });

			// Observe wrapper
			swiper.observer.attach(swiper.$wrapperEl[0], { attributes: false });
		},
		destroy: function destroy() {
			var swiper = this;
			swiper.observer.observers.forEach(function (observer) {
				observer.disconnect();
			});
			swiper.observer.observers = [];
		},
	};

	var Observer$1 = {
		name: 'observer',
		params: {
			observer: false,
			observeParents: false,
			observeSlideChildren: false,
		},
		create: function create() {
			var swiper = this;
			Utils.extend(swiper, {
				observer: {
					init: Observer.init.bind(swiper),
					attach: Observer.attach.bind(swiper),
					destroy: Observer.destroy.bind(swiper),
					observers: [],
				},
			});
		},
		on: {
			init: function init() {
				var swiper = this;
				swiper.observer.init();
			},
			destroy: function destroy() {
				var swiper = this;
				swiper.observer.destroy();
			},
		},
	};

	var Virtual = {
		update: function update(force) {
			var swiper = this;
			var ref = swiper.params;
			var slidesPerView = ref.slidesPerView;
			var slidesPerGroup = ref.slidesPerGroup;
			var centeredSlides = ref.centeredSlides;
			var ref$1 = swiper.params.virtual;
			var addSlidesBefore = ref$1.addSlidesBefore;
			var addSlidesAfter = ref$1.addSlidesAfter;
			var ref$2 = swiper.virtual;
			var previousFrom = ref$2.from;
			var previousTo = ref$2.to;
			var slides = ref$2.slides;
			var previousSlidesGrid = ref$2.slidesGrid;
			var renderSlide = ref$2.renderSlide;
			var previousOffset = ref$2.offset;
			swiper.updateActiveIndex();
			var activeIndex = swiper.activeIndex || 0;

			var offsetProp;
			if (swiper.rtlTranslate) { offsetProp = 'right'; }
			else { offsetProp = swiper.isHorizontal() ? 'left' : 'top'; }

			var slidesAfter;
			var slidesBefore;
			if (centeredSlides) {
				slidesAfter = Math.floor(slidesPerView / 2) + slidesPerGroup + addSlidesBefore;
				slidesBefore = Math.floor(slidesPerView / 2) + slidesPerGroup + addSlidesAfter;
			} else {
				slidesAfter = slidesPerView + (slidesPerGroup - 1) + addSlidesBefore;
				slidesBefore = slidesPerGroup + addSlidesAfter;
			}
			var from = Math.max((activeIndex || 0) - slidesBefore, 0);
			var to = Math.min((activeIndex || 0) + slidesAfter, slides.length - 1);
			var offset = (swiper.slidesGrid[from] || 0) - (swiper.slidesGrid[0] || 0);

			Utils.extend(swiper.virtual, {
				from: from,
				to: to,
				offset: offset,
				slidesGrid: swiper.slidesGrid,
			});

			function onRendered() {
				swiper.updateSlides();
				swiper.updateProgress();
				swiper.updateSlidesClasses();
				if (swiper.lazy && swiper.params.lazy.enabled) {
					swiper.lazy.load();
				}
			}

			if (previousFrom === from && previousTo === to && !force) {
				if (swiper.slidesGrid !== previousSlidesGrid && offset !== previousOffset) {
					swiper.slides.css(offsetProp, (offset + "px"));
				}
				swiper.updateProgress();
				return;
			}
			if (swiper.params.virtual.renderExternal) {
				swiper.params.virtual.renderExternal.call(swiper, {
					offset: offset,
					from: from,
					to: to,
					slides: (function getSlides() {
						var slidesToRender = [];
						for (var i = from; i <= to; i += 1) {
							slidesToRender.push(slides[i]);
						}
						return slidesToRender;
					}()),
				});
				onRendered();
				return;
			}
			var prependIndexes = [];
			var appendIndexes = [];
			if (force) {
				swiper.$wrapperEl.find(("." + (swiper.params.slideClass))).remove();
			} else {
				for (var i = previousFrom; i <= previousTo; i += 1) {
					if (i < from || i > to) {
						swiper.$wrapperEl.find(("." + (swiper.params.slideClass) + "[data-swiper-slide-index=\"" + i + "\"]")).remove();
					}
				}
			}
			for (var i$1 = 0; i$1 < slides.length; i$1 += 1) {
				if (i$1 >= from && i$1 <= to) {
					if (typeof previousTo === 'undefined' || force) {
						appendIndexes.push(i$1);
					} else {
						if (i$1 > previousTo) { appendIndexes.push(i$1); }
						if (i$1 < previousFrom) { prependIndexes.push(i$1); }
					}
				}
			}
			appendIndexes.forEach(function (index) {
				swiper.$wrapperEl.append(renderSlide(slides[index], index));
			});
			prependIndexes.sort(function (a, b) { return b - a; }).forEach(function (index) {
				swiper.$wrapperEl.prepend(renderSlide(slides[index], index));
			});
			swiper.$wrapperEl.children('.swiper-slide').css(offsetProp, (offset + "px"));
			onRendered();
		},
		renderSlide: function renderSlide(slide, index) {
			var swiper = this;
			var params = swiper.params.virtual;
			if (params.cache && swiper.virtual.cache[index]) {
				return swiper.virtual.cache[index];
			}
			var $slideEl = params.renderSlide
				? $(params.renderSlide.call(swiper, slide, index))
				: $(("<div class=\"" + (swiper.params.slideClass) + "\" data-swiper-slide-index=\"" + index + "\">" + slide + "</div>"));
			if (!$slideEl.attr('data-swiper-slide-index')) { $slideEl.attr('data-swiper-slide-index', index); }
			if (params.cache) { swiper.virtual.cache[index] = $slideEl; }
			return $slideEl;
		},
		appendSlide: function appendSlide(slides) {
			var swiper = this;
			if (typeof slides === 'object' && 'length' in slides) {
				for (var i = 0; i < slides.length; i += 1) {
					if (slides[i]) { swiper.virtual.slides.push(slides[i]); }
				}
			} else {
				swiper.virtual.slides.push(slides);
			}
			swiper.virtual.update(true);
		},
		prependSlide: function prependSlide(slides) {
			var swiper = this;
			var activeIndex = swiper.activeIndex;
			var newActiveIndex = activeIndex + 1;
			var numberOfNewSlides = 1;

			if (Array.isArray(slides)) {
				for (var i = 0; i < slides.length; i += 1) {
					if (slides[i]) { swiper.virtual.slides.unshift(slides[i]); }
				}
				newActiveIndex = activeIndex + slides.length;
				numberOfNewSlides = slides.length;
			} else {
				swiper.virtual.slides.unshift(slides);
			}
			if (swiper.params.virtual.cache) {
				var cache = swiper.virtual.cache;
				var newCache = {};
				Object.keys(cache).forEach(function (cachedIndex) {
					var $cachedEl = cache[cachedIndex];
					var cachedElIndex = $cachedEl.attr('data-swiper-slide-index');
					if (cachedElIndex) {
						$cachedEl.attr('data-swiper-slide-index', parseInt(cachedElIndex, 10) + 1);
					}
					newCache[parseInt(cachedIndex, 10) + numberOfNewSlides] = $cachedEl;
				});
				swiper.virtual.cache = newCache;
			}
			swiper.virtual.update(true);
			swiper.slideTo(newActiveIndex, 0);
		},
		removeSlide: function removeSlide(slidesIndexes) {
			var swiper = this;
			if (typeof slidesIndexes === 'undefined' || slidesIndexes === null) { return; }
			var activeIndex = swiper.activeIndex;
			if (Array.isArray(slidesIndexes)) {
				for (var i = slidesIndexes.length - 1; i >= 0; i -= 1) {
					swiper.virtual.slides.splice(slidesIndexes[i], 1);
					if (swiper.params.virtual.cache) {
						delete swiper.virtual.cache[slidesIndexes[i]];
					}
					if (slidesIndexes[i] < activeIndex) { activeIndex -= 1; }
					activeIndex = Math.max(activeIndex, 0);
				}
			} else {
				swiper.virtual.slides.splice(slidesIndexes, 1);
				if (swiper.params.virtual.cache) {
					delete swiper.virtual.cache[slidesIndexes];
				}
				if (slidesIndexes < activeIndex) { activeIndex -= 1; }
				activeIndex = Math.max(activeIndex, 0);
			}
			swiper.virtual.update(true);
			swiper.slideTo(activeIndex, 0);
		},
		removeAllSlides: function removeAllSlides() {
			var swiper = this;
			swiper.virtual.slides = [];
			if (swiper.params.virtual.cache) {
				swiper.virtual.cache = {};
			}
			swiper.virtual.update(true);
			swiper.slideTo(0, 0);
		},
	};

	var Virtual$1 = {
		name: 'virtual',
		params: {
			virtual: {
				enabled: false,
				slides: [],
				cache: true,
				renderSlide: null,
				renderExternal: null,
				addSlidesBefore: 0,
				addSlidesAfter: 0,
			},
		},
		create: function create() {
			var swiper = this;
			Utils.extend(swiper, {
				virtual: {
					update: Virtual.update.bind(swiper),
					appendSlide: Virtual.appendSlide.bind(swiper),
					prependSlide: Virtual.prependSlide.bind(swiper),
					removeSlide: Virtual.removeSlide.bind(swiper),
					removeAllSlides: Virtual.removeAllSlides.bind(swiper),
					renderSlide: Virtual.renderSlide.bind(swiper),
					slides: swiper.params.virtual.slides,
					cache: {},
				},
			});
		},
		on: {
			beforeInit: function beforeInit() {
				var swiper = this;
				if (!swiper.params.virtual.enabled) { return; }
				swiper.classNames.push(((swiper.params.containerModifierClass) + "virtual"));
				var overwriteParams = {
					watchSlidesProgress: true,
				};
				Utils.extend(swiper.params, overwriteParams);
				Utils.extend(swiper.originalParams, overwriteParams);

				if (!swiper.params.initialSlide) {
					swiper.virtual.update();
				}
			},
			setTranslate: function setTranslate() {
				var swiper = this;
				if (!swiper.params.virtual.enabled) { return; }
				swiper.virtual.update();
			},
		},
	};

	var Keyboard = {
		handle: function handle(event) {
			var swiper = this;
			var rtl = swiper.rtlTranslate;
			var e = event;
			if (e.originalEvent) { e = e.originalEvent; } // jquery fix
			var kc = e.keyCode || e.charCode;
			// Directions locks
			if (!swiper.allowSlideNext && ((swiper.isHorizontal() && kc === 39) || (swiper.isVertical() && kc === 40) || kc === 34)) {
				return false;
			}
			if (!swiper.allowSlidePrev && ((swiper.isHorizontal() && kc === 37) || (swiper.isVertical() && kc === 38) || kc === 33)) {
				return false;
			}
			if (e.shiftKey || e.altKey || e.ctrlKey || e.metaKey) {
				return undefined;
			}
			if (doc.activeElement && doc.activeElement.nodeName && (doc.activeElement.nodeName.toLowerCase() === 'input' || doc.activeElement.nodeName.toLowerCase() === 'textarea')) {
				return undefined;
			}
			if (swiper.params.keyboard.onlyInViewport && (kc === 33 || kc === 34 || kc === 37 || kc === 39 || kc === 38 || kc === 40)) {
				var inView = false;
				// Check that swiper should be inside of visible area of window
				if (swiper.$el.parents(("." + (swiper.params.slideClass))).length > 0 && swiper.$el.parents(("." + (swiper.params.slideActiveClass))).length === 0) {
					return undefined;
				}
				var windowWidth = win.innerWidth;
				var windowHeight = win.innerHeight;
				var swiperOffset = swiper.$el.offset();
				if (rtl) { swiperOffset.left -= swiper.$el[0].scrollLeft; }
				var swiperCoord = [
					[swiperOffset.left, swiperOffset.top],
					[swiperOffset.left + swiper.width, swiperOffset.top],
					[swiperOffset.left, swiperOffset.top + swiper.height],
					[swiperOffset.left + swiper.width, swiperOffset.top + swiper.height] ];
				for (var i = 0; i < swiperCoord.length; i += 1) {
					var point = swiperCoord[i];
					if (
						point[0] >= 0 && point[0] <= windowWidth
						&& point[1] >= 0 && point[1] <= windowHeight
					) {
						inView = true;
					}
				}
				if (!inView) { return undefined; }
			}
			if (swiper.isHorizontal()) {
				if (kc === 33 || kc === 34 || kc === 37 || kc === 39) {
					if (e.preventDefault) { e.preventDefault(); }
					else { e.returnValue = false; }
				}
				if (((kc === 34 || kc === 39) && !rtl) || ((kc === 33 || kc === 37) && rtl)) { swiper.slideNext(); }
				if (((kc === 33 || kc === 37) && !rtl) || ((kc === 34 || kc === 39) && rtl)) { swiper.slidePrev(); }
			} else {
				if (kc === 33 || kc === 34 || kc === 38 || kc === 40) {
					if (e.preventDefault) { e.preventDefault(); }
					else { e.returnValue = false; }
				}
				if (kc === 34 || kc === 40) { swiper.slideNext(); }
				if (kc === 33 || kc === 38) { swiper.slidePrev(); }
			}
			swiper.emit('keyPress', kc);
			return undefined;
		},
		enable: function enable() {
			var swiper = this;
			if (swiper.keyboard.enabled) { return; }
			$(doc).on('keydown', swiper.keyboard.handle);
			swiper.keyboard.enabled = true;
		},
		disable: function disable() {
			var swiper = this;
			if (!swiper.keyboard.enabled) { return; }
			$(doc).off('keydown', swiper.keyboard.handle);
			swiper.keyboard.enabled = false;
		},
	};

	var Keyboard$1 = {
		name: 'keyboard',
		params: {
			keyboard: {
				enabled: false,
				onlyInViewport: true,
			},
		},
		create: function create() {
			var swiper = this;
			Utils.extend(swiper, {
				keyboard: {
					enabled: false,
					enable: Keyboard.enable.bind(swiper),
					disable: Keyboard.disable.bind(swiper),
					handle: Keyboard.handle.bind(swiper),
				},
			});
		},
		on: {
			init: function init() {
				var swiper = this;
				if (swiper.params.keyboard.enabled) {
					swiper.keyboard.enable();
				}
			},
			destroy: function destroy() {
				var swiper = this;
				if (swiper.keyboard.enabled) {
					swiper.keyboard.disable();
				}
			},
		},
	};

	function isEventSupported() {
		var eventName = 'onwheel';
		var isSupported = eventName in doc;

		if (!isSupported) {
			var element = doc.createElement('div');
			element.setAttribute(eventName, 'return;');
			isSupported = typeof element[eventName] === 'function';
		}

		if (!isSupported
			&& doc.implementation
			&& doc.implementation.hasFeature
			// always returns true in newer browsers as per the standard.
			// @see http://dom.spec.whatwg.org/#dom-domimplementation-hasfeature
			&& doc.implementation.hasFeature('', '') !== true
		) {
			// This is the only way to test support for the `wheel` event in IE9+.
			isSupported = doc.implementation.hasFeature('Events.wheel', '3.0');
		}

		return isSupported;
	}
	var Mousewheel = {
		lastScrollTime: Utils.now(),
		lastEventBeforeSnap: undefined,
		recentWheelEvents: [],
		event: function event() {
			if (win.navigator.userAgent.indexOf('firefox') > -1) { return 'DOMMouseScroll'; }
			return isEventSupported() ? 'wheel' : 'mousewheel';
		},
		normalize: function normalize(e) {
			// Reasonable defaults
			var PIXEL_STEP = 10;
			var LINE_HEIGHT = 40;
			var PAGE_HEIGHT = 800;

			var sX = 0;
			var sY = 0; // spinX, spinY
			var pX = 0;
			var pY = 0; // pixelX, pixelY

			// Legacy
			if ('detail' in e) {
				sY = e.detail;
			}
			if ('wheelDelta' in e) {
				sY = -e.wheelDelta / 120;
			}
			if ('wheelDeltaY' in e) {
				sY = -e.wheelDeltaY / 120;
			}
			if ('wheelDeltaX' in e) {
				sX = -e.wheelDeltaX / 120;
			}

			// side scrolling on FF with DOMMouseScroll
			if ('axis' in e && e.axis === e.HORIZONTAL_AXIS) {
				sX = sY;
				sY = 0;
			}

			pX = sX * PIXEL_STEP;
			pY = sY * PIXEL_STEP;

			if ('deltaY' in e) {
				pY = e.deltaY;
			}
			if ('deltaX' in e) {
				pX = e.deltaX;
			}

			if (e.shiftKey && !pX) { // if user scrolls with shift he wants horizontal scroll
				pX = pY;
				pY = 0;
			}

			if ((pX || pY) && e.deltaMode) {
				if (e.deltaMode === 1) { // delta in LINE units
					pX *= LINE_HEIGHT;
					pY *= LINE_HEIGHT;
				} else { // delta in PAGE units
					pX *= PAGE_HEIGHT;
					pY *= PAGE_HEIGHT;
				}
			}

			// Fall-back if spin cannot be determined
			if (pX && !sX) {
				sX = (pX < 1) ? -1 : 1;
			}
			if (pY && !sY) {
				sY = (pY < 1) ? -1 : 1;
			}

			return {
				spinX: sX,
				spinY: sY,
				pixelX: pX,
				pixelY: pY,
			};
		},
		handleMouseEnter: function handleMouseEnter() {
			var swiper = this;
			swiper.mouseEntered = true;
		},
		handleMouseLeave: function handleMouseLeave() {
			var swiper = this;
			swiper.mouseEntered = false;
		},
		handle: function handle(event) {
			var e = event;
			var swiper = this;
			var params = swiper.params.mousewheel;

			if (swiper.params.cssMode) {
				e.preventDefault();
			}

			var target = swiper.$el;
			if (swiper.params.mousewheel.eventsTarged !== 'container') {
				target = $(swiper.params.mousewheel.eventsTarged);
			}
			if (!swiper.mouseEntered && !target[0].contains(e.target) && !params.releaseOnEdges) { return true; }

			if (e.originalEvent) { e = e.originalEvent; } // jquery fix
			var delta = 0;
			var rtlFactor = swiper.rtlTranslate ? -1 : 1;

			var data = Mousewheel.normalize(e);

			if (params.forceToAxis) {
				if (swiper.isHorizontal()) {
					if (Math.abs(data.pixelX) > Math.abs(data.pixelY)) { delta = data.pixelX * rtlFactor; }
					else { return true; }
				} else if (Math.abs(data.pixelY) > Math.abs(data.pixelX)) { delta = data.pixelY; }
				else { return true; }
			} else {
				delta = Math.abs(data.pixelX) > Math.abs(data.pixelY) ? -data.pixelX * rtlFactor : -data.pixelY;
			}

			if (delta === 0) { return true; }

			if (params.invert) { delta = -delta; }

			if (!swiper.params.freeMode) {
				// Register the new event in a variable which stores the relevant data
				var newEvent = {
					time: Utils.now(),
					delta: Math.abs(delta),
					direction: Math.sign(delta),
					raw: event,
				};

				// Keep the most recent events
				var recentWheelEvents = swiper.mousewheel.recentWheelEvents;
				if (recentWheelEvents.length >= 2) {
					recentWheelEvents.shift(); // only store the last N events
				}
				var prevEvent = recentWheelEvents.length ? recentWheelEvents[recentWheelEvents.length - 1] : undefined;
				recentWheelEvents.push(newEvent);

				// If there is at least one previous recorded event:
				//   If direction has changed or
				//   if the scroll is quicker than the previous one:
				//     Animate the slider.
				// Else (this is the first time the wheel is moved):
				//     Animate the slider.
				if (prevEvent) {
					if (newEvent.direction !== prevEvent.direction || newEvent.delta > prevEvent.delta) {
						swiper.mousewheel.animateSlider(newEvent);
					}
				} else {
					swiper.mousewheel.animateSlider(newEvent);
				}

				// If it's time to release the scroll:
				//   Return now so you don't hit the preventDefault.
				if (swiper.mousewheel.releaseScroll(newEvent)) {
					return true;
				}
			} else {
				// Freemode or scrollContainer:

				// If we recently snapped after a momentum scroll, then ignore wheel events
				// to give time for the deceleration to finish. Stop ignoring after 500 msecs
				// or if it's a new scroll (larger delta or inverse sign as last event before
				// an end-of-momentum snap).
				var newEvent$1 = { time: Utils.now(), delta: Math.abs(delta), direction: Math.sign(delta) };
				var ref = swiper.mousewheel;
				var lastEventBeforeSnap = ref.lastEventBeforeSnap;
				var ignoreWheelEvents = lastEventBeforeSnap
					&& newEvent$1.time < lastEventBeforeSnap.time + 500
					&& newEvent$1.delta <= lastEventBeforeSnap.delta
					&& newEvent$1.direction === lastEventBeforeSnap.direction;
				if (!ignoreWheelEvents) {
					swiper.mousewheel.lastEventBeforeSnap = undefined;

					if (swiper.params.loop) {
						swiper.loopFix();
					}
					var position = swiper.getTranslate() + (delta * params.sensitivity);
					var wasBeginning = swiper.isBeginning;
					var wasEnd = swiper.isEnd;

					if (position >= swiper.minTranslate()) { position = swiper.minTranslate(); }
					if (position <= swiper.maxTranslate()) { position = swiper.maxTranslate(); }

					swiper.setTransition(0);
					swiper.setTranslate(position);
					swiper.updateProgress();
					swiper.updateActiveIndex();
					swiper.updateSlidesClasses();

					if ((!wasBeginning && swiper.isBeginning) || (!wasEnd && swiper.isEnd)) {
						swiper.updateSlidesClasses();
					}

					if (swiper.params.freeModeSticky) {
						// When wheel scrolling starts with sticky (aka snap) enabled, then detect
						// the end of a momentum scroll by storing recent (N=15?) wheel events.
						// 1. do all N events have decreasing or same (absolute value) delta?
						// 2. did all N events arrive in the last M (M=500?) msecs?
						// 3. does the earliest event have an (absolute value) delta that's
						//    at least P (P=1?) larger than the most recent event's delta?
						// 4. does the latest event have a delta that's smaller than Q (Q=6?) pixels?
						// If 1-4 are "yes" then we're near the end of a momuntum scroll deceleration.
						// Snap immediately and ignore remaining wheel events in this scroll.
						// See comment above for "remaining wheel events in this scroll" determination.
						// If 1-4 aren't satisfied, then wait to snap until 500ms after the last event.
						clearTimeout(swiper.mousewheel.timeout);
						swiper.mousewheel.timeout = undefined;
						var recentWheelEvents$1 = swiper.mousewheel.recentWheelEvents;
						if (recentWheelEvents$1.length >= 15) {
							recentWheelEvents$1.shift(); // only store the last N events
						}
						var prevEvent$1 = recentWheelEvents$1.length ? recentWheelEvents$1[recentWheelEvents$1.length - 1] : undefined;
						var firstEvent = recentWheelEvents$1[0];
						recentWheelEvents$1.push(newEvent$1);
						if (prevEvent$1 && (newEvent$1.delta > prevEvent$1.delta || newEvent$1.direction !== prevEvent$1.direction)) {
							// Increasing or reverse-sign delta means the user started scrolling again. Clear the wheel event log.
							recentWheelEvents$1.splice(0);
						} else if (recentWheelEvents$1.length >= 15
								&& newEvent$1.time - firstEvent.time < 500
								&& firstEvent.delta - newEvent$1.delta >= 1
								&& newEvent$1.delta <= 6
						) {
							// We're at the end of the deceleration of a momentum scroll, so there's no need
							// to wait for more events. Snap ASAP on the next tick.
							// Also, because there's some remaining momentum we'll bias the snap in the
							// direction of the ongoing scroll because it's better UX for the scroll to snap
							// in the same direction as the scroll instead of reversing to snap.  Therefore,
							// if it's already scrolled more than 20% in the current direction, keep going.
							var snapToThreshold = delta > 0 ? 0.8 : 0.2;
							swiper.mousewheel.lastEventBeforeSnap = newEvent$1;
							recentWheelEvents$1.splice(0);
							swiper.mousewheel.timeout = Utils.nextTick(function () {
								swiper.slideToClosest(swiper.params.speed, true, undefined, snapToThreshold);
							}, 0); // no delay; move on next tick
						}
						if (!swiper.mousewheel.timeout) {
							// if we get here, then we haven't detected the end of a momentum scroll, so
							// we'll consider a scroll "complete" when there haven't been any wheel events
							// for 500ms.
							swiper.mousewheel.timeout = Utils.nextTick(function () {
								var snapToThreshold = 0.5;
								swiper.mousewheel.lastEventBeforeSnap = newEvent$1;
								recentWheelEvents$1.splice(0);
								swiper.slideToClosest(swiper.params.speed, true, undefined, snapToThreshold);
							}, 500);
						}
					}

					// Emit event
					if (!ignoreWheelEvents) { swiper.emit('scroll', e); }

					// Stop autoplay
					if (swiper.params.autoplay && swiper.params.autoplayDisableOnInteraction) { swiper.autoplay.stop(); }
					// Return page scroll on edge positions
					if (position === swiper.minTranslate() || position === swiper.maxTranslate()) { return true; }
				}
			}

			if (e.preventDefault) { e.preventDefault(); }
			else { e.returnValue = false; }
			return false;
		},
		animateSlider: function animateSlider(newEvent) {
			var swiper = this;
			// If the movement is NOT big enough and
			// if the last time the user scrolled was too close to the current one (avoid continuously triggering the slider):
			//   Don't go any further (avoid insignificant scroll movement).
			if (newEvent.delta >= 6 && Utils.now() - swiper.mousewheel.lastScrollTime < 60) {
				// Return false as a default
				return true;
			}
			// If user is scrolling towards the end:
			//   If the slider hasn't hit the latest slide or
			//   if the slider is a loop and
			//   if the slider isn't moving right now:
			//     Go to next slide and
			//     emit a scroll event.
			// Else (the user is scrolling towards the beginning) and
			// if the slider hasn't hit the first slide or
			// if the slider is a loop and
			// if the slider isn't moving right now:
			//   Go to prev slide and
			//   emit a scroll event.
			if (newEvent.direction < 0) {
				if ((!swiper.isEnd || swiper.params.loop) && !swiper.animating) {
					swiper.slideNext();
					swiper.emit('scroll', newEvent.raw);
				}
			} else if ((!swiper.isBeginning || swiper.params.loop) && !swiper.animating) {
				swiper.slidePrev();
				swiper.emit('scroll', newEvent.raw);
			}
			// If you got here is because an animation has been triggered so store the current time
			swiper.mousewheel.lastScrollTime = (new win.Date()).getTime();
			// Return false as a default
			return false;
		},
		releaseScroll: function releaseScroll(newEvent) {
			var swiper = this;
			var params = swiper.params.mousewheel;
			if (newEvent.direction < 0) {
				if (swiper.isEnd && !swiper.params.loop && params.releaseOnEdges) {
					// Return true to animate scroll on edges
					return true;
				}
			} else if (swiper.isBeginning && !swiper.params.loop && params.releaseOnEdges) {
				// Return true to animate scroll on edges
				return true;
			}
			return false;
		},
		enable: function enable() {
			var swiper = this;
			var event = Mousewheel.event();
			if (swiper.params.cssMode) {
				swiper.wrapperEl.removeEventListener(event, swiper.mousewheel.handle);
				return true;
			}
			if (!event) { return false; }
			if (swiper.mousewheel.enabled) { return false; }
			var target = swiper.$el;
			if (swiper.params.mousewheel.eventsTarged !== 'container') {
				target = $(swiper.params.mousewheel.eventsTarged);
			}
			target.on('mouseenter', swiper.mousewheel.handleMouseEnter);
			target.on('mouseleave', swiper.mousewheel.handleMouseLeave);
			target.on(event, swiper.mousewheel.handle);
			swiper.mousewheel.enabled = true;
			return true;
		},
		disable: function disable() {
			var swiper = this;
			var event = Mousewheel.event();
			if (swiper.params.cssMode) {
				swiper.wrapperEl.addEventListener(event, swiper.mousewheel.handle);
				return true;
			}
			if (!event) { return false; }
			if (!swiper.mousewheel.enabled) { return false; }
			var target = swiper.$el;
			if (swiper.params.mousewheel.eventsTarged !== 'container') {
				target = $(swiper.params.mousewheel.eventsTarged);
			}
			target.off(event, swiper.mousewheel.handle);
			swiper.mousewheel.enabled = false;
			return true;
		},
	};

	var Mousewheel$1 = {
		name: 'mousewheel',
		params: {
			mousewheel: {
				enabled: false,
				releaseOnEdges: false,
				invert: false,
				forceToAxis: false,
				sensitivity: 1,
				eventsTarged: 'container',
			},
		},
		create: function create() {
			var swiper = this;
			Utils.extend(swiper, {
				mousewheel: {
					enabled: false,
					enable: Mousewheel.enable.bind(swiper),
					disable: Mousewheel.disable.bind(swiper),
					handle: Mousewheel.handle.bind(swiper),
					handleMouseEnter: Mousewheel.handleMouseEnter.bind(swiper),
					handleMouseLeave: Mousewheel.handleMouseLeave.bind(swiper),
					animateSlider: Mousewheel.animateSlider.bind(swiper),
					releaseScroll: Mousewheel.releaseScroll.bind(swiper),
					lastScrollTime: Utils.now(),
					lastEventBeforeSnap: undefined,
					recentWheelEvents: [],
				},
			});
		},
		on: {
			init: function init() {
				var swiper = this;
				if (!swiper.params.mousewheel.enabled && swiper.params.cssMode) {
					swiper.mousewheel.disable();
				}
				if (swiper.params.mousewheel.enabled) { swiper.mousewheel.enable(); }
			},
			destroy: function destroy() {
				var swiper = this;
				if (swiper.params.cssMode) {
					swiper.mousewheel.enable();
				}
				if (swiper.mousewheel.enabled) { swiper.mousewheel.disable(); }
			},
		},
	};

	var Navigation = {
		update: function update() {
			// Update Navigation Buttons
			var swiper = this;
			var params = swiper.params.navigation;

			if (swiper.params.loop) { return; }
			var ref = swiper.navigation;
			var $nextEl = ref.$nextEl;
			var $prevEl = ref.$prevEl;

			if ($prevEl && $prevEl.length > 0) {
				if (swiper.isBeginning) {
					$prevEl.addClass(params.disabledClass);
				} else {
					$prevEl.removeClass(params.disabledClass);
				}
				$prevEl[swiper.params.watchOverflow && swiper.isLocked ? 'addClass' : 'removeClass'](params.lockClass);
			}
			if ($nextEl && $nextEl.length > 0) {
				if (swiper.isEnd) {
					$nextEl.addClass(params.disabledClass);
				} else {
					$nextEl.removeClass(params.disabledClass);
				}
				$nextEl[swiper.params.watchOverflow && swiper.isLocked ? 'addClass' : 'removeClass'](params.lockClass);
			}
		},
		onPrevClick: function onPrevClick(e) {
			var swiper = this;
			e.preventDefault();
			if (swiper.isBeginning && !swiper.params.loop) { return; }
			swiper.slidePrev();
		},
		onNextClick: function onNextClick(e) {
			var swiper = this;
			e.preventDefault();
			if (swiper.isEnd && !swiper.params.loop) { return; }
			swiper.slideNext();
		},
		init: function init() {
			var swiper = this;
			var params = swiper.params.navigation;
			if (!(params.nextEl || params.prevEl)) { return; }

			var $nextEl;
			var $prevEl;
			if (params.nextEl) {
				$nextEl = $(params.nextEl);
				if (
					swiper.params.uniqueNavElements
					&& typeof params.nextEl === 'string'
					&& $nextEl.length > 1
					&& swiper.$el.find(params.nextEl).length === 1
				) {
					$nextEl = swiper.$el.find(params.nextEl);
				}
			}
			if (params.prevEl) {
				$prevEl = $(params.prevEl);
				if (
					swiper.params.uniqueNavElements
					&& typeof params.prevEl === 'string'
					&& $prevEl.length > 1
					&& swiper.$el.find(params.prevEl).length === 1
				) {
					$prevEl = swiper.$el.find(params.prevEl);
				}
			}

			if ($nextEl && $nextEl.length > 0) {
				$nextEl.on('click', swiper.navigation.onNextClick);
			}
			if ($prevEl && $prevEl.length > 0) {
				$prevEl.on('click', swiper.navigation.onPrevClick);
			}

			Utils.extend(swiper.navigation, {
				$nextEl: $nextEl,
				nextEl: $nextEl && $nextEl[0],
				$prevEl: $prevEl,
				prevEl: $prevEl && $prevEl[0],
			});
		},
		destroy: function destroy() {
			var swiper = this;
			var ref = swiper.navigation;
			var $nextEl = ref.$nextEl;
			var $prevEl = ref.$prevEl;
			if ($nextEl && $nextEl.length) {
				$nextEl.off('click', swiper.navigation.onNextClick);
				$nextEl.removeClass(swiper.params.navigation.disabledClass);
			}
			if ($prevEl && $prevEl.length) {
				$prevEl.off('click', swiper.navigation.onPrevClick);
				$prevEl.removeClass(swiper.params.navigation.disabledClass);
			}
		},
	};

	var Navigation$1 = {
		name: 'navigation',
		params: {
			navigation: {
				nextEl: null,
				prevEl: null,

				hideOnClick: false,
				disabledClass: 'swiper-button-disabled',
				hiddenClass: 'swiper-button-hidden',
				lockClass: 'swiper-button-lock',
			},
		},
		create: function create() {
			var swiper = this;
			Utils.extend(swiper, {
				navigation: {
					init: Navigation.init.bind(swiper),
					update: Navigation.update.bind(swiper),
					destroy: Navigation.destroy.bind(swiper),
					onNextClick: Navigation.onNextClick.bind(swiper),
					onPrevClick: Navigation.onPrevClick.bind(swiper),
				},
			});
		},
		on: {
			init: function init() {
				var swiper = this;
				swiper.navigation.init();
				swiper.navigation.update();
			},
			toEdge: function toEdge() {
				var swiper = this;
				swiper.navigation.update();
			},
			fromEdge: function fromEdge() {
				var swiper = this;
				swiper.navigation.update();
			},
			destroy: function destroy() {
				var swiper = this;
				swiper.navigation.destroy();
			},
			click: function click(e) {
				var swiper = this;
				var ref = swiper.navigation;
				var $nextEl = ref.$nextEl;
				var $prevEl = ref.$prevEl;
				if (
					swiper.params.navigation.hideOnClick
					&& !$(e.target).is($prevEl)
					&& !$(e.target).is($nextEl)
				) {
					var isHidden;
					if ($nextEl) {
						isHidden = $nextEl.hasClass(swiper.params.navigation.hiddenClass);
					} else if ($prevEl) {
						isHidden = $prevEl.hasClass(swiper.params.navigation.hiddenClass);
					}
					if (isHidden === true) {
						swiper.emit('navigationShow', swiper);
					} else {
						swiper.emit('navigationHide', swiper);
					}
					if ($nextEl) {
						$nextEl.toggleClass(swiper.params.navigation.hiddenClass);
					}
					if ($prevEl) {
						$prevEl.toggleClass(swiper.params.navigation.hiddenClass);
					}
				}
			},
		},
	};

	var Pagination = {
		update: function update() {
			// Render || Update Pagination bullets/items
			var swiper = this;
			var rtl = swiper.rtl;
			var params = swiper.params.pagination;
			if (!params.el || !swiper.pagination.el || !swiper.pagination.$el || swiper.pagination.$el.length === 0) { return; }
			var slidesLength = swiper.virtual && swiper.params.virtual.enabled ? swiper.virtual.slides.length : swiper.slides.length;
			var $el = swiper.pagination.$el;
			// Current/Total
			var current;
			var total = swiper.params.loop ? Math.ceil((slidesLength - (swiper.loopedSlides * 2)) / swiper.params.slidesPerGroup) : swiper.snapGrid.length;
			if (swiper.params.loop) {
				current = Math.ceil((swiper.activeIndex - swiper.loopedSlides) / swiper.params.slidesPerGroup);
				if (current > slidesLength - 1 - (swiper.loopedSlides * 2)) {
					current -= (slidesLength - (swiper.loopedSlides * 2));
				}
				if (current > total - 1) { current -= total; }
				if (current < 0 && swiper.params.paginationType !== 'bullets') { current = total + current; }
			} else if (typeof swiper.snapIndex !== 'undefined') {
				current = swiper.snapIndex;
			} else {
				current = swiper.activeIndex || 0;
			}
			// Types
			if (params.type === 'bullets' && swiper.pagination.bullets && swiper.pagination.bullets.length > 0) {
				var bullets = swiper.pagination.bullets;
				var firstIndex;
				var lastIndex;
				var midIndex;
				if (params.dynamicBullets) {
					swiper.pagination.bulletSize = bullets.eq(0)[swiper.isHorizontal() ? 'outerWidth' : 'outerHeight'](true);
					$el.css(swiper.isHorizontal() ? 'width' : 'height', ((swiper.pagination.bulletSize * (params.dynamicMainBullets + 4)) + "px"));
					if (params.dynamicMainBullets > 1 && swiper.previousIndex !== undefined) {
						swiper.pagination.dynamicBulletIndex += (current - swiper.previousIndex);
						if (swiper.pagination.dynamicBulletIndex > (params.dynamicMainBullets - 1)) {
							swiper.pagination.dynamicBulletIndex = params.dynamicMainBullets - 1;
						} else if (swiper.pagination.dynamicBulletIndex < 0) {
							swiper.pagination.dynamicBulletIndex = 0;
						}
					}
					firstIndex = current - swiper.pagination.dynamicBulletIndex;
					lastIndex = firstIndex + (Math.min(bullets.length, params.dynamicMainBullets) - 1);
					midIndex = (lastIndex + firstIndex) / 2;
				}
				bullets.removeClass(((params.bulletActiveClass) + " " + (params.bulletActiveClass) + "-next " + (params.bulletActiveClass) + "-next-next " + (params.bulletActiveClass) + "-prev " + (params.bulletActiveClass) + "-prev-prev " + (params.bulletActiveClass) + "-main"));
				if ($el.length > 1) {
					bullets.each(function (index, bullet) {
						var $bullet = $(bullet);
						var bulletIndex = $bullet.index();
						if (bulletIndex === current) {
							$bullet.addClass(params.bulletActiveClass);
						}
						if (params.dynamicBullets) {
							if (bulletIndex >= firstIndex && bulletIndex <= lastIndex) {
								$bullet.addClass(((params.bulletActiveClass) + "-main"));
							}
							if (bulletIndex === firstIndex) {
								$bullet
									.prev()
									.addClass(((params.bulletActiveClass) + "-prev"))
									.prev()
									.addClass(((params.bulletActiveClass) + "-prev-prev"));
							}
							if (bulletIndex === lastIndex) {
								$bullet
									.next()
									.addClass(((params.bulletActiveClass) + "-next"))
									.next()
									.addClass(((params.bulletActiveClass) + "-next-next"));
							}
						}
					});
				} else {
					var $bullet = bullets.eq(current);
					var bulletIndex = $bullet.index();
					$bullet.addClass(params.bulletActiveClass);
					if (params.dynamicBullets) {
						var $firstDisplayedBullet = bullets.eq(firstIndex);
						var $lastDisplayedBullet = bullets.eq(lastIndex);
						for (var i = firstIndex; i <= lastIndex; i += 1) {
							bullets.eq(i).addClass(((params.bulletActiveClass) + "-main"));
						}
						if (swiper.params.loop) {
							if (bulletIndex >= bullets.length - params.dynamicMainBullets) {
								for (var i$1 = params.dynamicMainBullets; i$1 >= 0; i$1 -= 1) {
									bullets.eq(bullets.length - i$1).addClass(((params.bulletActiveClass) + "-main"));
								}
								bullets.eq(bullets.length - params.dynamicMainBullets - 1).addClass(((params.bulletActiveClass) + "-prev"));
							} else {
								$firstDisplayedBullet
									.prev()
									.addClass(((params.bulletActiveClass) + "-prev"))
									.prev()
									.addClass(((params.bulletActiveClass) + "-prev-prev"));
								$lastDisplayedBullet
									.next()
									.addClass(((params.bulletActiveClass) + "-next"))
									.next()
									.addClass(((params.bulletActiveClass) + "-next-next"));
							}
						} else {
							$firstDisplayedBullet
								.prev()
								.addClass(((params.bulletActiveClass) + "-prev"))
								.prev()
								.addClass(((params.bulletActiveClass) + "-prev-prev"));
							$lastDisplayedBullet
								.next()
								.addClass(((params.bulletActiveClass) + "-next"))
								.next()
								.addClass(((params.bulletActiveClass) + "-next-next"));
						}
					}
				}
				if (params.dynamicBullets) {
					var dynamicBulletsLength = Math.min(bullets.length, params.dynamicMainBullets + 4);
					var bulletsOffset = (((swiper.pagination.bulletSize * dynamicBulletsLength) - (swiper.pagination.bulletSize)) / 2) - (midIndex * swiper.pagination.bulletSize);
					var offsetProp = rtl ? 'right' : 'left';
					bullets.css(swiper.isHorizontal() ? offsetProp : 'top', (bulletsOffset + "px"));
				}
			}
			if (params.type === 'fraction') {
				$el.find(("." + (params.currentClass))).text(params.formatFractionCurrent(current + 1));
				$el.find(("." + (params.totalClass))).text(params.formatFractionTotal(total));
			}
			if (params.type === 'progressbar') {
				var progressbarDirection;
				if (params.progressbarOpposite) {
					progressbarDirection = swiper.isHorizontal() ? 'vertical' : 'horizontal';
				} else {
					progressbarDirection = swiper.isHorizontal() ? 'horizontal' : 'vertical';
				}
				var scale = (current + 1) / total;
				var scaleX = 1;
				var scaleY = 1;
				if (progressbarDirection === 'horizontal') {
					scaleX = scale;
				} else {
					scaleY = scale;
				}
				$el.find(("." + (params.progressbarFillClass))).transform(("translate3d(0,0,0) scaleX(" + scaleX + ") scaleY(" + scaleY + ")")).transition(swiper.params.speed);
			}
			if (params.type === 'custom' && params.renderCustom) {
				$el.html(params.renderCustom(swiper, current + 1, total));
				swiper.emit('paginationRender', swiper, $el[0]);
			} else {
				swiper.emit('paginationUpdate', swiper, $el[0]);
			}
			$el[swiper.params.watchOverflow && swiper.isLocked ? 'addClass' : 'removeClass'](params.lockClass);
		},
		render: function render() {
			// Render Container
			var swiper = this;
			var params = swiper.params.pagination;
			if (!params.el || !swiper.pagination.el || !swiper.pagination.$el || swiper.pagination.$el.length === 0) { return; }
			var slidesLength = swiper.virtual && swiper.params.virtual.enabled ? swiper.virtual.slides.length : swiper.slides.length;

			var $el = swiper.pagination.$el;
			var paginationHTML = '';
			if (params.type === 'bullets') {
				var numberOfBullets = swiper.params.loop ? Math.ceil((slidesLength - (swiper.loopedSlides * 2)) / swiper.params.slidesPerGroup) : swiper.snapGrid.length;
				for (var i = 0; i < numberOfBullets; i += 1) {
					if (params.renderBullet) {
						paginationHTML += params.renderBullet.call(swiper, i, params.bulletClass);
					} else {
						paginationHTML += "<" + (params.bulletElement) + " class=\"" + (params.bulletClass) + "\"></" + (params.bulletElement) + ">";
					}
				}
				$el.html(paginationHTML);
				swiper.pagination.bullets = $el.find(("." + (params.bulletClass)));
			}
			if (params.type === 'fraction') {
				if (params.renderFraction) {
					paginationHTML = params.renderFraction.call(swiper, params.currentClass, params.totalClass);
				} else {
					paginationHTML = "<span class=\"" + (params.currentClass) + "\"></span>"
					+ ' / '
					+ "<span class=\"" + (params.totalClass) + "\"></span>";
				}
				$el.html(paginationHTML);
			}
			if (params.type === 'progressbar') {
				if (params.renderProgressbar) {
					paginationHTML = params.renderProgressbar.call(swiper, params.progressbarFillClass);
				} else {
					paginationHTML = "<span class=\"" + (params.progressbarFillClass) + "\"></span>";
				}
				$el.html(paginationHTML);
			}
			if (params.type !== 'custom') {
				swiper.emit('paginationRender', swiper.pagination.$el[0]);
			}
		},
		init: function init() {
			var swiper = this;
			var params = swiper.params.pagination;
			if (!params.el) { return; }

			var $el = $(params.el);
			if ($el.length === 0) { return; }

			if (
				swiper.params.uniqueNavElements
				&& typeof params.el === 'string'
				&& $el.length > 1
				&& swiper.$el.find(params.el).length === 1
			) {
				$el = swiper.$el.find(params.el);
			}

			if (params.type === 'bullets' && params.clickable) {
				$el.addClass(params.clickableClass);
			}

			$el.addClass(params.modifierClass + params.type);

			if (params.type === 'bullets' && params.dynamicBullets) {
				$el.addClass(("" + (params.modifierClass) + (params.type) + "-dynamic"));
				swiper.pagination.dynamicBulletIndex = 0;
				if (params.dynamicMainBullets < 1) {
					params.dynamicMainBullets = 1;
				}
			}
			if (params.type === 'progressbar' && params.progressbarOpposite) {
				$el.addClass(params.progressbarOppositeClass);
			}

			if (params.clickable) {
				$el.on('click', ("." + (params.bulletClass)), function onClick(e) {
					e.preventDefault();
					var index = $(this).index() * swiper.params.slidesPerGroup;
					if (swiper.params.loop) { index += swiper.loopedSlides; }
					swiper.slideTo(index);
				});
			}

			Utils.extend(swiper.pagination, {
				$el: $el,
				el: $el[0],
			});
		},
		destroy: function destroy() {
			var swiper = this;
			var params = swiper.params.pagination;
			if (!params.el || !swiper.pagination.el || !swiper.pagination.$el || swiper.pagination.$el.length === 0) { return; }
			var $el = swiper.pagination.$el;

			$el.removeClass(params.hiddenClass);
			$el.removeClass(params.modifierClass + params.type);
			if (swiper.pagination.bullets) { swiper.pagination.bullets.removeClass(params.bulletActiveClass); }
			if (params.clickable) {
				$el.off('click', ("." + (params.bulletClass)));
			}
		},
	};

	var Pagination$1 = {
		name: 'pagination',
		params: {
			pagination: {
				el: null,
				bulletElement: 'span',
				clickable: false,
				hideOnClick: false,
				renderBullet: null,
				renderProgressbar: null,
				renderFraction: null,
				renderCustom: null,
				progressbarOpposite: false,
				type: 'bullets', // 'bullets' or 'progressbar' or 'fraction' or 'custom'
				dynamicBullets: false,
				dynamicMainBullets: 1,
				formatFractionCurrent: function (number) { return number; },
				formatFractionTotal: function (number) { return number; },
				bulletClass: 'swiper-pagination-bullet',
				bulletActiveClass: 'swiper-pagination-bullet-active',
				modifierClass: 'swiper-pagination-', // NEW
				currentClass: 'swiper-pagination-current',
				totalClass: 'swiper-pagination-total',
				hiddenClass: 'swiper-pagination-hidden',
				progressbarFillClass: 'swiper-pagination-progressbar-fill',
				progressbarOppositeClass: 'swiper-pagination-progressbar-opposite',
				clickableClass: 'swiper-pagination-clickable', // NEW
				lockClass: 'swiper-pagination-lock',
			},
		},
		create: function create() {
			var swiper = this;
			Utils.extend(swiper, {
				pagination: {
					init: Pagination.init.bind(swiper),
					render: Pagination.render.bind(swiper),
					update: Pagination.update.bind(swiper),
					destroy: Pagination.destroy.bind(swiper),
					dynamicBulletIndex: 0,
				},
			});
		},
		on: {
			init: function init() {
				var swiper = this;
				swiper.pagination.init();
				swiper.pagination.render();
				swiper.pagination.update();
			},
			activeIndexChange: function activeIndexChange() {
				var swiper = this;
				if (swiper.params.loop) {
					swiper.pagination.update();
				} else if (typeof swiper.snapIndex === 'undefined') {
					swiper.pagination.update();
				}
			},
			snapIndexChange: function snapIndexChange() {
				var swiper = this;
				if (!swiper.params.loop) {
					swiper.pagination.update();
				}
			},
			slidesLengthChange: function slidesLengthChange() {
				var swiper = this;
				if (swiper.params.loop) {
					swiper.pagination.render();
					swiper.pagination.update();
				}
			},
			snapGridLengthChange: function snapGridLengthChange() {
				var swiper = this;
				if (!swiper.params.loop) {
					swiper.pagination.render();
					swiper.pagination.update();
				}
			},
			destroy: function destroy() {
				var swiper = this;
				swiper.pagination.destroy();
			},
			click: function click(e) {
				var swiper = this;
				if (
					swiper.params.pagination.el
					&& swiper.params.pagination.hideOnClick
					&& swiper.pagination.$el.length > 0
					&& !$(e.target).hasClass(swiper.params.pagination.bulletClass)
				) {
					var isHidden = swiper.pagination.$el.hasClass(swiper.params.pagination.hiddenClass);
					if (isHidden === true) {
						swiper.emit('paginationShow', swiper);
					} else {
						swiper.emit('paginationHide', swiper);
					}
					swiper.pagination.$el.toggleClass(swiper.params.pagination.hiddenClass);
				}
			},
		},
	};

	var Scrollbar = {
		setTranslate: function setTranslate() {
			var swiper = this;
			if (!swiper.params.scrollbar.el || !swiper.scrollbar.el) { return; }
			var scrollbar = swiper.scrollbar;
			var rtl = swiper.rtlTranslate;
			var progress = swiper.progress;
			var dragSize = scrollbar.dragSize;
			var trackSize = scrollbar.trackSize;
			var $dragEl = scrollbar.$dragEl;
			var $el = scrollbar.$el;
			var params = swiper.params.scrollbar;

			var newSize = dragSize;
			var newPos = (trackSize - dragSize) * progress;
			if (rtl) {
				newPos = -newPos;
				if (newPos > 0) {
					newSize = dragSize - newPos;
					newPos = 0;
				} else if (-newPos + dragSize > trackSize) {
					newSize = trackSize + newPos;
				}
			} else if (newPos < 0) {
				newSize = dragSize + newPos;
				newPos = 0;
			} else if (newPos + dragSize > trackSize) {
				newSize = trackSize - newPos;
			}
			if (swiper.isHorizontal()) {
				$dragEl.transform(("translate3d(" + newPos + "px, 0, 0)"));
				$dragEl[0].style.width = newSize + "px";
			} else {
				$dragEl.transform(("translate3d(0px, " + newPos + "px, 0)"));
				$dragEl[0].style.height = newSize + "px";
			}
			if (params.hide) {
				clearTimeout(swiper.scrollbar.timeout);
				$el[0].style.opacity = 1;
				swiper.scrollbar.timeout = setTimeout(function () {
					$el[0].style.opacity = 0;
					$el.transition(400);
				}, 1000);
			}
		},
		setTransition: function setTransition(duration) {
			var swiper = this;
			if (!swiper.params.scrollbar.el || !swiper.scrollbar.el) { return; }
			swiper.scrollbar.$dragEl.transition(duration);
		},
		updateSize: function updateSize() {
			var swiper = this;
			if (!swiper.params.scrollbar.el || !swiper.scrollbar.el) { return; }

			var scrollbar = swiper.scrollbar;
			var $dragEl = scrollbar.$dragEl;
			var $el = scrollbar.$el;

			$dragEl[0].style.width = '';
			$dragEl[0].style.height = '';
			var trackSize = swiper.isHorizontal() ? $el[0].offsetWidth : $el[0].offsetHeight;

			var divider = swiper.size / swiper.virtualSize;
			var moveDivider = divider * (trackSize / swiper.size);
			var dragSize;
			if (swiper.params.scrollbar.dragSize === 'auto') {
				dragSize = trackSize * divider;
			} else {
				dragSize = parseInt(swiper.params.scrollbar.dragSize, 10);
			}

			if (swiper.isHorizontal()) {
				$dragEl[0].style.width = dragSize + "px";
			} else {
				$dragEl[0].style.height = dragSize + "px";
			}

			if (divider >= 1) {
				$el[0].style.display = 'none';
			} else {
				$el[0].style.display = '';
			}
			if (swiper.params.scrollbar.hide) {
				$el[0].style.opacity = 0;
			}
			Utils.extend(scrollbar, {
				trackSize: trackSize,
				divider: divider,
				moveDivider: moveDivider,
				dragSize: dragSize,
			});
			scrollbar.$el[swiper.params.watchOverflow && swiper.isLocked ? 'addClass' : 'removeClass'](swiper.params.scrollbar.lockClass);
		},
		getPointerPosition: function getPointerPosition(e) {
			var swiper = this;
			if (swiper.isHorizontal()) {
				return ((e.type === 'touchstart' || e.type === 'touchmove') ? e.targetTouches[0].clientX : e.clientX);
			}
			return ((e.type === 'touchstart' || e.type === 'touchmove') ? e.targetTouches[0].clientY : e.clientY);
		},
		setDragPosition: function setDragPosition(e) {
			var swiper = this;
			var scrollbar = swiper.scrollbar;
			var rtl = swiper.rtlTranslate;
			var $el = scrollbar.$el;
			var dragSize = scrollbar.dragSize;
			var trackSize = scrollbar.trackSize;
			var dragStartPos = scrollbar.dragStartPos;

			var positionRatio;
			positionRatio = ((scrollbar.getPointerPosition(e)) - $el.offset()[swiper.isHorizontal() ? 'left' : 'top']
				- (dragStartPos !== null ? dragStartPos : dragSize / 2)) / (trackSize - dragSize);
			positionRatio = Math.max(Math.min(positionRatio, 1), 0);
			if (rtl) {
				positionRatio = 1 - positionRatio;
			}

			var position = swiper.minTranslate() + ((swiper.maxTranslate() - swiper.minTranslate()) * positionRatio);

			swiper.updateProgress(position);
			swiper.setTranslate(position);
			swiper.updateActiveIndex();
			swiper.updateSlidesClasses();
		},
		onDragStart: function onDragStart(e) {
			var swiper = this;
			var params = swiper.params.scrollbar;
			var scrollbar = swiper.scrollbar;
			var $wrapperEl = swiper.$wrapperEl;
			var $el = scrollbar.$el;
			var $dragEl = scrollbar.$dragEl;
			swiper.scrollbar.isTouched = true;
			swiper.scrollbar.dragStartPos = (e.target === $dragEl[0] || e.target === $dragEl)
				? scrollbar.getPointerPosition(e) - e.target.getBoundingClientRect()[swiper.isHorizontal() ? 'left' : 'top'] : null;
			e.preventDefault();
			e.stopPropagation();

			$wrapperEl.transition(100);
			$dragEl.transition(100);
			scrollbar.setDragPosition(e);

			clearTimeout(swiper.scrollbar.dragTimeout);

			$el.transition(0);
			if (params.hide) {
				$el.css('opacity', 1);
			}
			if (swiper.params.cssMode) {
				swiper.$wrapperEl.css('scroll-snap-type', 'none');
			}
			swiper.emit('scrollbarDragStart', e);
		},
		onDragMove: function onDragMove(e) {
			var swiper = this;
			var scrollbar = swiper.scrollbar;
			var $wrapperEl = swiper.$wrapperEl;
			var $el = scrollbar.$el;
			var $dragEl = scrollbar.$dragEl;

			if (!swiper.scrollbar.isTouched) { return; }
			if (e.preventDefault) { e.preventDefault(); }
			else { e.returnValue = false; }
			scrollbar.setDragPosition(e);
			$wrapperEl.transition(0);
			$el.transition(0);
			$dragEl.transition(0);
			swiper.emit('scrollbarDragMove', e);
		},
		onDragEnd: function onDragEnd(e) {
			var swiper = this;

			var params = swiper.params.scrollbar;
			var scrollbar = swiper.scrollbar;
			var $wrapperEl = swiper.$wrapperEl;
			var $el = scrollbar.$el;

			if (!swiper.scrollbar.isTouched) { return; }
			swiper.scrollbar.isTouched = false;
			if (swiper.params.cssMode) {
				swiper.$wrapperEl.css('scroll-snap-type', '');
				$wrapperEl.transition('');
			}
			if (params.hide) {
				clearTimeout(swiper.scrollbar.dragTimeout);
				swiper.scrollbar.dragTimeout = Utils.nextTick(function () {
					$el.css('opacity', 0);
					$el.transition(400);
				}, 1000);
			}
			swiper.emit('scrollbarDragEnd', e);
			if (params.snapOnRelease) {
				swiper.slideToClosest();
			}
		},
		enableDraggable: function enableDraggable() {
			var swiper = this;
			if (!swiper.params.scrollbar.el) { return; }
			var scrollbar = swiper.scrollbar;
			var touchEventsTouch = swiper.touchEventsTouch;
			var touchEventsDesktop = swiper.touchEventsDesktop;
			var params = swiper.params;
			var $el = scrollbar.$el;
			var target = $el[0];
			var activeListener = Support.passiveListener && params.passiveListeners ? { passive: false, capture: false } : false;
			var passiveListener = Support.passiveListener && params.passiveListeners ? { passive: true, capture: false } : false;
			if (!Support.touch) {
				target.addEventListener(touchEventsDesktop.start, swiper.scrollbar.onDragStart, activeListener);
				doc.addEventListener(touchEventsDesktop.move, swiper.scrollbar.onDragMove, activeListener);
				doc.addEventListener(touchEventsDesktop.end, swiper.scrollbar.onDragEnd, passiveListener);
			} else {
				target.addEventListener(touchEventsTouch.start, swiper.scrollbar.onDragStart, activeListener);
				target.addEventListener(touchEventsTouch.move, swiper.scrollbar.onDragMove, activeListener);
				target.addEventListener(touchEventsTouch.end, swiper.scrollbar.onDragEnd, passiveListener);
			}
		},
		disableDraggable: function disableDraggable() {
			var swiper = this;
			if (!swiper.params.scrollbar.el) { return; }
			var scrollbar = swiper.scrollbar;
			var touchEventsTouch = swiper.touchEventsTouch;
			var touchEventsDesktop = swiper.touchEventsDesktop;
			var params = swiper.params;
			var $el = scrollbar.$el;
			var target = $el[0];
			var activeListener = Support.passiveListener && params.passiveListeners ? { passive: false, capture: false } : false;
			var passiveListener = Support.passiveListener && params.passiveListeners ? { passive: true, capture: false } : false;
			if (!Support.touch) {
				target.removeEventListener(touchEventsDesktop.start, swiper.scrollbar.onDragStart, activeListener);
				doc.removeEventListener(touchEventsDesktop.move, swiper.scrollbar.onDragMove, activeListener);
				doc.removeEventListener(touchEventsDesktop.end, swiper.scrollbar.onDragEnd, passiveListener);
			} else {
				target.removeEventListener(touchEventsTouch.start, swiper.scrollbar.onDragStart, activeListener);
				target.removeEventListener(touchEventsTouch.move, swiper.scrollbar.onDragMove, activeListener);
				target.removeEventListener(touchEventsTouch.end, swiper.scrollbar.onDragEnd, passiveListener);
			}
		},
		init: function init() {
			var swiper = this;
			if (!swiper.params.scrollbar.el) { return; }
			var scrollbar = swiper.scrollbar;
			var $swiperEl = swiper.$el;
			var params = swiper.params.scrollbar;

			var $el = $(params.el);
			if (swiper.params.uniqueNavElements && typeof params.el === 'string' && $el.length > 1 && $swiperEl.find(params.el).length === 1) {
				$el = $swiperEl.find(params.el);
			}

			var $dragEl = $el.find(("." + (swiper.params.scrollbar.dragClass)));
			if ($dragEl.length === 0) {
				$dragEl = $(("<div class=\"" + (swiper.params.scrollbar.dragClass) + "\"></div>"));
				$el.append($dragEl);
			}

			Utils.extend(scrollbar, {
				$el: $el,
				el: $el[0],
				$dragEl: $dragEl,
				dragEl: $dragEl[0],
			});

			if (params.draggable) {
				scrollbar.enableDraggable();
			}
		},
		destroy: function destroy() {
			var swiper = this;
			swiper.scrollbar.disableDraggable();
		},
	};

	var Scrollbar$1 = {
		name: 'scrollbar',
		params: {
			scrollbar: {
				el: null,
				dragSize: 'auto',
				hide: false,
				draggable: false,
				snapOnRelease: true,
				lockClass: 'swiper-scrollbar-lock',
				dragClass: 'swiper-scrollbar-drag',
			},
		},
		create: function create() {
			var swiper = this;
			Utils.extend(swiper, {
				scrollbar: {
					init: Scrollbar.init.bind(swiper),
					destroy: Scrollbar.destroy.bind(swiper),
					updateSize: Scrollbar.updateSize.bind(swiper),
					setTranslate: Scrollbar.setTranslate.bind(swiper),
					setTransition: Scrollbar.setTransition.bind(swiper),
					enableDraggable: Scrollbar.enableDraggable.bind(swiper),
					disableDraggable: Scrollbar.disableDraggable.bind(swiper),
					setDragPosition: Scrollbar.setDragPosition.bind(swiper),
					getPointerPosition: Scrollbar.getPointerPosition.bind(swiper),
					onDragStart: Scrollbar.onDragStart.bind(swiper),
					onDragMove: Scrollbar.onDragMove.bind(swiper),
					onDragEnd: Scrollbar.onDragEnd.bind(swiper),
					isTouched: false,
					timeout: null,
					dragTimeout: null,
				},
			});
		},
		on: {
			init: function init() {
				var swiper = this;
				swiper.scrollbar.init();
				swiper.scrollbar.updateSize();
				swiper.scrollbar.setTranslate();
			},
			update: function update() {
				var swiper = this;
				swiper.scrollbar.updateSize();
			},
			resize: function resize() {
				var swiper = this;
				swiper.scrollbar.updateSize();
			},
			observerUpdate: function observerUpdate() {
				var swiper = this;
				swiper.scrollbar.updateSize();
			},
			setTranslate: function setTranslate() {
				var swiper = this;
				swiper.scrollbar.setTranslate();
			},
			setTransition: function setTransition(duration) {
				var swiper = this;
				swiper.scrollbar.setTransition(duration);
			},
			destroy: function destroy() {
				var swiper = this;
				swiper.scrollbar.destroy();
			},
		},
	};

	var Parallax = {
		setTransform: function setTransform(el, progress) {
			var swiper = this;
			var rtl = swiper.rtl;

			var $el = $(el);
			var rtlFactor = rtl ? -1 : 1;

			var p = $el.attr('data-swiper-parallax') || '0';
			var x = $el.attr('data-swiper-parallax-x');
			var y = $el.attr('data-swiper-parallax-y');
			var scale = $el.attr('data-swiper-parallax-scale');
			var opacity = $el.attr('data-swiper-parallax-opacity');

			if (x || y) {
				x = x || '0';
				y = y || '0';
			} else if (swiper.isHorizontal()) {
				x = p;
				y = '0';
			} else {
				y = p;
				x = '0';
			}

			if ((x).indexOf('%') >= 0) {
				x = (parseInt(x, 10) * progress * rtlFactor) + "%";
			} else {
				x = (x * progress * rtlFactor) + "px";
			}
			if ((y).indexOf('%') >= 0) {
				y = (parseInt(y, 10) * progress) + "%";
			} else {
				y = (y * progress) + "px";
			}

			if (typeof opacity !== 'undefined' && opacity !== null) {
				var currentOpacity = opacity - ((opacity - 1) * (1 - Math.abs(progress)));
				$el[0].style.opacity = currentOpacity;
			}
			if (typeof scale === 'undefined' || scale === null) {
				$el.transform(("translate3d(" + x + ", " + y + ", 0px)"));
			} else {
				var currentScale = scale - ((scale - 1) * (1 - Math.abs(progress)));
				$el.transform(("translate3d(" + x + ", " + y + ", 0px) scale(" + currentScale + ")"));
			}
		},
		setTranslate: function setTranslate() {
			var swiper = this;
			var $el = swiper.$el;
			var slides = swiper.slides;
			var progress = swiper.progress;
			var snapGrid = swiper.snapGrid;
			$el.children('[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y], [data-swiper-parallax-opacity], [data-swiper-parallax-scale]')
				.each(function (index, el) {
					swiper.parallax.setTransform(el, progress);
				});
			slides.each(function (slideIndex, slideEl) {
				var slideProgress = slideEl.progress;
				if (swiper.params.slidesPerGroup > 1 && swiper.params.slidesPerView !== 'auto') {
					slideProgress += Math.ceil(slideIndex / 2) - (progress * (snapGrid.length - 1));
				}
				slideProgress = Math.min(Math.max(slideProgress, -1), 1);
				$(slideEl).find('[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y], [data-swiper-parallax-opacity], [data-swiper-parallax-scale]')
					.each(function (index, el) {
						swiper.parallax.setTransform(el, slideProgress);
					});
			});
		},
		setTransition: function setTransition(duration) {
			if ( duration === void 0 ) duration = this.params.speed;

			var swiper = this;
			var $el = swiper.$el;
			$el.find('[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y], [data-swiper-parallax-opacity], [data-swiper-parallax-scale]')
				.each(function (index, parallaxEl) {
					var $parallaxEl = $(parallaxEl);
					var parallaxDuration = parseInt($parallaxEl.attr('data-swiper-parallax-duration'), 10) || duration;
					if (duration === 0) { parallaxDuration = 0; }
					$parallaxEl.transition(parallaxDuration);
				});
		},
	};

	var Parallax$1 = {
		name: 'parallax',
		params: {
			parallax: {
				enabled: false,
			},
		},
		create: function create() {
			var swiper = this;
			Utils.extend(swiper, {
				parallax: {
					setTransform: Parallax.setTransform.bind(swiper),
					setTranslate: Parallax.setTranslate.bind(swiper),
					setTransition: Parallax.setTransition.bind(swiper),
				},
			});
		},
		on: {
			beforeInit: function beforeInit() {
				var swiper = this;
				if (!swiper.params.parallax.enabled) { return; }
				swiper.params.watchSlidesProgress = true;
				swiper.originalParams.watchSlidesProgress = true;
			},
			init: function init() {
				var swiper = this;
				if (!swiper.params.parallax.enabled) { return; }
				swiper.parallax.setTranslate();
			},
			setTranslate: function setTranslate() {
				var swiper = this;
				if (!swiper.params.parallax.enabled) { return; }
				swiper.parallax.setTranslate();
			},
			setTransition: function setTransition(duration) {
				var swiper = this;
				if (!swiper.params.parallax.enabled) { return; }
				swiper.parallax.setTransition(duration);
			},
		},
	};

	var Zoom = {
		// Calc Scale From Multi-touches
		getDistanceBetweenTouches: function getDistanceBetweenTouches(e) {
			if (e.targetTouches.length < 2) { return 1; }
			var x1 = e.targetTouches[0].pageX;
			var y1 = e.targetTouches[0].pageY;
			var x2 = e.targetTouches[1].pageX;
			var y2 = e.targetTouches[1].pageY;
			var distance = Math.sqrt((Math.pow( (x2 - x1), 2 )) + (Math.pow( (y2 - y1), 2 )));
			return distance;
		},
		// Events
		onGestureStart: function onGestureStart(e) {
			var swiper = this;
			var params = swiper.params.zoom;
			var zoom = swiper.zoom;
			var gesture = zoom.gesture;
			zoom.fakeGestureTouched = false;
			zoom.fakeGestureMoved = false;
			if (!Support.gestures) {
				if (e.type !== 'touchstart' || (e.type === 'touchstart' && e.targetTouches.length < 2)) {
					return;
				}
				zoom.fakeGestureTouched = true;
				gesture.scaleStart = Zoom.getDistanceBetweenTouches(e);
			}
			if (!gesture.$slideEl || !gesture.$slideEl.length) {
				gesture.$slideEl = $(e.target).closest(("." + (swiper.params.slideClass)));
				if (gesture.$slideEl.length === 0) { gesture.$slideEl = swiper.slides.eq(swiper.activeIndex); }
				gesture.$imageEl = gesture.$slideEl.find('img, svg, canvas, picture, .swiper-zoom-target');
				gesture.$imageWrapEl = gesture.$imageEl.parent(("." + (params.containerClass)));
				gesture.maxRatio = gesture.$imageWrapEl.attr('data-swiper-zoom') || params.maxRatio;
				if (gesture.$imageWrapEl.length === 0) {
					gesture.$imageEl = undefined;
					return;
				}
			}
			gesture.$imageEl.transition(0);
			swiper.zoom.isScaling = true;
		},
		onGestureChange: function onGestureChange(e) {
			var swiper = this;
			var params = swiper.params.zoom;
			var zoom = swiper.zoom;
			var gesture = zoom.gesture;
			if (!Support.gestures) {
				if (e.type !== 'touchmove' || (e.type === 'touchmove' && e.targetTouches.length < 2)) {
					return;
				}
				zoom.fakeGestureMoved = true;
				gesture.scaleMove = Zoom.getDistanceBetweenTouches(e);
			}
			if (!gesture.$imageEl || gesture.$imageEl.length === 0) { return; }
			if (Support.gestures) {
				zoom.scale = e.scale * zoom.currentScale;
			} else {
				zoom.scale = (gesture.scaleMove / gesture.scaleStart) * zoom.currentScale;
			}
			if (zoom.scale > gesture.maxRatio) {
				zoom.scale = (gesture.maxRatio - 1) + (Math.pow( ((zoom.scale - gesture.maxRatio) + 1), 0.5 ));
			}
			if (zoom.scale < params.minRatio) {
				zoom.scale = (params.minRatio + 1) - (Math.pow( ((params.minRatio - zoom.scale) + 1), 0.5 ));
			}
			gesture.$imageEl.transform(("translate3d(0,0,0) scale(" + (zoom.scale) + ")"));
		},
		onGestureEnd: function onGestureEnd(e) {
			var swiper = this;
			var params = swiper.params.zoom;
			var zoom = swiper.zoom;
			var gesture = zoom.gesture;
			if (!Support.gestures) {
				if (!zoom.fakeGestureTouched || !zoom.fakeGestureMoved) {
					return;
				}
				if (e.type !== 'touchend' || (e.type === 'touchend' && e.changedTouches.length < 2 && !Device.android)) {
					return;
				}
				zoom.fakeGestureTouched = false;
				zoom.fakeGestureMoved = false;
			}
			if (!gesture.$imageEl || gesture.$imageEl.length === 0) { return; }
			zoom.scale = Math.max(Math.min(zoom.scale, gesture.maxRatio), params.minRatio);
			gesture.$imageEl.transition(swiper.params.speed).transform(("translate3d(0,0,0) scale(" + (zoom.scale) + ")"));
			zoom.currentScale = zoom.scale;
			zoom.isScaling = false;
			if (zoom.scale === 1) { gesture.$slideEl = undefined; }
		},
		onTouchStart: function onTouchStart(e) {
			var swiper = this;
			var zoom = swiper.zoom;
			var gesture = zoom.gesture;
			var image = zoom.image;
			if (!gesture.$imageEl || gesture.$imageEl.length === 0) { return; }
			if (image.isTouched) { return; }
			if (Device.android) { e.preventDefault(); }
			image.isTouched = true;
			image.touchesStart.x = e.type === 'touchstart' ? e.targetTouches[0].pageX : e.pageX;
			image.touchesStart.y = e.type === 'touchstart' ? e.targetTouches[0].pageY : e.pageY;
		},
		onTouchMove: function onTouchMove(e) {
			var swiper = this;
			var zoom = swiper.zoom;
			var gesture = zoom.gesture;
			var image = zoom.image;
			var velocity = zoom.velocity;
			if (!gesture.$imageEl || gesture.$imageEl.length === 0) { return; }
			swiper.allowClick = false;
			if (!image.isTouched || !gesture.$slideEl) { return; }

			if (!image.isMoved) {
				image.width = gesture.$imageEl[0].offsetWidth;
				image.height = gesture.$imageEl[0].offsetHeight;
				image.startX = Utils.getTranslate(gesture.$imageWrapEl[0], 'x') || 0;
				image.startY = Utils.getTranslate(gesture.$imageWrapEl[0], 'y') || 0;
				gesture.slideWidth = gesture.$slideEl[0].offsetWidth;
				gesture.slideHeight = gesture.$slideEl[0].offsetHeight;
				gesture.$imageWrapEl.transition(0);
				if (swiper.rtl) {
					image.startX = -image.startX;
					image.startY = -image.startY;
				}
			}
			// Define if we need image drag
			var scaledWidth = image.width * zoom.scale;
			var scaledHeight = image.height * zoom.scale;

			if (scaledWidth < gesture.slideWidth && scaledHeight < gesture.slideHeight) { return; }

			image.minX = Math.min(((gesture.slideWidth / 2) - (scaledWidth / 2)), 0);
			image.maxX = -image.minX;
			image.minY = Math.min(((gesture.slideHeight / 2) - (scaledHeight / 2)), 0);
			image.maxY = -image.minY;

			image.touchesCurrent.x = e.type === 'touchmove' ? e.targetTouches[0].pageX : e.pageX;
			image.touchesCurrent.y = e.type === 'touchmove' ? e.targetTouches[0].pageY : e.pageY;

			if (!image.isMoved && !zoom.isScaling) {
				if (
					swiper.isHorizontal()
					&& (
						(Math.floor(image.minX) === Math.floor(image.startX) && image.touchesCurrent.x < image.touchesStart.x)
						|| (Math.floor(image.maxX) === Math.floor(image.startX) && image.touchesCurrent.x > image.touchesStart.x)
					)
				) {
					image.isTouched = false;
					return;
				} if (
					!swiper.isHorizontal()
					&& (
						(Math.floor(image.minY) === Math.floor(image.startY) && image.touchesCurrent.y < image.touchesStart.y)
						|| (Math.floor(image.maxY) === Math.floor(image.startY) && image.touchesCurrent.y > image.touchesStart.y)
					)
				) {
					image.isTouched = false;
					return;
				}
			}
			e.preventDefault();
			e.stopPropagation();

			image.isMoved = true;
			image.currentX = (image.touchesCurrent.x - image.touchesStart.x) + image.startX;
			image.currentY = (image.touchesCurrent.y - image.touchesStart.y) + image.startY;

			if (image.currentX < image.minX) {
				image.currentX = (image.minX + 1) - (Math.pow( ((image.minX - image.currentX) + 1), 0.8 ));
			}
			if (image.currentX > image.maxX) {
				image.currentX = (image.maxX - 1) + (Math.pow( ((image.currentX - image.maxX) + 1), 0.8 ));
			}

			if (image.currentY < image.minY) {
				image.currentY = (image.minY + 1) - (Math.pow( ((image.minY - image.currentY) + 1), 0.8 ));
			}
			if (image.currentY > image.maxY) {
				image.currentY = (image.maxY - 1) + (Math.pow( ((image.currentY - image.maxY) + 1), 0.8 ));
			}

			// Velocity
			if (!velocity.prevPositionX) { velocity.prevPositionX = image.touchesCurrent.x; }
			if (!velocity.prevPositionY) { velocity.prevPositionY = image.touchesCurrent.y; }
			if (!velocity.prevTime) { velocity.prevTime = Date.now(); }
			velocity.x = (image.touchesCurrent.x - velocity.prevPositionX) / (Date.now() - velocity.prevTime) / 2;
			velocity.y = (image.touchesCurrent.y - velocity.prevPositionY) / (Date.now() - velocity.prevTime) / 2;
			if (Math.abs(image.touchesCurrent.x - velocity.prevPositionX) < 2) { velocity.x = 0; }
			if (Math.abs(image.touchesCurrent.y - velocity.prevPositionY) < 2) { velocity.y = 0; }
			velocity.prevPositionX = image.touchesCurrent.x;
			velocity.prevPositionY = image.touchesCurrent.y;
			velocity.prevTime = Date.now();

			gesture.$imageWrapEl.transform(("translate3d(" + (image.currentX) + "px, " + (image.currentY) + "px,0)"));
		},
		onTouchEnd: function onTouchEnd() {
			var swiper = this;
			var zoom = swiper.zoom;
			var gesture = zoom.gesture;
			var image = zoom.image;
			var velocity = zoom.velocity;
			if (!gesture.$imageEl || gesture.$imageEl.length === 0) { return; }
			if (!image.isTouched || !image.isMoved) {
				image.isTouched = false;
				image.isMoved = false;
				return;
			}
			image.isTouched = false;
			image.isMoved = false;
			var momentumDurationX = 300;
			var momentumDurationY = 300;
			var momentumDistanceX = velocity.x * momentumDurationX;
			var newPositionX = image.currentX + momentumDistanceX;
			var momentumDistanceY = velocity.y * momentumDurationY;
			var newPositionY = image.currentY + momentumDistanceY;

			// Fix duration
			if (velocity.x !== 0) { momentumDurationX = Math.abs((newPositionX - image.currentX) / velocity.x); }
			if (velocity.y !== 0) { momentumDurationY = Math.abs((newPositionY - image.currentY) / velocity.y); }
			var momentumDuration = Math.max(momentumDurationX, momentumDurationY);

			image.currentX = newPositionX;
			image.currentY = newPositionY;

			// Define if we need image drag
			var scaledWidth = image.width * zoom.scale;
			var scaledHeight = image.height * zoom.scale;
			image.minX = Math.min(((gesture.slideWidth / 2) - (scaledWidth / 2)), 0);
			image.maxX = -image.minX;
			image.minY = Math.min(((gesture.slideHeight / 2) - (scaledHeight / 2)), 0);
			image.maxY = -image.minY;
			image.currentX = Math.max(Math.min(image.currentX, image.maxX), image.minX);
			image.currentY = Math.max(Math.min(image.currentY, image.maxY), image.minY);

			gesture.$imageWrapEl.transition(momentumDuration).transform(("translate3d(" + (image.currentX) + "px, " + (image.currentY) + "px,0)"));
		},
		onTransitionEnd: function onTransitionEnd() {
			var swiper = this;
			var zoom = swiper.zoom;
			var gesture = zoom.gesture;
			if (gesture.$slideEl && swiper.previousIndex !== swiper.activeIndex) {
				gesture.$imageEl.transform('translate3d(0,0,0) scale(1)');
				gesture.$imageWrapEl.transform('translate3d(0,0,0)');

				zoom.scale = 1;
				zoom.currentScale = 1;

				gesture.$slideEl = undefined;
				gesture.$imageEl = undefined;
				gesture.$imageWrapEl = undefined;
			}
		},
		// Toggle Zoom
		toggle: function toggle(e) {
			var swiper = this;
			var zoom = swiper.zoom;

			if (zoom.scale && zoom.scale !== 1) {
				// Zoom Out
				zoom.out();
			} else {
				// Zoom In
				zoom.in(e);
			}
		},
		in: function in$1(e) {
			var swiper = this;

			var zoom = swiper.zoom;
			var params = swiper.params.zoom;
			var gesture = zoom.gesture;
			var image = zoom.image;

			if (!gesture.$slideEl) {
				gesture.$slideEl = swiper.slides.eq(swiper.activeIndex);
				gesture.$imageEl = gesture.$slideEl.find('img, svg, canvas, picture, .swiper-zoom-target');
				gesture.$imageWrapEl = gesture.$imageEl.parent(("." + (params.containerClass)));
			}
			if (!gesture.$imageEl || gesture.$imageEl.length === 0) { return; }

			gesture.$slideEl.addClass(("" + (params.zoomedSlideClass)));

			var touchX;
			var touchY;
			var offsetX;
			var offsetY;
			var diffX;
			var diffY;
			var translateX;
			var translateY;
			var imageWidth;
			var imageHeight;
			var scaledWidth;
			var scaledHeight;
			var translateMinX;
			var translateMinY;
			var translateMaxX;
			var translateMaxY;
			var slideWidth;
			var slideHeight;

			if (typeof image.touchesStart.x === 'undefined' && e) {
				touchX = e.type === 'touchend' ? e.changedTouches[0].pageX : e.pageX;
				touchY = e.type === 'touchend' ? e.changedTouches[0].pageY : e.pageY;
			} else {
				touchX = image.touchesStart.x;
				touchY = image.touchesStart.y;
			}

			zoom.scale = gesture.$imageWrapEl.attr('data-swiper-zoom') || params.maxRatio;
			zoom.currentScale = gesture.$imageWrapEl.attr('data-swiper-zoom') || params.maxRatio;
			if (e) {
				slideWidth = gesture.$slideEl[0].offsetWidth;
				slideHeight = gesture.$slideEl[0].offsetHeight;
				offsetX = gesture.$slideEl.offset().left;
				offsetY = gesture.$slideEl.offset().top;
				diffX = (offsetX + (slideWidth / 2)) - touchX;
				diffY = (offsetY + (slideHeight / 2)) - touchY;

				imageWidth = gesture.$imageEl[0].offsetWidth;
				imageHeight = gesture.$imageEl[0].offsetHeight;
				scaledWidth = imageWidth * zoom.scale;
				scaledHeight = imageHeight * zoom.scale;

				translateMinX = Math.min(((slideWidth / 2) - (scaledWidth / 2)), 0);
				translateMinY = Math.min(((slideHeight / 2) - (scaledHeight / 2)), 0);
				translateMaxX = -translateMinX;
				translateMaxY = -translateMinY;

				translateX = diffX * zoom.scale;
				translateY = diffY * zoom.scale;

				if (translateX < translateMinX) {
					translateX = translateMinX;
				}
				if (translateX > translateMaxX) {
					translateX = translateMaxX;
				}

				if (translateY < translateMinY) {
					translateY = translateMinY;
				}
				if (translateY > translateMaxY) {
					translateY = translateMaxY;
				}
			} else {
				translateX = 0;
				translateY = 0;
			}
			gesture.$imageWrapEl.transition(300).transform(("translate3d(" + translateX + "px, " + translateY + "px,0)"));
			gesture.$imageEl.transition(300).transform(("translate3d(0,0,0) scale(" + (zoom.scale) + ")"));
		},
		out: function out() {
			var swiper = this;

			var zoom = swiper.zoom;
			var params = swiper.params.zoom;
			var gesture = zoom.gesture;

			if (!gesture.$slideEl) {
				gesture.$slideEl = swiper.slides.eq(swiper.activeIndex);
				gesture.$imageEl = gesture.$slideEl.find('img, svg, canvas, picture, .swiper-zoom-target');
				gesture.$imageWrapEl = gesture.$imageEl.parent(("." + (params.containerClass)));
			}
			if (!gesture.$imageEl || gesture.$imageEl.length === 0) { return; }

			zoom.scale = 1;
			zoom.currentScale = 1;
			gesture.$imageWrapEl.transition(300).transform('translate3d(0,0,0)');
			gesture.$imageEl.transition(300).transform('translate3d(0,0,0) scale(1)');
			gesture.$slideEl.removeClass(("" + (params.zoomedSlideClass)));
			gesture.$slideEl = undefined;
		},
		// Attach/Detach Events
		enable: function enable() {
			var swiper = this;
			var zoom = swiper.zoom;
			if (zoom.enabled) { return; }
			zoom.enabled = true;

			var passiveListener = swiper.touchEvents.start === 'touchstart' && Support.passiveListener && swiper.params.passiveListeners ? { passive: true, capture: false } : false;
			var activeListenerWithCapture = Support.passiveListener ? { passive: false, capture: true } : true;

			var slideSelector = "." + (swiper.params.slideClass);

			// Scale image
			if (Support.gestures) {
				swiper.$wrapperEl.on('gesturestart', slideSelector, zoom.onGestureStart, passiveListener);
				swiper.$wrapperEl.on('gesturechange', slideSelector, zoom.onGestureChange, passiveListener);
				swiper.$wrapperEl.on('gestureend', slideSelector, zoom.onGestureEnd, passiveListener);
			} else if (swiper.touchEvents.start === 'touchstart') {
				swiper.$wrapperEl.on(swiper.touchEvents.start, slideSelector, zoom.onGestureStart, passiveListener);
				swiper.$wrapperEl.on(swiper.touchEvents.move, slideSelector, zoom.onGestureChange, activeListenerWithCapture);
				swiper.$wrapperEl.on(swiper.touchEvents.end, slideSelector, zoom.onGestureEnd, passiveListener);
				if (swiper.touchEvents.cancel) {
					swiper.$wrapperEl.on(swiper.touchEvents.cancel, slideSelector, zoom.onGestureEnd, passiveListener);
				}
			}

			// Move image
			swiper.$wrapperEl.on(swiper.touchEvents.move, ("." + (swiper.params.zoom.containerClass)), zoom.onTouchMove, activeListenerWithCapture);
		},
		disable: function disable() {
			var swiper = this;
			var zoom = swiper.zoom;
			if (!zoom.enabled) { return; }

			swiper.zoom.enabled = false;

			var passiveListener = swiper.touchEvents.start === 'touchstart' && Support.passiveListener && swiper.params.passiveListeners ? { passive: true, capture: false } : false;
			var activeListenerWithCapture = Support.passiveListener ? { passive: false, capture: true } : true;

			var slideSelector = "." + (swiper.params.slideClass);

			// Scale image
			if (Support.gestures) {
				swiper.$wrapperEl.off('gesturestart', slideSelector, zoom.onGestureStart, passiveListener);
				swiper.$wrapperEl.off('gesturechange', slideSelector, zoom.onGestureChange, passiveListener);
				swiper.$wrapperEl.off('gestureend', slideSelector, zoom.onGestureEnd, passiveListener);
			} else if (swiper.touchEvents.start === 'touchstart') {
				swiper.$wrapperEl.off(swiper.touchEvents.start, slideSelector, zoom.onGestureStart, passiveListener);
				swiper.$wrapperEl.off(swiper.touchEvents.move, slideSelector, zoom.onGestureChange, activeListenerWithCapture);
				swiper.$wrapperEl.off(swiper.touchEvents.end, slideSelector, zoom.onGestureEnd, passiveListener);
				if (swiper.touchEvents.cancel) {
					swiper.$wrapperEl.off(swiper.touchEvents.cancel, slideSelector, zoom.onGestureEnd, passiveListener);
				}
			}

			// Move image
			swiper.$wrapperEl.off(swiper.touchEvents.move, ("." + (swiper.params.zoom.containerClass)), zoom.onTouchMove, activeListenerWithCapture);
		},
	};

	var Zoom$1 = {
		name: 'zoom',
		params: {
			zoom: {
				enabled: false,
				maxRatio: 3,
				minRatio: 1,
				toggle: true,
				containerClass: 'swiper-zoom-container',
				zoomedSlideClass: 'swiper-slide-zoomed',
			},
		},
		create: function create() {
			var swiper = this;
			var zoom = {
				enabled: false,
				scale: 1,
				currentScale: 1,
				isScaling: false,
				gesture: {
					$slideEl: undefined,
					slideWidth: undefined,
					slideHeight: undefined,
					$imageEl: undefined,
					$imageWrapEl: undefined,
					maxRatio: 3,
				},
				image: {
					isTouched: undefined,
					isMoved: undefined,
					currentX: undefined,
					currentY: undefined,
					minX: undefined,
					minY: undefined,
					maxX: undefined,
					maxY: undefined,
					width: undefined,
					height: undefined,
					startX: undefined,
					startY: undefined,
					touchesStart: {},
					touchesCurrent: {},
				},
				velocity: {
					x: undefined,
					y: undefined,
					prevPositionX: undefined,
					prevPositionY: undefined,
					prevTime: undefined,
				},
			};

			('onGestureStart onGestureChange onGestureEnd onTouchStart onTouchMove onTouchEnd onTransitionEnd toggle enable disable in out').split(' ').forEach(function (methodName) {
				zoom[methodName] = Zoom[methodName].bind(swiper);
			});
			Utils.extend(swiper, {
				zoom: zoom,
			});

			var scale = 1;
			Object.defineProperty(swiper.zoom, 'scale', {
				get: function get() {
					return scale;
				},
				set: function set(value) {
					if (scale !== value) {
						var imageEl = swiper.zoom.gesture.$imageEl ? swiper.zoom.gesture.$imageEl[0] : undefined;
						var slideEl = swiper.zoom.gesture.$slideEl ? swiper.zoom.gesture.$slideEl[0] : undefined;
						swiper.emit('zoomChange', value, imageEl, slideEl);
					}
					scale = value;
				},
			});
		},
		on: {
			init: function init() {
				var swiper = this;
				if (swiper.params.zoom.enabled) {
					swiper.zoom.enable();
				}
			},
			destroy: function destroy() {
				var swiper = this;
				swiper.zoom.disable();
			},
			touchStart: function touchStart(e) {
				var swiper = this;
				if (!swiper.zoom.enabled) { return; }
				swiper.zoom.onTouchStart(e);
			},
			touchEnd: function touchEnd(e) {
				var swiper = this;
				if (!swiper.zoom.enabled) { return; }
				swiper.zoom.onTouchEnd(e);
			},
			doubleTap: function doubleTap(e) {
				var swiper = this;
				if (swiper.params.zoom.enabled && swiper.zoom.enabled && swiper.params.zoom.toggle) {
					swiper.zoom.toggle(e);
				}
			},
			transitionEnd: function transitionEnd() {
				var swiper = this;
				if (swiper.zoom.enabled && swiper.params.zoom.enabled) {
					swiper.zoom.onTransitionEnd();
				}
			},
			slideChange: function slideChange() {
				var swiper = this;
				if (swiper.zoom.enabled && swiper.params.zoom.enabled && swiper.params.cssMode) {
					swiper.zoom.onTransitionEnd();
				}
			},
		},
	};

	var Lazy = {
		loadInSlide: function loadInSlide(index, loadInDuplicate) {
			if ( loadInDuplicate === void 0 ) loadInDuplicate = true;

			var swiper = this;
			var params = swiper.params.lazy;
			if (typeof index === 'undefined') { return; }
			if (swiper.slides.length === 0) { return; }
			var isVirtual = swiper.virtual && swiper.params.virtual.enabled;

			var $slideEl = isVirtual
				? swiper.$wrapperEl.children(("." + (swiper.params.slideClass) + "[data-swiper-slide-index=\"" + index + "\"]"))
				: swiper.slides.eq(index);

			var $images = $slideEl.find(("." + (params.elementClass) + ":not(." + (params.loadedClass) + "):not(." + (params.loadingClass) + ")"));
			if ($slideEl.hasClass(params.elementClass) && !$slideEl.hasClass(params.loadedClass) && !$slideEl.hasClass(params.loadingClass)) {
				$images = $images.add($slideEl[0]);
			}
			if ($images.length === 0) { return; }

			$images.each(function (imageIndex, imageEl) {
				var $imageEl = $(imageEl);
				$imageEl.addClass(params.loadingClass);

				var background = $imageEl.attr('data-background');
				var src = $imageEl.attr('data-src');
				var srcset = $imageEl.attr('data-srcset');
				var sizes = $imageEl.attr('data-sizes');

				swiper.loadImage($imageEl[0], (src || background), srcset, sizes, false, function () {
					if (typeof swiper === 'undefined' || swiper === null || !swiper || (swiper && !swiper.params) || swiper.destroyed) { return; }
					if (background) {
						$imageEl.css('background-image', ("url(\"" + background + "\")"));
						$imageEl.removeAttr('data-background');
					} else {
						if (srcset) {
							$imageEl.attr('srcset', srcset);
							$imageEl.removeAttr('data-srcset');
						}
						if (sizes) {
							$imageEl.attr('sizes', sizes);
							$imageEl.removeAttr('data-sizes');
						}
						if (src) {
							$imageEl.attr('src', src);
							$imageEl.removeAttr('data-src');
						}
					}

					$imageEl.addClass(params.loadedClass).removeClass(params.loadingClass);
					$slideEl.find(("." + (params.preloaderClass))).remove();
					if (swiper.params.loop && loadInDuplicate) {
						var slideOriginalIndex = $slideEl.attr('data-swiper-slide-index');
						if ($slideEl.hasClass(swiper.params.slideDuplicateClass)) {
							var originalSlide = swiper.$wrapperEl.children(("[data-swiper-slide-index=\"" + slideOriginalIndex + "\"]:not(." + (swiper.params.slideDuplicateClass) + ")"));
							swiper.lazy.loadInSlide(originalSlide.index(), false);
						} else {
							var duplicatedSlide = swiper.$wrapperEl.children(("." + (swiper.params.slideDuplicateClass) + "[data-swiper-slide-index=\"" + slideOriginalIndex + "\"]"));
							swiper.lazy.loadInSlide(duplicatedSlide.index(), false);
						}
					}
					swiper.emit('lazyImageReady', $slideEl[0], $imageEl[0]);
					if (swiper.params.autoHeight) {
						swiper.updateAutoHeight();
					}
				});

				swiper.emit('lazyImageLoad', $slideEl[0], $imageEl[0]);
			});
		},
		load: function load() {
			var swiper = this;
			var $wrapperEl = swiper.$wrapperEl;
			var swiperParams = swiper.params;
			var slides = swiper.slides;
			var activeIndex = swiper.activeIndex;
			var isVirtual = swiper.virtual && swiperParams.virtual.enabled;
			var params = swiperParams.lazy;

			var slidesPerView = swiperParams.slidesPerView;
			if (slidesPerView === 'auto') {
				slidesPerView = 0;
			}

			function slideExist(index) {
				if (isVirtual) {
					if ($wrapperEl.children(("." + (swiperParams.slideClass) + "[data-swiper-slide-index=\"" + index + "\"]")).length) {
						return true;
					}
				} else if (slides[index]) { return true; }
				return false;
			}
			function slideIndex(slideEl) {
				if (isVirtual) {
					return $(slideEl).attr('data-swiper-slide-index');
				}
				return $(slideEl).index();
			}

			if (!swiper.lazy.initialImageLoaded) { swiper.lazy.initialImageLoaded = true; }
			if (swiper.params.watchSlidesVisibility) {
				$wrapperEl.children(("." + (swiperParams.slideVisibleClass))).each(function (elIndex, slideEl) {
					var index = isVirtual ? $(slideEl).attr('data-swiper-slide-index') : $(slideEl).index();
					swiper.lazy.loadInSlide(index);
				});
			} else if (slidesPerView > 1) {
				for (var i = activeIndex; i < activeIndex + slidesPerView; i += 1) {
					if (slideExist(i)) { swiper.lazy.loadInSlide(i); }
				}
			} else {
				swiper.lazy.loadInSlide(activeIndex);
			}
			if (params.loadPrevNext) {
				if (slidesPerView > 1 || (params.loadPrevNextAmount && params.loadPrevNextAmount > 1)) {
					var amount = params.loadPrevNextAmount;
					var spv = slidesPerView;
					var maxIndex = Math.min(activeIndex + spv + Math.max(amount, spv), slides.length);
					var minIndex = Math.max(activeIndex - Math.max(spv, amount), 0);
					// Next Slides
					for (var i$1 = activeIndex + slidesPerView; i$1 < maxIndex; i$1 += 1) {
						if (slideExist(i$1)) { swiper.lazy.loadInSlide(i$1); }
					}
					// Prev Slides
					for (var i$2 = minIndex; i$2 < activeIndex; i$2 += 1) {
						if (slideExist(i$2)) { swiper.lazy.loadInSlide(i$2); }
					}
				} else {
					var nextSlide = $wrapperEl.children(("." + (swiperParams.slideNextClass)));
					if (nextSlide.length > 0) { swiper.lazy.loadInSlide(slideIndex(nextSlide)); }

					var prevSlide = $wrapperEl.children(("." + (swiperParams.slidePrevClass)));
					if (prevSlide.length > 0) { swiper.lazy.loadInSlide(slideIndex(prevSlide)); }
				}
			}
		},
	};

	var Lazy$1 = {
		name: 'lazy',
		params: {
			lazy: {
				enabled: false,
				loadPrevNext: false,
				loadPrevNextAmount: 1,
				loadOnTransitionStart: false,

				elementClass: 'swiper-lazy',
				loadingClass: 'swiper-lazy-loading',
				loadedClass: 'swiper-lazy-loaded',
				preloaderClass: 'swiper-lazy-preloader',
			},
		},
		create: function create() {
			var swiper = this;
			Utils.extend(swiper, {
				lazy: {
					initialImageLoaded: false,
					load: Lazy.load.bind(swiper),
					loadInSlide: Lazy.loadInSlide.bind(swiper),
				},
			});
		},
		on: {
			beforeInit: function beforeInit() {
				var swiper = this;
				if (swiper.params.lazy.enabled && swiper.params.preloadImages) {
					swiper.params.preloadImages = false;
				}
			},
			init: function init() {
				var swiper = this;
				if (swiper.params.lazy.enabled && !swiper.params.loop && swiper.params.initialSlide === 0) {
					swiper.lazy.load();
				}
			},
			scroll: function scroll() {
				var swiper = this;
				if (swiper.params.freeMode && !swiper.params.freeModeSticky) {
					swiper.lazy.load();
				}
			},
			resize: function resize() {
				var swiper = this;
				if (swiper.params.lazy.enabled) {
					swiper.lazy.load();
				}
			},
			scrollbarDragMove: function scrollbarDragMove() {
				var swiper = this;
				if (swiper.params.lazy.enabled) {
					swiper.lazy.load();
				}
			},
			transitionStart: function transitionStart() {
				var swiper = this;
				if (swiper.params.lazy.enabled) {
					if (swiper.params.lazy.loadOnTransitionStart || (!swiper.params.lazy.loadOnTransitionStart && !swiper.lazy.initialImageLoaded)) {
						swiper.lazy.load();
					}
				}
			},
			transitionEnd: function transitionEnd() {
				var swiper = this;
				if (swiper.params.lazy.enabled && !swiper.params.lazy.loadOnTransitionStart) {
					swiper.lazy.load();
				}
			},
			slideChange: function slideChange() {
				var swiper = this;
				if (swiper.params.lazy.enabled && swiper.params.cssMode) {
					swiper.lazy.load();
				}
			},
		},
	};

	/* eslint no-bitwise: ["error", { "allow": [">>"] }] */

	var Controller = {
		LinearSpline: function LinearSpline(x, y) {
			var binarySearch = (function search() {
				var maxIndex;
				var minIndex;
				var guess;
				return function (array, val) {
					minIndex = -1;
					maxIndex = array.length;
					while (maxIndex - minIndex > 1) {
						guess = maxIndex + minIndex >> 1;
						if (array[guess] <= val) {
							minIndex = guess;
						} else {
							maxIndex = guess;
						}
					}
					return maxIndex;
				};
			}());
			this.x = x;
			this.y = y;
			this.lastIndex = x.length - 1;
			// Given an x value (x2), return the expected y2 value:
			// (x1,y1) is the known point before given value,
			// (x3,y3) is the known point after given value.
			var i1;
			var i3;

			this.interpolate = function interpolate(x2) {
				if (!x2) { return 0; }

				// Get the indexes of x1 and x3 (the array indexes before and after given x2):
				i3 = binarySearch(this.x, x2);
				i1 = i3 - 1;

				// We have our indexes i1 & i3, so we can calculate already:
				// y2 := ((x2−x1) × (y3−y1)) ÷ (x3−x1) + y1
				return (((x2 - this.x[i1]) * (this.y[i3] - this.y[i1])) / (this.x[i3] - this.x[i1])) + this.y[i1];
			};
			return this;
		},
		// xxx: for now i will just save one spline function to to
		getInterpolateFunction: function getInterpolateFunction(c) {
			var swiper = this;
			if (!swiper.controller.spline) {
				swiper.controller.spline = swiper.params.loop
					? new Controller.LinearSpline(swiper.slidesGrid, c.slidesGrid)
					: new Controller.LinearSpline(swiper.snapGrid, c.snapGrid);
			}
		},
		setTranslate: function setTranslate(setTranslate$1, byController) {
			var swiper = this;
			var controlled = swiper.controller.control;
			var multiplier;
			var controlledTranslate;
			function setControlledTranslate(c) {
				// this will create an Interpolate function based on the snapGrids
				// x is the Grid of the scrolled scroller and y will be the controlled scroller
				// it makes sense to create this only once and recall it for the interpolation
				// the function does a lot of value caching for performance
				var translate = swiper.rtlTranslate ? -swiper.translate : swiper.translate;
				if (swiper.params.controller.by === 'slide') {
					swiper.controller.getInterpolateFunction(c);
					// i am not sure why the values have to be multiplicated this way, tried to invert the snapGrid
					// but it did not work out
					controlledTranslate = -swiper.controller.spline.interpolate(-translate);
				}

				if (!controlledTranslate || swiper.params.controller.by === 'container') {
					multiplier = (c.maxTranslate() - c.minTranslate()) / (swiper.maxTranslate() - swiper.minTranslate());
					controlledTranslate = ((translate - swiper.minTranslate()) * multiplier) + c.minTranslate();
				}

				if (swiper.params.controller.inverse) {
					controlledTranslate = c.maxTranslate() - controlledTranslate;
				}
				c.updateProgress(controlledTranslate);
				c.setTranslate(controlledTranslate, swiper);
				c.updateActiveIndex();
				c.updateSlidesClasses();
			}
			if (Array.isArray(controlled)) {
				for (var i = 0; i < controlled.length; i += 1) {
					if (controlled[i] !== byController && controlled[i] instanceof Swiper) {
						setControlledTranslate(controlled[i]);
					}
				}
			} else if (controlled instanceof Swiper && byController !== controlled) {
				setControlledTranslate(controlled);
			}
		},
		setTransition: function setTransition(duration, byController) {
			var swiper = this;
			var controlled = swiper.controller.control;
			var i;
			function setControlledTransition(c) {
				c.setTransition(duration, swiper);
				if (duration !== 0) {
					c.transitionStart();
					if (c.params.autoHeight) {
						Utils.nextTick(function () {
							c.updateAutoHeight();
						});
					}
					c.$wrapperEl.transitionEnd(function () {
						if (!controlled) { return; }
						if (c.params.loop && swiper.params.controller.by === 'slide') {
							c.loopFix();
						}
						c.transitionEnd();
					});
				}
			}
			if (Array.isArray(controlled)) {
				for (i = 0; i < controlled.length; i += 1) {
					if (controlled[i] !== byController && controlled[i] instanceof Swiper) {
						setControlledTransition(controlled[i]);
					}
				}
			} else if (controlled instanceof Swiper && byController !== controlled) {
				setControlledTransition(controlled);
			}
		},
	};
	var Controller$1 = {
		name: 'controller',
		params: {
			controller: {
				control: undefined,
				inverse: false,
				by: 'slide', // or 'container'
			},
		},
		create: function create() {
			var swiper = this;
			Utils.extend(swiper, {
				controller: {
					control: swiper.params.controller.control,
					getInterpolateFunction: Controller.getInterpolateFunction.bind(swiper),
					setTranslate: Controller.setTranslate.bind(swiper),
					setTransition: Controller.setTransition.bind(swiper),
				},
			});
		},
		on: {
			update: function update() {
				var swiper = this;
				if (!swiper.controller.control) { return; }
				if (swiper.controller.spline) {
					swiper.controller.spline = undefined;
					delete swiper.controller.spline;
				}
			},
			resize: function resize() {
				var swiper = this;
				if (!swiper.controller.control) { return; }
				if (swiper.controller.spline) {
					swiper.controller.spline = undefined;
					delete swiper.controller.spline;
				}
			},
			observerUpdate: function observerUpdate() {
				var swiper = this;
				if (!swiper.controller.control) { return; }
				if (swiper.controller.spline) {
					swiper.controller.spline = undefined;
					delete swiper.controller.spline;
				}
			},
			setTranslate: function setTranslate(translate, byController) {
				var swiper = this;
				if (!swiper.controller.control) { return; }
				swiper.controller.setTranslate(translate, byController);
			},
			setTransition: function setTransition(duration, byController) {
				var swiper = this;
				if (!swiper.controller.control) { return; }
				swiper.controller.setTransition(duration, byController);
			},
		},
	};

	var a11y = {
		makeElFocusable: function makeElFocusable($el) {
			$el.attr('tabIndex', '0');
			return $el;
		},
		addElRole: function addElRole($el, role) {
			$el.attr('role', role);
			return $el;
		},
		addElLabel: function addElLabel($el, label) {
			$el.attr('aria-label', label);
			return $el;
		},
		disableEl: function disableEl($el) {
			$el.attr('aria-disabled', true);
			return $el;
		},
		enableEl: function enableEl($el) {
			$el.attr('aria-disabled', false);
			return $el;
		},
		onEnterKey: function onEnterKey(e) {
			var swiper = this;
			var params = swiper.params.a11y;
			if (e.keyCode !== 13) { return; }
			var $targetEl = $(e.target);
			if (swiper.navigation && swiper.navigation.$nextEl && $targetEl.is(swiper.navigation.$nextEl)) {
				if (!(swiper.isEnd && !swiper.params.loop)) {
					swiper.slideNext();
				}
				if (swiper.isEnd) {
					swiper.a11y.notify(params.lastSlideMessage);
				} else {
					swiper.a11y.notify(params.nextSlideMessage);
				}
			}
			if (swiper.navigation && swiper.navigation.$prevEl && $targetEl.is(swiper.navigation.$prevEl)) {
				if (!(swiper.isBeginning && !swiper.params.loop)) {
					swiper.slidePrev();
				}
				if (swiper.isBeginning) {
					swiper.a11y.notify(params.firstSlideMessage);
				} else {
					swiper.a11y.notify(params.prevSlideMessage);
				}
			}
			if (swiper.pagination && $targetEl.is(("." + (swiper.params.pagination.bulletClass)))) {
				$targetEl[0].click();
			}
		},
		notify: function notify(message) {
			var swiper = this;
			var notification = swiper.a11y.liveRegion;
			if (notification.length === 0) { return; }
			notification.html('');
			notification.html(message);
		},
		updateNavigation: function updateNavigation() {
			var swiper = this;

			if (swiper.params.loop || !swiper.navigation) { return; }
			var ref = swiper.navigation;
			var $nextEl = ref.$nextEl;
			var $prevEl = ref.$prevEl;

			if ($prevEl && $prevEl.length > 0) {
				if (swiper.isBeginning) {
					swiper.a11y.disableEl($prevEl);
				} else {
					swiper.a11y.enableEl($prevEl);
				}
			}
			if ($nextEl && $nextEl.length > 0) {
				if (swiper.isEnd) {
					swiper.a11y.disableEl($nextEl);
				} else {
					swiper.a11y.enableEl($nextEl);
				}
			}
		},
		updatePagination: function updatePagination() {
			var swiper = this;
			var params = swiper.params.a11y;
			if (swiper.pagination && swiper.params.pagination.clickable && swiper.pagination.bullets && swiper.pagination.bullets.length) {
				swiper.pagination.bullets.each(function (bulletIndex, bulletEl) {
					var $bulletEl = $(bulletEl);
					swiper.a11y.makeElFocusable($bulletEl);
					swiper.a11y.addElRole($bulletEl, 'button');
					swiper.a11y.addElLabel($bulletEl, params.paginationBulletMessage.replace(/{{index}}/, $bulletEl.index() + 1));
				});
			}
		},
		init: function init() {
			var swiper = this;

			swiper.$el.append(swiper.a11y.liveRegion);

			// Navigation
			var params = swiper.params.a11y;
			var $nextEl;
			var $prevEl;
			if (swiper.navigation && swiper.navigation.$nextEl) {
				$nextEl = swiper.navigation.$nextEl;
			}
			if (swiper.navigation && swiper.navigation.$prevEl) {
				$prevEl = swiper.navigation.$prevEl;
			}
			if ($nextEl) {
				swiper.a11y.makeElFocusable($nextEl);
				swiper.a11y.addElRole($nextEl, 'button');
				swiper.a11y.addElLabel($nextEl, params.nextSlideMessage);
				$nextEl.on('keydown', swiper.a11y.onEnterKey);
			}
			if ($prevEl) {
				swiper.a11y.makeElFocusable($prevEl);
				swiper.a11y.addElRole($prevEl, 'button');
				swiper.a11y.addElLabel($prevEl, params.prevSlideMessage);
				$prevEl.on('keydown', swiper.a11y.onEnterKey);
			}

			// Pagination
			if (swiper.pagination && swiper.params.pagination.clickable && swiper.pagination.bullets && swiper.pagination.bullets.length) {
				swiper.pagination.$el.on('keydown', ("." + (swiper.params.pagination.bulletClass)), swiper.a11y.onEnterKey);
			}
		},
		destroy: function destroy() {
			var swiper = this;
			if (swiper.a11y.liveRegion && swiper.a11y.liveRegion.length > 0) { swiper.a11y.liveRegion.remove(); }

			var $nextEl;
			var $prevEl;
			if (swiper.navigation && swiper.navigation.$nextEl) {
				$nextEl = swiper.navigation.$nextEl;
			}
			if (swiper.navigation && swiper.navigation.$prevEl) {
				$prevEl = swiper.navigation.$prevEl;
			}
			if ($nextEl) {
				$nextEl.off('keydown', swiper.a11y.onEnterKey);
			}
			if ($prevEl) {
				$prevEl.off('keydown', swiper.a11y.onEnterKey);
			}

			// Pagination
			if (swiper.pagination && swiper.params.pagination.clickable && swiper.pagination.bullets && swiper.pagination.bullets.length) {
				swiper.pagination.$el.off('keydown', ("." + (swiper.params.pagination.bulletClass)), swiper.a11y.onEnterKey);
			}
		},
	};
	var A11y = {
		name: 'a11y',
		params: {
			a11y: {
				enabled: true,
				notificationClass: 'swiper-notification',
				prevSlideMessage: 'Previous slide',
				nextSlideMessage: 'Next slide',
				firstSlideMessage: 'This is the first slide',
				lastSlideMessage: 'This is the last slide',
				paginationBulletMessage: 'Go to slide {{index}}',
			},
		},
		create: function create() {
			var swiper = this;
			Utils.extend(swiper, {
				a11y: {
					liveRegion: $(("<span class=\"" + (swiper.params.a11y.notificationClass) + "\" aria-live=\"assertive\" aria-atomic=\"true\"></span>")),
				},
			});
			Object.keys(a11y).forEach(function (methodName) {
				swiper.a11y[methodName] = a11y[methodName].bind(swiper);
			});
		},
		on: {
			init: function init() {
				var swiper = this;
				if (!swiper.params.a11y.enabled) { return; }
				swiper.a11y.init();
				swiper.a11y.updateNavigation();
			},
			toEdge: function toEdge() {
				var swiper = this;
				if (!swiper.params.a11y.enabled) { return; }
				swiper.a11y.updateNavigation();
			},
			fromEdge: function fromEdge() {
				var swiper = this;
				if (!swiper.params.a11y.enabled) { return; }
				swiper.a11y.updateNavigation();
			},
			paginationUpdate: function paginationUpdate() {
				var swiper = this;
				if (!swiper.params.a11y.enabled) { return; }
				swiper.a11y.updatePagination();
			},
			destroy: function destroy() {
				var swiper = this;
				if (!swiper.params.a11y.enabled) { return; }
				swiper.a11y.destroy();
			},
		},
	};

	var History = {
		init: function init() {
			var swiper = this;
			if (!swiper.params.history) { return; }
			if (!win.history || !win.history.pushState) {
				swiper.params.history.enabled = false;
				swiper.params.hashNavigation.enabled = true;
				return;
			}
			var history = swiper.history;
			history.initialized = true;
			history.paths = History.getPathValues();
			if (!history.paths.key && !history.paths.value) { return; }
			history.scrollToSlide(0, history.paths.value, swiper.params.runCallbacksOnInit);
			if (!swiper.params.history.replaceState) {
				win.addEventListener('popstate', swiper.history.setHistoryPopState);
			}
		},
		destroy: function destroy() {
			var swiper = this;
			if (!swiper.params.history.replaceState) {
				win.removeEventListener('popstate', swiper.history.setHistoryPopState);
			}
		},
		setHistoryPopState: function setHistoryPopState() {
			var swiper = this;
			swiper.history.paths = History.getPathValues();
			swiper.history.scrollToSlide(swiper.params.speed, swiper.history.paths.value, false);
		},
		getPathValues: function getPathValues() {
			var pathArray = win.location.pathname.slice(1).split('/').filter(function (part) { return part !== ''; });
			var total = pathArray.length;
			var key = pathArray[total - 2];
			var value = pathArray[total - 1];
			return { key: key, value: value };
		},
		setHistory: function setHistory(key, index) {
			var swiper = this;
			if (!swiper.history.initialized || !swiper.params.history.enabled) { return; }
			var slide = swiper.slides.eq(index);
			var value = History.slugify(slide.attr('data-history'));
			if (!win.location.pathname.includes(key)) {
				value = key + "/" + value;
			}
			var currentState = win.history.state;
			if (currentState && currentState.value === value) {
				return;
			}
			if (swiper.params.history.replaceState) {
				win.history.replaceState({ value: value }, null, value);
			} else {
				win.history.pushState({ value: value }, null, value);
			}
		},
		slugify: function slugify(text) {
			return text.toString()
				.replace(/\s+/g, '-')
				.replace(/[^\w-]+/g, '')
				.replace(/--+/g, '-')
				.replace(/^-+/, '')
				.replace(/-+$/, '');
		},
		scrollToSlide: function scrollToSlide(speed, value, runCallbacks) {
			var swiper = this;
			if (value) {
				for (var i = 0, length = swiper.slides.length; i < length; i += 1) {
					var slide = swiper.slides.eq(i);
					var slideHistory = History.slugify(slide.attr('data-history'));
					if (slideHistory === value && !slide.hasClass(swiper.params.slideDuplicateClass)) {
						var index = slide.index();
						swiper.slideTo(index, speed, runCallbacks);
					}
				}
			} else {
				swiper.slideTo(0, speed, runCallbacks);
			}
		},
	};

	var History$1 = {
		name: 'history',
		params: {
			history: {
				enabled: false,
				replaceState: false,
				key: 'slides',
			},
		},
		create: function create() {
			var swiper = this;
			Utils.extend(swiper, {
				history: {
					init: History.init.bind(swiper),
					setHistory: History.setHistory.bind(swiper),
					setHistoryPopState: History.setHistoryPopState.bind(swiper),
					scrollToSlide: History.scrollToSlide.bind(swiper),
					destroy: History.destroy.bind(swiper),
				},
			});
		},
		on: {
			init: function init() {
				var swiper = this;
				if (swiper.params.history.enabled) {
					swiper.history.init();
				}
			},
			destroy: function destroy() {
				var swiper = this;
				if (swiper.params.history.enabled) {
					swiper.history.destroy();
				}
			},
			transitionEnd: function transitionEnd() {
				var swiper = this;
				if (swiper.history.initialized) {
					swiper.history.setHistory(swiper.params.history.key, swiper.activeIndex);
				}
			},
			slideChange: function slideChange() {
				var swiper = this;
				if (swiper.history.initialized && swiper.params.cssMode) {
					swiper.history.setHistory(swiper.params.history.key, swiper.activeIndex);
				}
			},
		},
	};

	var HashNavigation = {
		onHashCange: function onHashCange() {
			var swiper = this;
			var newHash = doc.location.hash.replace('#', '');
			var activeSlideHash = swiper.slides.eq(swiper.activeIndex).attr('data-hash');
			if (newHash !== activeSlideHash) {
				var newIndex = swiper.$wrapperEl.children(("." + (swiper.params.slideClass) + "[data-hash=\"" + newHash + "\"]")).index();
				if (typeof newIndex === 'undefined') { return; }
				swiper.slideTo(newIndex);
			}
		},
		setHash: function setHash() {
			var swiper = this;
			if (!swiper.hashNavigation.initialized || !swiper.params.hashNavigation.enabled) { return; }
			if (swiper.params.hashNavigation.replaceState && win.history && win.history.replaceState) {
				win.history.replaceState(null, null, (("#" + (swiper.slides.eq(swiper.activeIndex).attr('data-hash'))) || ''));
			} else {
				var slide = swiper.slides.eq(swiper.activeIndex);
				var hash = slide.attr('data-hash') || slide.attr('data-history');
				doc.location.hash = hash || '';
			}
		},
		init: function init() {
			var swiper = this;
			if (!swiper.params.hashNavigation.enabled || (swiper.params.history && swiper.params.history.enabled)) { return; }
			swiper.hashNavigation.initialized = true;
			var hash = doc.location.hash.replace('#', '');
			if (hash) {
				var speed = 0;
				for (var i = 0, length = swiper.slides.length; i < length; i += 1) {
					var slide = swiper.slides.eq(i);
					var slideHash = slide.attr('data-hash') || slide.attr('data-history');
					if (slideHash === hash && !slide.hasClass(swiper.params.slideDuplicateClass)) {
						var index = slide.index();
						swiper.slideTo(index, speed, swiper.params.runCallbacksOnInit, true);
					}
				}
			}
			if (swiper.params.hashNavigation.watchState) {
				$(win).on('hashchange', swiper.hashNavigation.onHashCange);
			}
		},
		destroy: function destroy() {
			var swiper = this;
			if (swiper.params.hashNavigation.watchState) {
				$(win).off('hashchange', swiper.hashNavigation.onHashCange);
			}
		},
	};
	var HashNavigation$1 = {
		name: 'hash-navigation',
		params: {
			hashNavigation: {
				enabled: false,
				replaceState: false,
				watchState: false,
			},
		},
		create: function create() {
			var swiper = this;
			Utils.extend(swiper, {
				hashNavigation: {
					initialized: false,
					init: HashNavigation.init.bind(swiper),
					destroy: HashNavigation.destroy.bind(swiper),
					setHash: HashNavigation.setHash.bind(swiper),
					onHashCange: HashNavigation.onHashCange.bind(swiper),
				},
			});
		},
		on: {
			init: function init() {
				var swiper = this;
				if (swiper.params.hashNavigation.enabled) {
					swiper.hashNavigation.init();
				}
			},
			destroy: function destroy() {
				var swiper = this;
				if (swiper.params.hashNavigation.enabled) {
					swiper.hashNavigation.destroy();
				}
			},
			transitionEnd: function transitionEnd() {
				var swiper = this;
				if (swiper.hashNavigation.initialized) {
					swiper.hashNavigation.setHash();
				}
			},
			slideChange: function slideChange() {
				var swiper = this;
				if (swiper.hashNavigation.initialized && swiper.params.cssMode) {
					swiper.hashNavigation.setHash();
				}
			},
		},
	};

	/* eslint no-underscore-dangle: "off" */

	var Autoplay = {
		run: function run() {
			var swiper = this;
			var $activeSlideEl = swiper.slides.eq(swiper.activeIndex);
			var delay = swiper.params.autoplay.delay;
			if ($activeSlideEl.attr('data-swiper-autoplay')) {
				delay = $activeSlideEl.attr('data-swiper-autoplay') || swiper.params.autoplay.delay;
			}
			clearTimeout(swiper.autoplay.timeout);
			swiper.autoplay.timeout = Utils.nextTick(function () {
				if (swiper.params.autoplay.reverseDirection) {
					if (swiper.params.loop) {
						swiper.loopFix();
						swiper.slidePrev(swiper.params.speed, true, true);
						swiper.emit('autoplay');
					} else if (!swiper.isBeginning) {
						swiper.slidePrev(swiper.params.speed, true, true);
						swiper.emit('autoplay');
					} else if (!swiper.params.autoplay.stopOnLastSlide) {
						swiper.slideTo(swiper.slides.length - 1, swiper.params.speed, true, true);
						swiper.emit('autoplay');
					} else {
						swiper.autoplay.stop();
					}
				} else if (swiper.params.loop) {
					swiper.loopFix();
					swiper.slideNext(swiper.params.speed, true, true);
					swiper.emit('autoplay');
				} else if (!swiper.isEnd) {
					swiper.slideNext(swiper.params.speed, true, true);
					swiper.emit('autoplay');
				} else if (!swiper.params.autoplay.stopOnLastSlide) {
					swiper.slideTo(0, swiper.params.speed, true, true);
					swiper.emit('autoplay');
				} else {
					swiper.autoplay.stop();
				}
				if (swiper.params.cssMode && swiper.autoplay.running) { swiper.autoplay.run(); }
			}, delay);
		},
		start: function start() {
			var swiper = this;
			if (typeof swiper.autoplay.timeout !== 'undefined') { return false; }
			if (swiper.autoplay.running) { return false; }
			swiper.autoplay.running = true;
			swiper.emit('autoplayStart');
			swiper.autoplay.run();
			return true;
		},
		stop: function stop() {
			var swiper = this;
			if (!swiper.autoplay.running) { return false; }
			if (typeof swiper.autoplay.timeout === 'undefined') { return false; }

			if (swiper.autoplay.timeout) {
				clearTimeout(swiper.autoplay.timeout);
				swiper.autoplay.timeout = undefined;
			}
			swiper.autoplay.running = false;
			swiper.emit('autoplayStop');
			return true;
		},
		pause: function pause(speed) {
			var swiper = this;
			if (!swiper.autoplay.running) { return; }
			if (swiper.autoplay.paused) { return; }
			if (swiper.autoplay.timeout) { clearTimeout(swiper.autoplay.timeout); }
			swiper.autoplay.paused = true;
			if (speed === 0 || !swiper.params.autoplay.waitForTransition) {
				swiper.autoplay.paused = false;
				swiper.autoplay.run();
			} else {
				swiper.$wrapperEl[0].addEventListener('transitionend', swiper.autoplay.onTransitionEnd);
				swiper.$wrapperEl[0].addEventListener('webkitTransitionEnd', swiper.autoplay.onTransitionEnd);
			}
		},
	};

	var Autoplay$1 = {
		name: 'autoplay',
		params: {
			autoplay: {
				enabled: false,
				delay: 3000,
				waitForTransition: true,
				disableOnInteraction: true,
				stopOnLastSlide: false,
				reverseDirection: false,
			},
		},
		create: function create() {
			var swiper = this;
			Utils.extend(swiper, {
				autoplay: {
					running: false,
					paused: false,
					run: Autoplay.run.bind(swiper),
					start: Autoplay.start.bind(swiper),
					stop: Autoplay.stop.bind(swiper),
					pause: Autoplay.pause.bind(swiper),
					onVisibilityChange: function onVisibilityChange() {
						if (document.visibilityState === 'hidden' && swiper.autoplay.running) {
							swiper.autoplay.pause();
						}
						if (document.visibilityState === 'visible' && swiper.autoplay.paused) {
							swiper.autoplay.run();
							swiper.autoplay.paused = false;
						}
					},
					onTransitionEnd: function onTransitionEnd(e) {
						if (!swiper || swiper.destroyed || !swiper.$wrapperEl) { return; }
						if (e.target !== this) { return; }
						swiper.$wrapperEl[0].removeEventListener('transitionend', swiper.autoplay.onTransitionEnd);
						swiper.$wrapperEl[0].removeEventListener('webkitTransitionEnd', swiper.autoplay.onTransitionEnd);
						swiper.autoplay.paused = false;
						if (!swiper.autoplay.running) {
							swiper.autoplay.stop();
						} else {
							swiper.autoplay.run();
						}
					},
				},
			});
		},
		on: {
			init: function init() {
				var swiper = this;
				if (swiper.params.autoplay.enabled) {
					swiper.autoplay.start();
					document.addEventListener('visibilitychange', swiper.autoplay.onVisibilityChange);
				}
			},
			beforeTransitionStart: function beforeTransitionStart(speed, internal) {
				var swiper = this;
				if (swiper.autoplay.running) {
					if (internal || !swiper.params.autoplay.disableOnInteraction) {
						swiper.autoplay.pause(speed);
					} else {
						swiper.autoplay.stop();
					}
				}
			},
			sliderFirstMove: function sliderFirstMove() {
				var swiper = this;
				if (swiper.autoplay.running) {
					if (swiper.params.autoplay.disableOnInteraction) {
						swiper.autoplay.stop();
					} else {
						swiper.autoplay.pause();
					}
				}
			},
			touchEnd: function touchEnd() {
				var swiper = this;
				if (swiper.params.cssMode && swiper.autoplay.paused && !swiper.params.autoplay.disableOnInteraction) {
					swiper.autoplay.run();
				}
			},
			destroy: function destroy() {
				var swiper = this;
				if (swiper.autoplay.running) {
					swiper.autoplay.stop();
				}
				document.removeEventListener('visibilitychange', swiper.autoplay.onVisibilityChange);
			},
		},
	};

	var Fade = {
		setTranslate: function setTranslate() {
			var swiper = this;
			var slides = swiper.slides;
			for (var i = 0; i < slides.length; i += 1) {
				var $slideEl = swiper.slides.eq(i);
				var offset = $slideEl[0].swiperSlideOffset;
				var tx = -offset;
				if (!swiper.params.virtualTranslate) { tx -= swiper.translate; }
				var ty = 0;
				if (!swiper.isHorizontal()) {
					ty = tx;
					tx = 0;
				}
				var slideOpacity = swiper.params.fadeEffect.crossFade
					? Math.max(1 - Math.abs($slideEl[0].progress), 0)
					: 1 + Math.min(Math.max($slideEl[0].progress, -1), 0);
				$slideEl
					.css({
						opacity: slideOpacity,
					})
					.transform(("translate3d(" + tx + "px, " + ty + "px, 0px)"));
			}
		},
		setTransition: function setTransition(duration) {
			var swiper = this;
			var slides = swiper.slides;
			var $wrapperEl = swiper.$wrapperEl;
			slides.transition(duration);
			if (swiper.params.virtualTranslate && duration !== 0) {
				var eventTriggered = false;
				slides.transitionEnd(function () {
					if (eventTriggered) { return; }
					if (!swiper || swiper.destroyed) { return; }
					eventTriggered = true;
					swiper.animating = false;
					var triggerEvents = ['webkitTransitionEnd', 'transitionend'];
					for (var i = 0; i < triggerEvents.length; i += 1) {
						$wrapperEl.trigger(triggerEvents[i]);
					}
				});
			}
		},
	};

	var EffectFade = {
		name: 'effect-fade',
		params: {
			fadeEffect: {
				crossFade: false,
			},
		},
		create: function create() {
			var swiper = this;
			Utils.extend(swiper, {
				fadeEffect: {
					setTranslate: Fade.setTranslate.bind(swiper),
					setTransition: Fade.setTransition.bind(swiper),
				},
			});
		},
		on: {
			beforeInit: function beforeInit() {
				var swiper = this;
				if (swiper.params.effect !== 'fade') { return; }
				swiper.classNames.push(((swiper.params.containerModifierClass) + "fade"));
				var overwriteParams = {
					slidesPerView: 1,
					slidesPerColumn: 1,
					slidesPerGroup: 1,
					watchSlidesProgress: true,
					spaceBetween: 0,
					virtualTranslate: true,
				};
				Utils.extend(swiper.params, overwriteParams);
				Utils.extend(swiper.originalParams, overwriteParams);
			},
			setTranslate: function setTranslate() {
				var swiper = this;
				if (swiper.params.effect !== 'fade') { return; }
				swiper.fadeEffect.setTranslate();
			},
			setTransition: function setTransition(duration) {
				var swiper = this;
				if (swiper.params.effect !== 'fade') { return; }
				swiper.fadeEffect.setTransition(duration);
			},
		},
	};

	var Cube = {
		setTranslate: function setTranslate() {
			var swiper = this;
			var $el = swiper.$el;
			var $wrapperEl = swiper.$wrapperEl;
			var slides = swiper.slides;
			var swiperWidth = swiper.width;
			var swiperHeight = swiper.height;
			var rtl = swiper.rtlTranslate;
			var swiperSize = swiper.size;
			var params = swiper.params.cubeEffect;
			var isHorizontal = swiper.isHorizontal();
			var isVirtual = swiper.virtual && swiper.params.virtual.enabled;
			var wrapperRotate = 0;
			var $cubeShadowEl;
			if (params.shadow) {
				if (isHorizontal) {
					$cubeShadowEl = $wrapperEl.find('.swiper-cube-shadow');
					if ($cubeShadowEl.length === 0) {
						$cubeShadowEl = $('<div class="swiper-cube-shadow"></div>');
						$wrapperEl.append($cubeShadowEl);
					}
					$cubeShadowEl.css({ height: (swiperWidth + "px") });
				} else {
					$cubeShadowEl = $el.find('.swiper-cube-shadow');
					if ($cubeShadowEl.length === 0) {
						$cubeShadowEl = $('<div class="swiper-cube-shadow"></div>');
						$el.append($cubeShadowEl);
					}
				}
			}
			for (var i = 0; i < slides.length; i += 1) {
				var $slideEl = slides.eq(i);
				var slideIndex = i;
				if (isVirtual) {
					slideIndex = parseInt($slideEl.attr('data-swiper-slide-index'), 10);
				}
				var slideAngle = slideIndex * 90;
				var round = Math.floor(slideAngle / 360);
				if (rtl) {
					slideAngle = -slideAngle;
					round = Math.floor(-slideAngle / 360);
				}
				var progress = Math.max(Math.min($slideEl[0].progress, 1), -1);
				var tx = 0;
				var ty = 0;
				var tz = 0;
				if (slideIndex % 4 === 0) {
					tx = -round * 4 * swiperSize;
					tz = 0;
				} else if ((slideIndex - 1) % 4 === 0) {
					tx = 0;
					tz = -round * 4 * swiperSize;
				} else if ((slideIndex - 2) % 4 === 0) {
					tx = swiperSize + (round * 4 * swiperSize);
					tz = swiperSize;
				} else if ((slideIndex - 3) % 4 === 0) {
					tx = -swiperSize;
					tz = (3 * swiperSize) + (swiperSize * 4 * round);
				}
				if (rtl) {
					tx = -tx;
				}

				if (!isHorizontal) {
					ty = tx;
					tx = 0;
				}

				var transform = "rotateX(" + (isHorizontal ? 0 : -slideAngle) + "deg) rotateY(" + (isHorizontal ? slideAngle : 0) + "deg) translate3d(" + tx + "px, " + ty + "px, " + tz + "px)";
				if (progress <= 1 && progress > -1) {
					wrapperRotate = (slideIndex * 90) + (progress * 90);
					if (rtl) { wrapperRotate = (-slideIndex * 90) - (progress * 90); }
				}
				$slideEl.transform(transform);
				if (params.slideShadows) {
					// Set shadows
					var shadowBefore = isHorizontal ? $slideEl.find('.swiper-slide-shadow-left') : $slideEl.find('.swiper-slide-shadow-top');
					var shadowAfter = isHorizontal ? $slideEl.find('.swiper-slide-shadow-right') : $slideEl.find('.swiper-slide-shadow-bottom');
					if (shadowBefore.length === 0) {
						shadowBefore = $(("<div class=\"swiper-slide-shadow-" + (isHorizontal ? 'left' : 'top') + "\"></div>"));
						$slideEl.append(shadowBefore);
					}
					if (shadowAfter.length === 0) {
						shadowAfter = $(("<div class=\"swiper-slide-shadow-" + (isHorizontal ? 'right' : 'bottom') + "\"></div>"));
						$slideEl.append(shadowAfter);
					}
					if (shadowBefore.length) { shadowBefore[0].style.opacity = Math.max(-progress, 0); }
					if (shadowAfter.length) { shadowAfter[0].style.opacity = Math.max(progress, 0); }
				}
			}
			$wrapperEl.css({
				'-webkit-transform-origin': ("50% 50% -" + (swiperSize / 2) + "px"),
				'-moz-transform-origin': ("50% 50% -" + (swiperSize / 2) + "px"),
				'-ms-transform-origin': ("50% 50% -" + (swiperSize / 2) + "px"),
				'transform-origin': ("50% 50% -" + (swiperSize / 2) + "px"),
			});

			if (params.shadow) {
				if (isHorizontal) {
					$cubeShadowEl.transform(("translate3d(0px, " + ((swiperWidth / 2) + params.shadowOffset) + "px, " + (-swiperWidth / 2) + "px) rotateX(90deg) rotateZ(0deg) scale(" + (params.shadowScale) + ")"));
				} else {
					var shadowAngle = Math.abs(wrapperRotate) - (Math.floor(Math.abs(wrapperRotate) / 90) * 90);
					var multiplier = 1.5 - (
						(Math.sin((shadowAngle * 2 * Math.PI) / 360) / 2)
						+ (Math.cos((shadowAngle * 2 * Math.PI) / 360) / 2)
					);
					var scale1 = params.shadowScale;
					var scale2 = params.shadowScale / multiplier;
					var offset = params.shadowOffset;
					$cubeShadowEl.transform(("scale3d(" + scale1 + ", 1, " + scale2 + ") translate3d(0px, " + ((swiperHeight / 2) + offset) + "px, " + (-swiperHeight / 2 / scale2) + "px) rotateX(-90deg)"));
				}
			}
			var zFactor = (Browser.isSafari || Browser.isUiWebView) ? (-swiperSize / 2) : 0;
			$wrapperEl
				.transform(("translate3d(0px,0," + zFactor + "px) rotateX(" + (swiper.isHorizontal() ? 0 : wrapperRotate) + "deg) rotateY(" + (swiper.isHorizontal() ? -wrapperRotate : 0) + "deg)"));
		},
		setTransition: function setTransition(duration) {
			var swiper = this;
			var $el = swiper.$el;
			var slides = swiper.slides;
			slides
				.transition(duration)
				.find('.swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left')
				.transition(duration);
			if (swiper.params.cubeEffect.shadow && !swiper.isHorizontal()) {
				$el.find('.swiper-cube-shadow').transition(duration);
			}
		},
	};

	var EffectCube = {
		name: 'effect-cube',
		params: {
			cubeEffect: {
				slideShadows: true,
				shadow: true,
				shadowOffset: 20,
				shadowScale: 0.94,
			},
		},
		create: function create() {
			var swiper = this;
			Utils.extend(swiper, {
				cubeEffect: {
					setTranslate: Cube.setTranslate.bind(swiper),
					setTransition: Cube.setTransition.bind(swiper),
				},
			});
		},
		on: {
			beforeInit: function beforeInit() {
				var swiper = this;
				if (swiper.params.effect !== 'cube') { return; }
				swiper.classNames.push(((swiper.params.containerModifierClass) + "cube"));
				swiper.classNames.push(((swiper.params.containerModifierClass) + "3d"));
				var overwriteParams = {
					slidesPerView: 1,
					slidesPerColumn: 1,
					slidesPerGroup: 1,
					watchSlidesProgress: true,
					resistanceRatio: 0,
					spaceBetween: 0,
					centeredSlides: false,
					virtualTranslate: true,
				};
				Utils.extend(swiper.params, overwriteParams);
				Utils.extend(swiper.originalParams, overwriteParams);
			},
			setTranslate: function setTranslate() {
				var swiper = this;
				if (swiper.params.effect !== 'cube') { return; }
				swiper.cubeEffect.setTranslate();
			},
			setTransition: function setTransition(duration) {
				var swiper = this;
				if (swiper.params.effect !== 'cube') { return; }
				swiper.cubeEffect.setTransition(duration);
			},
		},
	};

	var Flip = {
		setTranslate: function setTranslate() {
			var swiper = this;
			var slides = swiper.slides;
			var rtl = swiper.rtlTranslate;
			for (var i = 0; i < slides.length; i += 1) {
				var $slideEl = slides.eq(i);
				var progress = $slideEl[0].progress;
				if (swiper.params.flipEffect.limitRotation) {
					progress = Math.max(Math.min($slideEl[0].progress, 1), -1);
				}
				var offset = $slideEl[0].swiperSlideOffset;
				var rotate = -180 * progress;
				var rotateY = rotate;
				var rotateX = 0;
				var tx = -offset;
				var ty = 0;
				if (!swiper.isHorizontal()) {
					ty = tx;
					tx = 0;
					rotateX = -rotateY;
					rotateY = 0;
				} else if (rtl) {
					rotateY = -rotateY;
				}

				$slideEl[0].style.zIndex = -Math.abs(Math.round(progress)) + slides.length;

				if (swiper.params.flipEffect.slideShadows) {
					// Set shadows
					var shadowBefore = swiper.isHorizontal() ? $slideEl.find('.swiper-slide-shadow-left') : $slideEl.find('.swiper-slide-shadow-top');
					var shadowAfter = swiper.isHorizontal() ? $slideEl.find('.swiper-slide-shadow-right') : $slideEl.find('.swiper-slide-shadow-bottom');
					if (shadowBefore.length === 0) {
						shadowBefore = $(("<div class=\"swiper-slide-shadow-" + (swiper.isHorizontal() ? 'left' : 'top') + "\"></div>"));
						$slideEl.append(shadowBefore);
					}
					if (shadowAfter.length === 0) {
						shadowAfter = $(("<div class=\"swiper-slide-shadow-" + (swiper.isHorizontal() ? 'right' : 'bottom') + "\"></div>"));
						$slideEl.append(shadowAfter);
					}
					if (shadowBefore.length) { shadowBefore[0].style.opacity = Math.max(-progress, 0); }
					if (shadowAfter.length) { shadowAfter[0].style.opacity = Math.max(progress, 0); }
				}
				$slideEl
					.transform(("translate3d(" + tx + "px, " + ty + "px, 0px) rotateX(" + rotateX + "deg) rotateY(" + rotateY + "deg)"));
			}
		},
		setTransition: function setTransition(duration) {
			var swiper = this;
			var slides = swiper.slides;
			var activeIndex = swiper.activeIndex;
			var $wrapperEl = swiper.$wrapperEl;
			slides
				.transition(duration)
				.find('.swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left')
				.transition(duration);
			if (swiper.params.virtualTranslate && duration !== 0) {
				var eventTriggered = false;
				// eslint-disable-next-line
				slides.eq(activeIndex).transitionEnd(function onTransitionEnd() {
					if (eventTriggered) { return; }
					if (!swiper || swiper.destroyed) { return; }
					// if (!$(this).hasClass(swiper.params.slideActiveClass)) return;
					eventTriggered = true;
					swiper.animating = false;
					var triggerEvents = ['webkitTransitionEnd', 'transitionend'];
					for (var i = 0; i < triggerEvents.length; i += 1) {
						$wrapperEl.trigger(triggerEvents[i]);
					}
				});
			}
		},
	};

	var EffectFlip = {
		name: 'effect-flip',
		params: {
			flipEffect: {
				slideShadows: true,
				limitRotation: true,
			},
		},
		create: function create() {
			var swiper = this;
			Utils.extend(swiper, {
				flipEffect: {
					setTranslate: Flip.setTranslate.bind(swiper),
					setTransition: Flip.setTransition.bind(swiper),
				},
			});
		},
		on: {
			beforeInit: function beforeInit() {
				var swiper = this;
				if (swiper.params.effect !== 'flip') { return; }
				swiper.classNames.push(((swiper.params.containerModifierClass) + "flip"));
				swiper.classNames.push(((swiper.params.containerModifierClass) + "3d"));
				var overwriteParams = {
					slidesPerView: 1,
					slidesPerColumn: 1,
					slidesPerGroup: 1,
					watchSlidesProgress: true,
					spaceBetween: 0,
					virtualTranslate: true,
				};
				Utils.extend(swiper.params, overwriteParams);
				Utils.extend(swiper.originalParams, overwriteParams);
			},
			setTranslate: function setTranslate() {
				var swiper = this;
				if (swiper.params.effect !== 'flip') { return; }
				swiper.flipEffect.setTranslate();
			},
			setTransition: function setTransition(duration) {
				var swiper = this;
				if (swiper.params.effect !== 'flip') { return; }
				swiper.flipEffect.setTransition(duration);
			},
		},
	};

	var Coverflow = {
		setTranslate: function setTranslate() {
			var swiper = this;
			var swiperWidth = swiper.width;
			var swiperHeight = swiper.height;
			var slides = swiper.slides;
			var $wrapperEl = swiper.$wrapperEl;
			var slidesSizesGrid = swiper.slidesSizesGrid;
			var params = swiper.params.coverflowEffect;
			var isHorizontal = swiper.isHorizontal();
			var transform = swiper.translate;
			var center = isHorizontal ? -transform + (swiperWidth / 2) : -transform + (swiperHeight / 2);
			var rotate = isHorizontal ? params.rotate : -params.rotate;
			var translate = params.depth;
			// Each slide offset from center
			for (var i = 0, length = slides.length; i < length; i += 1) {
				var $slideEl = slides.eq(i);
				var slideSize = slidesSizesGrid[i];
				var slideOffset = $slideEl[0].swiperSlideOffset;
				var offsetMultiplier = ((center - slideOffset - (slideSize / 2)) / slideSize) * params.modifier;

				var rotateY = isHorizontal ? rotate * offsetMultiplier : 0;
				var rotateX = isHorizontal ? 0 : rotate * offsetMultiplier;
				// var rotateZ = 0
				var translateZ = -translate * Math.abs(offsetMultiplier);

				var stretch = params.stretch;
				// Allow percentage to make a relative stretch for responsive sliders
				if (typeof stretch === 'string' && stretch.indexOf('%') !== -1) {
					stretch = ((parseFloat(params.stretch) / 100) * slideSize);
				}
				var translateY = isHorizontal ? 0 : stretch * (offsetMultiplier);
				var translateX = isHorizontal ? stretch * (offsetMultiplier) : 0;

				// Fix for ultra small values
				if (Math.abs(translateX) < 0.001) { translateX = 0; }
				if (Math.abs(translateY) < 0.001) { translateY = 0; }
				if (Math.abs(translateZ) < 0.001) { translateZ = 0; }
				if (Math.abs(rotateY) < 0.001) { rotateY = 0; }
				if (Math.abs(rotateX) < 0.001) { rotateX = 0; }

				var slideTransform = "translate3d(" + translateX + "px," + translateY + "px," + translateZ + "px)  rotateX(" + rotateX + "deg) rotateY(" + rotateY + "deg)";

				$slideEl.transform(slideTransform);
				$slideEl[0].style.zIndex = -Math.abs(Math.round(offsetMultiplier)) + 1;
				if (params.slideShadows) {
					// Set shadows
					var $shadowBeforeEl = isHorizontal ? $slideEl.find('.swiper-slide-shadow-left') : $slideEl.find('.swiper-slide-shadow-top');
					var $shadowAfterEl = isHorizontal ? $slideEl.find('.swiper-slide-shadow-right') : $slideEl.find('.swiper-slide-shadow-bottom');
					if ($shadowBeforeEl.length === 0) {
						$shadowBeforeEl = $(("<div class=\"swiper-slide-shadow-" + (isHorizontal ? 'left' : 'top') + "\"></div>"));
						$slideEl.append($shadowBeforeEl);
					}
					if ($shadowAfterEl.length === 0) {
						$shadowAfterEl = $(("<div class=\"swiper-slide-shadow-" + (isHorizontal ? 'right' : 'bottom') + "\"></div>"));
						$slideEl.append($shadowAfterEl);
					}
					if ($shadowBeforeEl.length) { $shadowBeforeEl[0].style.opacity = offsetMultiplier > 0 ? offsetMultiplier : 0; }
					if ($shadowAfterEl.length) { $shadowAfterEl[0].style.opacity = (-offsetMultiplier) > 0 ? -offsetMultiplier : 0; }
				}
			}

			// Set correct perspective for IE10
			if (Support.pointerEvents || Support.prefixedPointerEvents) {
				var ws = $wrapperEl[0].style;
				ws.perspectiveOrigin = center + "px 50%";
			}
		},
		setTransition: function setTransition(duration) {
			var swiper = this;
			swiper.slides
				.transition(duration)
				.find('.swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left')
				.transition(duration);
		},
	};

	var EffectCoverflow = {
		name: 'effect-coverflow',
		params: {
			coverflowEffect: {
				rotate: 50,
				stretch: 0,
				depth: 100,
				modifier: 1,
				slideShadows: true,
			},
		},
		create: function create() {
			var swiper = this;
			Utils.extend(swiper, {
				coverflowEffect: {
					setTranslate: Coverflow.setTranslate.bind(swiper),
					setTransition: Coverflow.setTransition.bind(swiper),
				},
			});
		},
		on: {
			beforeInit: function beforeInit() {
				var swiper = this;
				if (swiper.params.effect !== 'coverflow') { return; }

				swiper.classNames.push(((swiper.params.containerModifierClass) + "coverflow"));
				swiper.classNames.push(((swiper.params.containerModifierClass) + "3d"));

				swiper.params.watchSlidesProgress = true;
				swiper.originalParams.watchSlidesProgress = true;
			},
			setTranslate: function setTranslate() {
				var swiper = this;
				if (swiper.params.effect !== 'coverflow') { return; }
				swiper.coverflowEffect.setTranslate();
			},
			setTransition: function setTransition(duration) {
				var swiper = this;
				if (swiper.params.effect !== 'coverflow') { return; }
				swiper.coverflowEffect.setTransition(duration);
			},
		},
	};

	var Thumbs = {
		init: function init() {
			var swiper = this;
			var ref = swiper.params;
			var thumbsParams = ref.thumbs;
			var SwiperClass = swiper.constructor;
			if (thumbsParams.swiper instanceof SwiperClass) {
				swiper.thumbs.swiper = thumbsParams.swiper;
				Utils.extend(swiper.thumbs.swiper.originalParams, {
					watchSlidesProgress: true,
					slideToClickedSlide: false,
				});
				Utils.extend(swiper.thumbs.swiper.params, {
					watchSlidesProgress: true,
					slideToClickedSlide: false,
				});
			} else if (Utils.isObject(thumbsParams.swiper)) {
				swiper.thumbs.swiper = new SwiperClass(Utils.extend({}, thumbsParams.swiper, {
					watchSlidesVisibility: true,
					watchSlidesProgress: true,
					slideToClickedSlide: false,
				}));
				swiper.thumbs.swiperCreated = true;
			}
			swiper.thumbs.swiper.$el.addClass(swiper.params.thumbs.thumbsContainerClass);
			swiper.thumbs.swiper.on('tap', swiper.thumbs.onThumbClick);
		},
		onThumbClick: function onThumbClick() {
			var swiper = this;
			var thumbsSwiper = swiper.thumbs.swiper;
			if (!thumbsSwiper) { return; }
			var clickedIndex = thumbsSwiper.clickedIndex;
			var clickedSlide = thumbsSwiper.clickedSlide;
			if (clickedSlide && $(clickedSlide).hasClass(swiper.params.thumbs.slideThumbActiveClass)) { return; }
			if (typeof clickedIndex === 'undefined' || clickedIndex === null) { return; }
			var slideToIndex;
			if (thumbsSwiper.params.loop) {
				slideToIndex = parseInt($(thumbsSwiper.clickedSlide).attr('data-swiper-slide-index'), 10);
			} else {
				slideToIndex = clickedIndex;
			}
			if (swiper.params.loop) {
				var currentIndex = swiper.activeIndex;
				if (swiper.slides.eq(currentIndex).hasClass(swiper.params.slideDuplicateClass)) {
					swiper.loopFix();
					// eslint-disable-next-line
					swiper._clientLeft = swiper.$wrapperEl[0].clientLeft;
					currentIndex = swiper.activeIndex;
				}
				var prevIndex = swiper.slides.eq(currentIndex).prevAll(("[data-swiper-slide-index=\"" + slideToIndex + "\"]")).eq(0).index();
				var nextIndex = swiper.slides.eq(currentIndex).nextAll(("[data-swiper-slide-index=\"" + slideToIndex + "\"]")).eq(0).index();
				if (typeof prevIndex === 'undefined') { slideToIndex = nextIndex; }
				else if (typeof nextIndex === 'undefined') { slideToIndex = prevIndex; }
				else if (nextIndex - currentIndex < currentIndex - prevIndex) { slideToIndex = nextIndex; }
				else { slideToIndex = prevIndex; }
			}
			swiper.slideTo(slideToIndex);
		},
		update: function update(initial) {
			var swiper = this;
			var thumbsSwiper = swiper.thumbs.swiper;
			if (!thumbsSwiper) { return; }

			var slidesPerView = thumbsSwiper.params.slidesPerView === 'auto'
				? thumbsSwiper.slidesPerViewDynamic()
				: thumbsSwiper.params.slidesPerView;

			if (swiper.realIndex !== thumbsSwiper.realIndex) {
				var currentThumbsIndex = thumbsSwiper.activeIndex;
				var newThumbsIndex;
				if (thumbsSwiper.params.loop) {
					if (thumbsSwiper.slides.eq(currentThumbsIndex).hasClass(thumbsSwiper.params.slideDuplicateClass)) {
						thumbsSwiper.loopFix();
						// eslint-disable-next-line
						thumbsSwiper._clientLeft = thumbsSwiper.$wrapperEl[0].clientLeft;
						currentThumbsIndex = thumbsSwiper.activeIndex;
					}
					// Find actual thumbs index to slide to
					var prevThumbsIndex = thumbsSwiper.slides.eq(currentThumbsIndex).prevAll(("[data-swiper-slide-index=\"" + (swiper.realIndex) + "\"]")).eq(0).index();
					var nextThumbsIndex = thumbsSwiper.slides.eq(currentThumbsIndex).nextAll(("[data-swiper-slide-index=\"" + (swiper.realIndex) + "\"]")).eq(0).index();
					if (typeof prevThumbsIndex === 'undefined') { newThumbsIndex = nextThumbsIndex; }
					else if (typeof nextThumbsIndex === 'undefined') { newThumbsIndex = prevThumbsIndex; }
					else if (nextThumbsIndex - currentThumbsIndex === currentThumbsIndex - prevThumbsIndex) { newThumbsIndex = currentThumbsIndex; }
					else if (nextThumbsIndex - currentThumbsIndex < currentThumbsIndex - prevThumbsIndex) { newThumbsIndex = nextThumbsIndex; }
					else { newThumbsIndex = prevThumbsIndex; }
				} else {
					newThumbsIndex = swiper.realIndex;
				}
				if (thumbsSwiper.visibleSlidesIndexes && thumbsSwiper.visibleSlidesIndexes.indexOf(newThumbsIndex) < 0) {
					if (thumbsSwiper.params.centeredSlides) {
						if (newThumbsIndex > currentThumbsIndex) {
							newThumbsIndex = newThumbsIndex - Math.floor(slidesPerView / 2) + 1;
						} else {
							newThumbsIndex = newThumbsIndex + Math.floor(slidesPerView / 2) - 1;
						}
					} else if (newThumbsIndex > currentThumbsIndex) {
						newThumbsIndex = newThumbsIndex - slidesPerView + 1;
					}
					thumbsSwiper.slideTo(newThumbsIndex, initial ? 0 : undefined);
				}
			}

			// Activate thumbs
			var thumbsToActivate = 1;
			var thumbActiveClass = swiper.params.thumbs.slideThumbActiveClass;

			if (swiper.params.slidesPerView > 1 && !swiper.params.centeredSlides) {
				thumbsToActivate = swiper.params.slidesPerView;
			}

			if (!swiper.params.thumbs.multipleActiveThumbs) {
				thumbsToActivate = 1;
			}

			thumbsToActivate = Math.floor(thumbsToActivate);

			thumbsSwiper.slides.removeClass(thumbActiveClass);
			if (thumbsSwiper.params.loop || (thumbsSwiper.params.virtual && thumbsSwiper.params.virtual.enabled)) {
				for (var i = 0; i < thumbsToActivate; i += 1) {
					thumbsSwiper.$wrapperEl.children(("[data-swiper-slide-index=\"" + (swiper.realIndex + i) + "\"]")).addClass(thumbActiveClass);
				}
			} else {
				for (var i$1 = 0; i$1 < thumbsToActivate; i$1 += 1) {
					thumbsSwiper.slides.eq(swiper.realIndex + i$1).addClass(thumbActiveClass);
				}
			}
		},
	};
	var Thumbs$1 = {
		name: 'thumbs',
		params: {
			thumbs: {
				multipleActiveThumbs: true,
				swiper: null,
				slideThumbActiveClass: 'swiper-slide-thumb-active',
				thumbsContainerClass: 'swiper-container-thumbs',
			},
		},
		create: function create() {
			var swiper = this;
			Utils.extend(swiper, {
				thumbs: {
					swiper: null,
					init: Thumbs.init.bind(swiper),
					update: Thumbs.update.bind(swiper),
					onThumbClick: Thumbs.onThumbClick.bind(swiper),
				},
			});
		},
		on: {
			beforeInit: function beforeInit() {
				var swiper = this;
				var ref = swiper.params;
				var thumbs = ref.thumbs;
				if (!thumbs || !thumbs.swiper) { return; }
				swiper.thumbs.init();
				swiper.thumbs.update(true);
			},
			slideChange: function slideChange() {
				var swiper = this;
				if (!swiper.thumbs.swiper) { return; }
				swiper.thumbs.update();
			},
			update: function update() {
				var swiper = this;
				if (!swiper.thumbs.swiper) { return; }
				swiper.thumbs.update();
			},
			resize: function resize() {
				var swiper = this;
				if (!swiper.thumbs.swiper) { return; }
				swiper.thumbs.update();
			},
			observerUpdate: function observerUpdate() {
				var swiper = this;
				if (!swiper.thumbs.swiper) { return; }
				swiper.thumbs.update();
			},
			setTransition: function setTransition(duration) {
				var swiper = this;
				var thumbsSwiper = swiper.thumbs.swiper;
				if (!thumbsSwiper) { return; }
				thumbsSwiper.setTransition(duration);
			},
			beforeDestroy: function beforeDestroy() {
				var swiper = this;
				var thumbsSwiper = swiper.thumbs.swiper;
				if (!thumbsSwiper) { return; }
				if (swiper.thumbs.swiperCreated && thumbsSwiper) {
					thumbsSwiper.destroy();
				}
			},
		},
	};

	// Swiper Class

	var components = [
		Device$1,
		Support$1,
		Browser$1,
		Resize,
		Observer$1,
		Virtual$1,
		Keyboard$1,
		Mousewheel$1,
		Navigation$1,
		Pagination$1,
		Scrollbar$1,
		Parallax$1,
		Zoom$1,
		Lazy$1,
		Controller$1,
		A11y,
		History$1,
		HashNavigation$1,
		Autoplay$1,
		EffectFade,
		EffectCube,
		EffectFlip,
		EffectCoverflow,
		Thumbs$1
	];

	if (typeof Swiper.use === 'undefined') {
		Swiper.use = Swiper.Class.use;
		Swiper.installModule = Swiper.Class.installModule;
	}

	Swiper.use(components);

	return Swiper;

}));
